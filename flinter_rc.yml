
# Flinter configuation file.


# These are all the regexp rules

# Set active to false is you want to skip  rule
# All are regexp rules, meaning you can add new rules simply by editing this file
# test your rule on https://regex101.com/ if needed

extension: f\d*

regexp-rules:

  missing-space-before-call-parameters:
    message: Missing space between subroutine name and parenthesis
    regexp: (?<=call\s)(\s*\w+)\(
    replacement: \1 (

  missing-space-after-call-parenthesis:
    message: Missing space after first parenthesis
    regexp: (?<=call\s)(\s*\w+\s*)\((\S)
    replacement: ( \2

  missing-space-before-call-parenthesis:
    message: Missing space before last parenthesis
    regexp: (?<=call\s)(\s*\w+\s*\([^)(]*(?:\([^)(]*(?:\([^)(]*\)[^)(]*)*\)[^)(]*)*(?<!\s))\)
    replacement: \1 )



  excessive-use-of-space:
    message: Except for indentation, single spaces are sufficient
    regexp: '(?<=\S)  +(?=[^\s!])'
    replacement: ' '

  missing-space-around-operator:
    message: Missing space around operator
    regexp: ([^\s=])({operators})([^\s=])
    replacement: \1 \2 \3

  missing-space-before-operator:
    message: Missing space before operator
    regexp: ([^\s=])({operators})(?=\s)
    replacement: \1 \2

  missing-space-after-operator:
    message: Missing space after operator
    regexp: (?<=\s)({operators})([^\s=])
    replacement: \1 \2

  missing-space-around-separator:
    message: Missing space around separator
    regexp: (\S)::(\S)
    replacement: '\1 :: \2'

  missing-space-before-separator:
    message: Missing space before separator
    regexp: (\S)::(?=\s)
    replacement: '\1 ::'

  missing-space-after-separator:
    message: Missing space after separator
    regexp: (?<=\s)::(\S)
    replacement: ':: \1'

  missing-space-after-ponctuation:
    message: Missing space after ponctuation
    regexp: ({ponctuations})(\S)
    replacement: \1 \2

  types-should-be-lowercased:
    message: Types should be lowercased
    regexp: \b({types_upper})\b
    case-sensitive: true
    active: false
  types-should-be-uppercased:
    message: Types should be uppercased
    regexp: \b({types})\b
    case-sensitive: true

  missing-space-before-parenthesis:
    message: Missing space before parenthesis
    regexp: ({structs})\(
    replacement: \1 (

  prepend-with-!$:
    message: Should prepend with "!$"
    regexp: ^(\s*)(use\s+omp_lib)
    replacement: '\1!$ \2'

  tabulation-insteadof-twospaces:
    message: Should use 2 spaces instead of tabulation
    regexp: \t
    replacement: '  '

  use-new-syntax-type:
    message: Use new syntax TYPE(kind)
    regexp: ({types})\*(\w+)
    replacement: \1(\2)

  one-space-before-comment:
    message: At least one space before comment
    regexp: (\S)\!
    replacement: \1 !

  one-space-after-comment:
    message: Exactly one space after comment
    regexp: \!(\S)
    replacement: '! \1'
    include-comments: true

  useless-eol-dotcomma:
    message: Useless ";" at end of line
    regexp: ;\s*$
    replacement: ''

  nospace-endif:
    message: Missing space after "end"
    regexp: \#endif
    replacement: null
    active: false

  nospace-end:
    message: Missing space after "end"
    regexp: end({blocks}|{structs})
    replacement: end \1

  missing-space-around-=:
    message: Missing space around "="
    regexp: ([^\s=])(?<!kind|.len)=([^\s=])
    replacement: \1 = \2

  missing-space-after-=:
    message: Missing space after "="
    regexp: (?<!kind|.len|...\s)\s+=([^\s=])
    replacement: = \1

  missing-space-before-=:
    message: Missing space before "="
    regexp: ([^\s=])(?<!kind|.len)=(?=\s)
    replacement: \1 =

  trailing-whitespaces:
    message: Trailing whitespaces
    regexp: ([ \t])+$
    replacement: ''
    include-comments: true

  reommended-use-of-sp-dp:
    message: You should use "sp" or "dp" instead
    regexp: \(kind\s*=\s*\d\s*\)

  reommended-use-of-brackets:
    message: You should use "[]" instead
    regexp: \(\\([^\)]*)\\\)
    replacement: '[\1]'

  reommended-use-mpi_f08:
    message: Should use "use mpi_f08" instead (or "use mpi" if not available)
    regexp: include\s+["\']mpif.h[\'"]

  not-recommended-bare-end:
    message: Bare end statement not recommended
    regexp: ^\s*end\s*$

  not-recommended-bare-stop:
    message: Bare stop statement not recommended
    regexp: ^\s*stop\s*$

  not-recommended-use-exit:
    message: exit is an extension and should be avoided
    regexp: \bexit\b

  not-recommended-use-goto:
    message: goto is hard to maintain, prone to spaghetti code.
    regexp: \bgoto\b

  not-recommended-use-double-precision:
    message: double precision is discouraged; use real instead.
    regexp: \bdouble\s+precision\b

  not-recommended-use-pause:
    message: pause is discouraged.
    regexp: \bpause\b

  not-recommended-use-include:
    message: include is discouraged, prefer use.
    regexp: \binclude\b

  problem-write:
    message: null
    regexp: write\(.*\)
    replacement: null
    active: false

  problem-open:
    message: null
    regexp: open *\([^\)]+\)
    replacement: null
    active: false

# These are rules that span over multiple lines, not accessible by regexp
# You you want to edit these rules or add your own, two options:
# - ask us.
# - fork the code.
structure-rules:
  file-line-lenght: 80
  file-line-number: 2000
  max-statements-in-context: 300   # Subroutine of function
  max-declared-locals: 35
  min-varlen: 1
  max-varlen: 30
  max-arguments: 10
  min-arglen: 1
  max-arglen: 70
  max-nesting-levels: 8
  var-declaration: '(?:{types})\s*(?:\(.*\))?\s*(?:::| )\s*([A-Za-z_]\w*(?:\s*,\s*[A-Za-z_]\w*)*)'

# These are the fortran syntax we use to parse the source
# A priori there is no need to edit, but Fortran is so vast in time...
syntax:
  types: 
    - real
    - character
    - logical
    - integer
    - complex
    - double precision

  operators:
    - '\.eq\.'
    - '=='
    - '\.neq\.'
    - '/='
    - '\.gt\.'
    - '>'
    - '\.lt\.'
    - '<'
    - '\.geq\.'
    - '>='
    - '\.leq\.'
    - '<='
    - '\.le\.'
    - '\.ge\.'
    - '\.and\.'
    - '\.or\.'

  structs:
    - if
    - select
    - case
    - while

  ponctuations:
    - ','
    - '\)'
    - ';'

  namespace_blocks:
    - program
    - module

  context_blocks:
    - function
    - subroutine

