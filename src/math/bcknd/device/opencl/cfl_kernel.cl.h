const char *cfl_kernel =
"#ifndef __MATH_CFL_KERNEL_CL__\n"
"#define __MATH_CFL_KERNEL_CL__\n"
"/*\n"
" Copyright (c) 2022, The Neko Authors\n"
" All rights reserved.\n"
"\n"
" Redistribution and use in source and binary forms, with or without\n"
" modification, are permitted provided that the following conditions\n"
" are met:\n"
"\n"
"   * Redistributions of source code must retain the above copyright\n"
"     notice, this list of conditions and the following disclaimer.\n"
"\n"
"   * Redistributions in binary form must reproduce the above\n"
"     copyright notice, this list of conditions and the following\n"
"     disclaimer in the documentation and/or other materials provided\n"
"     with the distribution.\n"
"\n"
"   * Neither the name of the authors nor the names of its\n"
"     contributors may be used to endorse or promote products derived\n"
"     from this software without specific prior written permission.\n"
"\n"
" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"
" \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n"
" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n"
" FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n"
" COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n"
" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n"
" BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n"
" LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n"
" CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n"
" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n"
" ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n"
" POSSIBILITY OF SUCH DAMAGE.\n"
"*/\n"
"\n"
"/**\n"
" * Device kernel for CFL\n"
" */\n"
"\n"
"#define DEFINE_CFL_KERNEL(LX, CHUNKS)                                          \\\n"
"__kernel void cfl_kernel_lx##LX(const double dt,                                 \\\n"
"				__global const double * __restrict__ u,	       \\\n"
"				__global const double * __restrict__ v,	       \\\n"
"				__global const double * __restrict__ w,	       \\\n"
"				__global const double * __restrict__ drdx,       \\\n"
"				__global const double * __restrict__ dsdx,       \\\n"
"				__global const double * __restrict__ dtdx,       \\\n"
"				__global const double * __restrict__ drdy,       \\\n"
"				__global const double * __restrict__ dsdy,       \\\n"
"				__global const double * __restrict__ dtdy,       \\\n"
"				__global const double * __restrict__ drdz,       \\\n"
"				__global const double * __restrict__ dsdz,       \\\n"
"				__global const double * __restrict__ dtdz,       \\\n"
"				__global const double * __restrict__ dr_inv,     \\\n"
"				__global const double * __restrict__ ds_inv,     \\\n"
"				__global const double * __restrict__ dt_inv,     \\\n"
"				__global const double * __restrict__ jacinv,     \\\n"
"				__global double * __restrict__ cfl_h) {	       \\\n"
"                                                                               \\\n"
"  int i,j,k;								       \\\n"
"                                                                               \\\n"
"  const int e = get_group_id(0);                                               \\\n"
"  const int iii = get_local_id(0);                                             \\\n"
"  const int nchunks = (LX * LX * LX - 1) / CHUNKS + 1;                         \\\n"
"                                                                               \\\n"
"  __local double shu[LX * LX * LX];                                              \\\n"
"  __local double shv[LX * LX * LX];                                              \\\n"
"  __local double shw[LX * LX * LX];                                              \\\n"
"                                                                               \\\n"
"  __local double shdr_inv[LX];                                                   \\\n"
"  __local double shds_inv[LX];                                                   \\\n"
"  __local double shdt_inv[LX];                                                   \\\n"
"                                                                               \\\n"
"  __local double shjacinv[LX * LX * LX];                                         \\\n"
"                                                                               \\\n"
"  __local double shcfl[256];                                                     \\\n"
"                                                                               \\\n"
"  if (iii < LX) {                                                              \\\n"
"    shdr_inv[iii] = dr_inv[iii];                                               \\\n"
"    shds_inv[iii] = ds_inv[iii];                                               \\\n"
"    shdt_inv[iii] = dt_inv[iii];                                               \\\n"
"  }                                                                            \\\n"
"                                                                               \\\n"
"  j = iii;                                                                     \\\n"
"  while(j < (LX * LX * LX)) {                                                  \\\n"
"    shu[j] = u[j + e * LX * LX * LX];                                          \\\n"
"    shv[j] = v[j + e * LX * LX * LX];                                          \\\n"
"    shw[j] = w[j + e * LX * LX * LX];                                          \\\n"
"                                                                               \\\n"
"    shjacinv[j] = jacinv[j + e * LX * LX * LX];                                \\\n"
"                                                                               \\\n"
"    j = j + CHUNKS;                                                            \\\n"
"  }                                                                            \\\n"
"                                                                               \\\n"
"  shcfl[iii] = 0.0;                                                            \\\n"
"                                                                               \\\n"
"  barrier(CLK_LOCAL_MEM_FENCE);                                                \\\n"
"                                                                               \\\n"
"  double cfl_tmp = 0.0;                                                          \\\n"
"  for (int n = 0; n < nchunks; n++) {                                          \\\n"
"    const int ijk = iii + n * CHUNKS;                                          \\\n"
"    const int jk = ijk / LX;                                                   \\\n"
"    i = ijk - jk * LX;                                                         \\\n"
"    k = jk / LX;                                                               \\\n"
"    j = jk - k * LX;                                                           \\\n"
"    if ( i < LX && j < LX && k < LX) {                                         \\\n"
"      const double cflr = fabs(dt * (( shu[ijk] * drdx[ijk + e * LX * LX * LX]   \\\n"
"                                     + shv[ijk] * drdy[ijk + e * LX * LX * LX] \\\n"
"                                     + shw[ijk] * drdz[ijk + e * LX * LX * LX] \\\n"
"                                     ) * shjacinv[ijk]) * shdr_inv[i]);        \\\n"
"      const double cfls = fabs(dt * (( shu[ijk] * dsdx[ijk + e * LX * LX * LX]   \\\n"
"                                     + shv[ijk] * dsdy[ijk + e * LX * LX * LX] \\\n"
"                                     + shw[ijk] * dsdz[ijk + e * LX * LX * LX] \\\n"
"                                     ) * shjacinv[ijk]) * shds_inv[j]);        \\\n"
"      const double cflt = fabs( dt * ( ( shu[ijk] * dtdx[ijk + e * LX * LX * LX] \\\n"
"                                      + shv[ijk] * dtdy[ijk + e * LX * LX * LX]\\\n"
"				      + shw[ijk] * dtdz[ijk + e * LX * LX * LX]\\\n"
"				      ) * shjacinv[ijk]) * shdt_inv[k]);       \\\n"
"                                                                               \\\n"
"      cfl_tmp = fmax(cflr + cfls + cflt, cfl_tmp);                             \\\n"
"                                                                               \\\n"
"    }                                                                          \\\n"
"  }                                                                            \\\n"
"  shcfl[iii] = cfl_tmp;                                                        \\\n"
"                                                                               \\\n"
"  i = (get_local_size(0)) >> 1;                                                \\\n"
"  while (i != 0) {                                                             \\\n"
"    if (iii < i) {                                                             \\\n"
"      shcfl[iii] = fmax(shcfl[iii], shcfl[iii + i]);                           \\\n"
"    }                                                                          \\\n"
"    barrier(CLK_LOCAL_MEM_FENCE);                                              \\\n"
"    i = i>>1;                                                                  \\\n"
"  }                                                                            \\\n"
"                                                                               \\\n"
"  if (get_local_id(0) == 0) {                                                  \\\n"
"    cfl_h[get_group_id(0)] = shcfl[0];                                         \\\n"
"  }                                                                            \\\n"
"}                                                                             \n"
"\n"
"DEFINE_CFL_KERNEL(2, 256)\n"
"DEFINE_CFL_KERNEL(3, 256)\n"
"DEFINE_CFL_KERNEL(4, 256)\n"
"DEFINE_CFL_KERNEL(5, 256)\n"
"DEFINE_CFL_KERNEL(6, 256)\n"
"DEFINE_CFL_KERNEL(7, 256)\n"
"DEFINE_CFL_KERNEL(8, 256)\n"
"DEFINE_CFL_KERNEL(9, 256)\n"
"DEFINE_CFL_KERNEL(10, 256)\n"
"DEFINE_CFL_KERNEL(11, 256)\n"
"DEFINE_CFL_KERNEL(12, 256)\n"
"\n"
"\n"
"#endif // __MATH_CFL_KERNEL_CL__\n"
;
