const char *lambda2_kernel =
"#ifndef __MATH_LAMBDA2_KERNEL_CL__\n"
"#define __MATH_LAMBDA2_KERNEL_CL__\n"
"/*\n"
" Copyright (c) 2023, The Neko Authors\n"
" All rights reserved.\n"
"\n"
" Redistribution and use in source and binary forms, with or without\n"
" modification, are permitted provided that the following conditions\n"
" are met:\n"
"\n"
"   * Redistributions of source code must retain the above copyright\n"
"     notice, this list of conditions and the following disclaimer.\n"
"\n"
"   * Redistributions in binary form must reproduce the above\n"
"     copyright notice, this list of conditions and the following\n"
"     disclaimer in the documentation and/or other materials provided\n"
"     with the distribution.\n"
"\n"
"   * Neither the name of the authors nor the names of its\n"
"     contributors may be used to endorse or promote products derived\n"
"     from this software without specific prior written permission.\n"
"\n"
" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"
" \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n"
" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n"
" FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n"
" COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n"
" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n"
" BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n"
" LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n"
" CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n"
" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n"
" ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n"
" POSSIBILITY OF SUCH DAMAGE.\n"
"*/\n"
"\n"
"/**\n"
" * Device kernel for lambda2\n"
" */\n"
"\n"
"inline double\n"
"eigen_val_calc(const double grad11,\n"
"               const double grad12,\n"
"               const double grad13,\n"
"               const double grad21,\n"
"               const double grad22,\n"
"               const double grad23,\n"
"               const double grad31,\n"
"               const double grad32,\n"
"               const double grad33) {\n"
"  \n"
"    double s11 = grad11;\n"
"    double s22 = grad22;\n"
"    double s33 = grad33;\n"
"    double s12 = 0.5*(grad12+grad21);\n"
"    double s13 = 0.5*(grad13+grad31);\n"
"    double s23 = 0.5*(grad23+grad32);\n"
"\n"
"    double o12 = 0.5*(grad12-grad21);\n"
"    double o13 = 0.5*(grad13-grad31);\n"
"    double o23 = 0.5*(grad23-grad32);\n"
"\n"
"    double a11 = s11*s11 + s12*s12 + s13*s13 - o12*o12 - o13*o13;\n"
"    double a12 = s11 * s12  +  s12 * s22  +  s13 * s23 - o13 * o23;\n"
"    double a13 = s11 * s13  +  s12 * s23  +  s13 * s33 + o12 * o23;\n"
"        \n"
"    double a22 = s12*s12 + s22*s22 + s23*s23 - o12*o12 - o23*o23;\n"
"    double a23 = s12 * s13 + s22 * s23 + s23 * s33 - o12 * o13;\n"
"    double a33 = s13*s13 + s23*s23 + s33*s33 - o13*o13 - o23*o23;\n"
"               \n"
"               \n"
"    double B = -(a11 + a22 + a33);\n"
"    double C = -(a12*a12 + a13*a13 + a23*a23 - a11 * a22 - a11 * a33 - a22 * a33);\n"
"    double D = -(2.0 * a12 * a13 * a23 - a11 * a23*a23 - a22 * a13*a13\n"
"            - a33 * a12*a12  +  a11 * a22 * a33);\n"
"                     \n"
"                     \n"
"    double q = (3.0 * C - B*B) / 9.0;\n"
"    double r = (9.0 * C * B - 27.0 * D - 2.0 * B*B*B) / 54.0;\n"
"\n"
"    double theta = acos( r / sqrt(-q*q*q) ); \n"
"    double pi = 4.0*atan(1.0);\n"
"    double eigen1 = 2.0 * sqrt(-q) * cos(theta / 3.0) - B / 3.0;\n"
"    double eigen2 = 2.0 * sqrt(-q) * cos((theta + 2.0 * pi) / 3.0) - B / 3.0;\n"
"    double eigen3 = 2.0 * sqrt(-q) * cos((theta + 4.0 * pi) / 3.0) - B / 3.0;\n"
"                                 \n"
"    if (eigen1 <= eigen2 && eigen2 <= eigen3)\n"
"        return eigen2;\n"
"    else if (eigen3 <= eigen2 && eigen2 <= eigen1)\n"
"        return eigen2;\n"
"    else if (eigen1 <= eigen3 && eigen3 <= eigen2)\n"
"        return eigen3;\n"
"    else if (eigen2 <= eigen3 && eigen3 <= eigen1)\n"
"        return eigen3;\n"
"    else if (eigen2 <= eigen1 && eigen1 <= eigen3)\n"
"        return eigen1;\n"
"    else if (eigen3 <= eigen1 && eigen1 <= eigen2)\n"
"        return eigen1;\n"
"    return 0.0;\n"
"}\n"
"\n"
"\n"
"#define DEFINE_LAMBDA2_KERNEL(LX, CHUNKS)                                      \\\n"
"__kernel void lambda2_kernel_lx##LX(__global double * __restrict__ lambda2,      \\\n"
"                                    __global const double * __restrict__ u,      \\\n"
"                                    __global const double * __restrict__ v,      \\\n"
"                                    __global const double * __restrict__ w,      \\\n"
"                                    __global const double * __restrict__ dx,     \\\n"
"                                    __global const double * __restrict__ dy,     \\\n"
"                                    __global const double * __restrict__ dz,     \\\n"
"                                    __global const double * __restrict__ drdx,   \\\n"
"                                    __global const double * __restrict__ dsdx,   \\\n"
"                                    __global const double * __restrict__ dtdx,   \\\n"
"                                    __global const double * __restrict__ drdy,   \\\n"
"                                    __global const double * __restrict__ dsdy,   \\\n"
"                                    __global const double * __restrict__ dtdy,   \\\n"
"                                    __global const double * __restrict__ drdz,   \\\n"
"                                    __global const double * __restrict__ dsdz,   \\\n"
"                                    __global const double * __restrict__ dtdz,   \\\n"
"                                    __global const double * __restrict__ jacinv){\\\n"
"                                                                               \\\n"
"                                                                               \\\n"
"  __local double shu[LX * LX * LX];                                              \\\n"
"  __local double shv[LX * LX * LX];                                              \\\n"
"  __local double shw[LX * LX * LX];                                              \\\n"
"                                                                               \\\n"
"  __local double shdx[LX * LX];                                                  \\\n"
"  __local double shdy[LX * LX];                                                  \\\n"
"  __local double shdz[LX * LX];                                                  \\\n"
"                                                                               \\\n"
"  int i,j,k;                                                                   \\\n"
"                                                                               \\\n"
"  const int e = get_group_id(0);                                               \\\n"
"  const int ele = get_group_id(0) * LX * LX * LX;                              \\\n"
"  const int iii = get_local_id(0);                                             \\\n"
"  const int nchunks = (LX * LX * LX - 1)/CHUNKS + 1;                           \\\n"
"                                                                               \\\n"
"                                                                               \\\n"
"  if (iii < (LX * LX)) {                                                       \\\n"
"    shdx[iii] = dx[iii];                                                       \\\n"
"    shdy[iii] = dy[iii];                                                       \\\n"
"    shdz[iii] = dz[iii];                                                       \\\n"
"  }                                                                            \\\n"
"                                                                               \\\n"
"  j = iii;                                                                     \\\n"
"  while(j < (LX * LX * LX)) {                                                  \\\n"
"    shu[j] = u[j + ele];                                                       \\\n"
"    shv[j] = v[j + ele];                                                       \\\n"
"    shw[j] = w[j + ele];                                                       \\\n"
"    j = j + CHUNKS;                                                            \\\n"
"  }                                                                            \\\n"
"                                                                               \\\n"
"  barrier(CLK_LOCAL_MEM_FENCE);                                                \\\n"
"                                                                               \\\n"
"  for (int n = 0; n < nchunks; n++) {                                          \\\n"
"    const int ijk = iii + n * CHUNKS;                                          \\\n"
"    const int jk = ijk / LX;                                                   \\\n"
"    i = ijk - jk * LX;                                                         \\\n"
"    k = jk / LX;                                                               \\\n"
"    j = jk - k * LX;                                                           \\\n"
"    if ( i < LX && j < LX && k < LX ) {                                        \\\n"
"                                                                               \\\n"
"      double rtmpu = 0.0;                                                        \\\n"
"      double stmpu = 0.0;                                                        \\\n"
"      double ttmpu = 0.0;                                                        \\\n"
"                                                                               \\\n"
"      double rtmpv = 0.0;                                                        \\\n"
"      double stmpv = 0.0;                                                        \\\n"
"      double ttmpv = 0.0;                                                        \\\n"
"                                                                               \\\n"
"      double rtmpw = 0.0;                                                        \\\n"
"      double stmpw = 0.0;                                                        \\\n"
"      double ttmpw = 0.0;                                                        \\\n"
"                                                                               \\\n"
"      for (int l = 0; l < LX; l++) {		                               \\\n"
"        rtmpu += shdx[i + l * LX] * shu[l + j * LX + k * LX * LX];	       \\\n"
"        stmpu += shdy[j + l * LX] * shu[i + l * LX + k * LX * LX];             \\\n"
"        ttmpu += shdz[k + l * LX] * shu[i + j * LX + l * LX * LX];             \\\n"
"	                                                                       \\\n"
"        rtmpv += shdx[i + l * LX] * shv[l + j * LX + k * LX * LX];	       \\\n"
"        stmpv += shdy[j + l * LX] * shv[i + l * LX + k * LX * LX];             \\\n"
"        ttmpv += shdz[k + l * LX] * shv[i + j * LX + l * LX * LX];             \\\n"
"	                                                                       \\\n"
"        rtmpw += shdx[i + l * LX] * shw[l + j * LX + k * LX * LX];	       \\\n"
"        stmpw += shdy[j + l * LX] * shw[i + l * LX + k * LX * LX];             \\\n"
"        ttmpw += shdz[k + l * LX] * shw[i + j * LX + l * LX * LX];             \\\n"
"      }                                                                        \\\n"
"                                                                               \\\n"
"      double jinv = jacinv[ijk + ele];                                           \\\n"
"                                                                               \\\n"
"      double grad11 = jinv                                                       \\\n"
"	  * (drdx[ijk + ele] * rtmpu                                           \\\n"
"	   + dsdx[ijk + ele] * stmpu                                           \\\n"
"	   + dtdx[ijk + ele] * ttmpu);                                         \\\n"
"                                                                               \\\n"
"      double grad12 = jinv                                                       \\\n"
"	  * (drdy[ijk + ele] * rtmpu                                           \\\n"
"	   + dsdy[ijk + ele] * stmpu                                           \\\n"
"	   + dtdy[ijk + ele] * ttmpu);                                         \\\n"
"                                                                               \\\n"
"      double grad13 = jinv                                                       \\\n"
"	  * (drdz[ijk + ele] * rtmpu                                           \\\n"
"	   + dsdz[ijk + ele] * stmpu                                           \\\n"
"	   + dtdz[ijk + ele] * ttmpu);                                         \\\n"
"                                                                               \\\n"
"      double grad21 = jinv                                                       \\\n"
"	  * (drdx[ijk + ele] * rtmpv                                           \\\n"
"	   + dsdx[ijk + ele] * stmpv                                           \\\n"
"	   + dtdx[ijk + ele] * ttmpv);                                         \\\n"
"                                                                               \\\n"
"      double grad22 = jinv                                                       \\\n"
"	  * (drdy[ijk + ele] * rtmpv                                           \\\n"
"	   + dsdy[ijk + ele] * stmpv                                           \\\n"
"	   + dtdy[ijk + ele] * ttmpv);                                         \\\n"
"                                                                               \\\n"
"      double grad23 = jinv                                                       \\\n"
"	  * (drdz[ijk + ele] * rtmpv                                           \\\n"
"	   + dsdz[ijk + ele] * stmpv                                           \\\n"
"	   + dtdz[ijk + ele] * ttmpv);                                         \\\n"
"                                                                               \\\n"
"      double grad31 = jinv                                                       \\\n"
"	  * (drdx[ijk + ele] * rtmpw                                           \\\n"
"	   + dsdx[ijk + ele] * stmpw                                           \\\n"
"	   + dtdx[ijk + ele] * ttmpw);                                         \\\n"
"                                                                               \\\n"
"      double grad32 = jinv                                                       \\\n"
"	  * (drdy[ijk + ele] * rtmpw                                           \\\n"
"	   + dsdy[ijk + ele] * stmpw                                           \\\n"
"	   + dtdy[ijk + ele] * ttmpw);                                         \\\n"
"                                                                               \\\n"
"      double grad33 = jinv                                                       \\\n"
"	  * (drdz[ijk + ele] * rtmpw                                           \\\n"
"	   + dsdz[ijk + ele] * stmpw                                           \\\n"
"	   + dtdz[ijk + ele] * ttmpw);                                         \\\n"
"      lambda2[ijk + e*LX*LX*LX] = eigen_val_calc( grad11, grad12, grad13,      \\\n"
"                                                  grad21, grad22, grad23,      \\\n"
"                                                  grad31, grad32, grad33);     \\\n"
"    }                                                                          \\\n"
"  }                                                                            \\\n"
"}                              \n"
"                                                                               \n"
"DEFINE_LAMBDA2_KERNEL(1, 256)\n"
"DEFINE_LAMBDA2_KERNEL(2, 256)\n"
"DEFINE_LAMBDA2_KERNEL(3, 256)\n"
"DEFINE_LAMBDA2_KERNEL(4, 256)\n"
"DEFINE_LAMBDA2_KERNEL(5, 256)\n"
"DEFINE_LAMBDA2_KERNEL(6, 256)\n"
"DEFINE_LAMBDA2_KERNEL(7, 256)\n"
"DEFINE_LAMBDA2_KERNEL(8, 256)\n"
"DEFINE_LAMBDA2_KERNEL(9, 256)\n"
"DEFINE_LAMBDA2_KERNEL(10, 256)\n"
"DEFINE_LAMBDA2_KERNEL(11, 256)\n"
"DEFINE_LAMBDA2_KERNEL(12, 256)\n"
"\n"
"\n"
"#endif // __MATH_LAMBDA2_KERNEL_CL__\n"
;
