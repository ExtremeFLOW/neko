const char *ax_helm_kernel =
"#ifndef __MATH_AX_HELM_KERNEL_CL__\n"
"#define __MATH_AX_HELM_KERNEL_CL__\n"
"/*\n"
" Copyright (c) 2021-2022, The Neko Authors\n"
" All rights reserved.\n"
"\n"
" Redistribution and use in source and binary forms, with or without\n"
" modification, are permitted provided that the following conditions\n"
" are met:\n"
"\n"
"   * Redistributions of source code must retain the above copyright\n"
"     notice, this list of conditions and the following disclaimer.\n"
"\n"
"   * Redistributions in binary form must reproduce the above\n"
"     copyright notice, this list of conditions and the following\n"
"     disclaimer in the documentation and/or other materials provided\n"
"     with the distribution.\n"
"\n"
"   * Neither the name of the authors nor the names of its\n"
"     contributors may be used to endorse or promote products derived\n"
"     from this software without specific prior written permission.\n"
"\n"
" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"
" \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n"
" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n"
" FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n"
" COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n"
" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n"
" BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n"
" LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n"
" CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n"
" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n"
" ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n"
" POSSIBILITY OF SUCH DAMAGE.\n"
"*/\n"
"\n"
"/**\n"
" * Device kernel for Ax helm\n"
" */\n"
"\n"
"#define DEFINE_AX_HELM_KERNEL(LX, CHUNKS)                                      \\\n"
"__kernel void ax_helm_kernel_lx##LX(__global double * __restrict__ w,            \\\n"
"                                    __global const double * __restrict__ u,      \\\n"
"                                    __global const double * __restrict__ dx,     \\\n"
"                                    __global const double * __restrict__ dy,     \\\n"
"                                    __global const double * __restrict__ dz,     \\\n"
"                                    __global const double * __restrict__ dxt,    \\\n"
"                                    __global const double * __restrict__ dyt,    \\\n"
"                                    __global const double * __restrict__ dzt,    \\\n"
"                                    __global const double * __restrict__ h1,     \\\n"
"                                    __global const double * __restrict__ g11,    \\\n"
"                                    __global const double * __restrict__ g22,    \\\n"
"                                    __global const double * __restrict__ g33,    \\\n"
"                                    __global const double * __restrict__ g12,    \\\n"
"                                    __global const double * __restrict__ g13,    \\\n"
"                                    __global const double * __restrict__ g23) {  \\\n"
"                                                                               \\\n"
"  __local double shdx[LX*LX];                                                    \\\n"
"  __local double shdy[LX*LX];                                                    \\\n"
"  __local double shdzt[LX*LX];                                                   \\\n"
"                                                                               \\\n"
"  __local double shdxt[LX*LX];                                                   \\\n"
"  __local double shdyt[LX*LX];                                                   \\\n"
"  __local double shdz[LX*LX];                                                    \\\n"
"                                                                               \\\n"
"  __local double shu[LX*LX*LX];                                                  \\\n"
"  __local double shur[LX*LX*LX];                                                 \\\n"
"  __local double shus[LX*LX*LX];                                                 \\\n"
"  __local double shut[LX*LX*LX];                                                 \\\n"
"                                                                               \\\n"
"  int l,i,j,k,n;                                                               \\\n"
"                                                                               \\\n"
"  const int e = get_group_id(0);                                               \\\n"
"  const int iii = get_local_id(0);                                             \\\n"
"  const int nchunks = (LX * LX * LX - 1)/CHUNKS + 1;                           \\\n"
"                                                                               \\\n"
"  if (iii<LX*LX) {                                                             \\\n"
"    shdx[iii] = dx[iii];                                                       \\\n"
"    shdy[iii] = dy[iii];                                                       \\\n"
"    shdz[iii] = dz[iii];                                                       \\\n"
"  }                                                                            \\\n"
"  i = iii;                                                                     \\\n"
"  while (i < LX * LX * LX){                                                    \\\n"
"    shu[i] = u[i+e*LX*LX*LX];                                                  \\\n"
"    i = i + CHUNKS;                                                            \\\n"
"  }                                                                            \\\n"
"                                                                               \\\n"
"  barrier(CLK_LOCAL_MEM_FENCE);                                                \\\n"
"                                                                               \\\n"
"  if (iii<LX*LX){                                                              \\\n"
"    shdxt[iii] = dxt[iii];                                                     \\\n"
"    shdyt[iii] = dyt[iii];                                                     \\\n"
"    shdzt[iii] = dzt[iii];                                                     \\\n"
"  }                                                                            \\\n"
"                                                                               \\\n"
"  for (n=0; n<nchunks; n++){                                                   \\\n"
"    const int ijk = iii+n*CHUNKS;                                              \\\n"
"    const int jk = ijk/LX;                                                     \\\n"
"    i = ijk-jk*LX;                                                             \\\n"
"    k = jk/LX;                                                                 \\\n"
"    j = jk-k*LX;                                                               \\\n"
"    if (i<LX && j<LX && k<LX && ijk < LX*LX*LX) {                              \\\n"
"      double rtmp = 0.0;                                                         \\\n"
"      double stmp = 0.0;                                                         \\\n"
"      double ttmp = 0.0;                                                         \\\n"
"      for (l = 0; l<LX; l++){                                                  \\\n"
"        rtmp = rtmp + shdx[i+l*LX] * shu[l+j*LX+k*LX*LX];                      \\\n"
"        stmp = stmp + shdy[j+l*LX] * shu[i+l*LX+k*LX*LX];                      \\\n"
"        ttmp = ttmp + shdz[k+l*LX] * shu[i+j*LX+l*LX*LX];                      \\\n"
"      }                                                                        \\\n"
"      shur[ijk] = h1[ijk+e*LX*LX*LX]                                           \\\n"
"                * (g11[ijk+e*LX*LX*LX] * rtmp                                  \\\n"
"                   + g12[ijk+e*LX*LX*LX] * stmp                                \\\n"
"                   + g13[ijk+e*LX*LX*LX] * ttmp);                              \\\n"
"      shus[ijk] = h1[ijk+e*LX*LX*LX]                                           \\\n"
"                * (g12[ijk+e*LX*LX*LX] * rtmp                                  \\\n"
"                   + g22[ijk+e*LX*LX*LX] * stmp                                \\\n"
"                   + g23[ijk+e*LX*LX*LX] * ttmp);                              \\\n"
"      shut[ijk] = h1[ijk+e*LX*LX*LX]                                           \\\n"
"                * (g13[ijk+e*LX*LX*LX] * rtmp                                  \\\n"
"                   + g23[ijk+e*LX*LX*LX] * stmp                                \\\n"
"                   + g33[ijk+e*LX*LX*LX] * ttmp);                              \\\n"
"    }                                                                          \\\n"
"  }                                                                            \\\n"
"                                                                               \\\n"
"  barrier(CLK_LOCAL_MEM_FENCE);                                                \\\n"
"                                                                               \\\n"
"  for (n=0; n<nchunks; n++){                                                   \\\n"
"    const int ijk = iii+n*CHUNKS;                                              \\\n"
"    const int jk = ijk/LX;                                                     \\\n"
"    i = ijk-jk*LX;                                                             \\\n"
"    k = jk/LX;                                                                 \\\n"
"    j = jk-k*LX;                                                               \\\n"
"    if (i<LX && j<LX && k<LX && ijk <LX*LX*LX) {                               \\\n"
"      double wijke = 0.0;                                                        \\\n"
"      for (l = 0; l<LX; l++){                                                  \\\n"
"        wijke = wijke                                                          \\\n"
"              + shdxt[i+l*LX] * shur[l+j*LX+k*LX*LX]                           \\\n"
"              + shdyt[j+l*LX] * shus[i+l*LX+k*LX*LX]                           \\\n"
"              + shdzt[k+l*LX] * shut[i+j*LX+l*LX*LX];                          \\\n"
"      }                                                                        \\\n"
"      w[ijk+e*LX*LX*LX] = wijke;                                               \\\n"
"    }                                                                          \\\n"
"  }                                                                            \\\n"
"}\n"
"\n"
"DEFINE_AX_HELM_KERNEL(1, 256)\n"
"DEFINE_AX_HELM_KERNEL(2, 256)\n"
"DEFINE_AX_HELM_KERNEL(3, 256)\n"
"DEFINE_AX_HELM_KERNEL(4, 256)\n"
"DEFINE_AX_HELM_KERNEL(5, 256)\n"
"DEFINE_AX_HELM_KERNEL(6, 256)\n"
"DEFINE_AX_HELM_KERNEL(7, 256)\n"
"DEFINE_AX_HELM_KERNEL(8, 256)\n"
"DEFINE_AX_HELM_KERNEL(9, 256)\n"
"DEFINE_AX_HELM_KERNEL(10, 256)\n"
"DEFINE_AX_HELM_KERNEL(11, 256)\n"
"DEFINE_AX_HELM_KERNEL(12, 256)\n"
"\n"
"\n"
"#endif // __MATH_AX_HELM_KERNEL_CL__\n"
;
