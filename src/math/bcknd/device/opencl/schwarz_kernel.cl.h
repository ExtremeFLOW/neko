const char *schwarz_kernel =
"#ifndef __MATH_SCHWARZ_KERNEL_CL__\n"
"#define __MATH_SCHWARZ_KERNEL_CL__\n"
"/*\n"
" Copyright (c) 2022-2023, The Neko Authors\n"
" All rights reserved.\n"
"\n"
" Redistribution and use in source and binary forms, with or without\n"
" modification, are permitted provided that the following conditions\n"
" are met:\n"
"\n"
"   * Redistributions of source code must retain the above copyright\n"
"     notice, this list of conditions and the following disclaimer.\n"
"\n"
"   * Redistributions in binary form must reproduce the above\n"
"     copyright notice, this list of conditions and the following\n"
"     disclaimer in the documentation and/or other materials provided\n"
"     with the distribution.\n"
"\n"
"   * Neither the name of the authors nor the names of its\n"
"     contributors may be used to endorse or promote products derived\n"
"     from this software without specific prior written permission.\n"
"\n"
" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"
" \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n"
" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n"
" FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n"
" COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n"
" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n"
" BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n"
" LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n"
" CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n"
" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n"
" ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n"
" POSSIBILITY OF SUCH DAMAGE.\n"
"*/\n"
"\n"
"/**\n"
" * Device kernel for schwarz extrude\n"
" * This can probably be done i a better way...\n"
" * We sum the \"shell\" of a1 that is l1 steps in scaled with f1\n"
" * with the shell of a2 that is l2 steps in and scale with f3.\n"
" * Right now we just thorw away all arrays that are not\n"
" * on the first face of dimension (nx-2)(nx-2)\n"
" * It should be noted that a1, a2 are often the same array.\n"
" * If l1,l2 are not the same or if one is not 0 this might lead to a race.\n"
" */\n"
"#define DEFINE_SCHWARZ_EXTRUDE_KERNEL(NX)                                      \\\n"
"__kernel void schwarz_extrude_kernel_nx##NX(__global double * a1,                \\\n"
"                                            const int l1,                      \\\n"
"                                            const double f1,                     \\\n"
"                                            __global double * a2,                \\\n"
"                                            const int l2,                      \\\n"
"                                            const double f2) {                   \\\n"
"                                                                               \\\n"
"  const int idx = get_local_id(0);                                             \\\n"
"  const int el = get_group_id(0)*NX*NX*NX;                                     \\\n"
"  const int x = idx%(NX-2) + 1;                                                \\\n"
"  const int y = idx/(NX-2) + 1;                                                \\\n"
"  int idx1,idx2;                                                               \\\n"
"                                                                               \\\n"
"  idx1 = l1 + x*NX + y*NX*NX + el;                                             \\\n"
"  idx2 = l2 + x*NX + y*NX*NX + el;                                             \\\n"
"  a1[idx1] = f1*a1[idx1] + f2*a2[idx2];                                        \\\n"
"                                                                               \\\n"
"  idx1 = (NX-1-l1) + x*NX + y*NX*NX + el;                                      \\\n"
"  idx2 = (NX-1-l2) + x*NX + y*NX*NX + el;                                      \\\n"
"  a1[idx1] = f1*a1[idx1] + f2*a2[idx2];                                        \\\n"
"                                                                               \\\n"
"  barrier(CLK_LOCAL_MEM_FENCE);                                                \\\n"
"                                                                               \\\n"
"  idx1 = x + l1*NX + y*NX*NX + el;                                             \\\n"
"  idx2 = x + l2*NX + y*NX*NX + el;                                             \\\n"
"  a1[idx1] = f1*a1[idx1] + f2*a2[idx2];                                        \\\n"
"                                                                               \\\n"
"  idx1 = x + (NX-1-l1)*NX + y*NX*NX + el;                                      \\\n"
"  idx2 = x + (NX-1-l2)*NX + y*NX*NX + el;                                      \\\n"
"  a1[idx1] = f1*a1[idx1] + f2*a2[idx2];                                        \\\n"
"                                                                               \\\n"
"  barrier(CLK_LOCAL_MEM_FENCE);                                                \\\n"
"                                                                               \\\n"
"  idx1 = x + y*NX + l1*NX*NX + el;                                             \\\n"
"  idx2 = x + y*NX + l2*NX*NX + el;                                             \\\n"
"  a1[idx1] = f1*a1[idx1] + f2*a2[idx2];                                        \\\n"
"                                                                               \\\n"
"  idx1 = x + y*NX + (NX-1-l1)*NX*NX + el;                                      \\\n"
"  idx2 = x + y*NX + (NX-1-l2)*NX*NX + el;                                      \\\n"
"  a1[idx1] = f1*a1[idx1] + f2*a2[idx2];                                        \\\n"
"}\n"
"\n"
"DEFINE_SCHWARZ_EXTRUDE_KERNEL(2);\n"
"DEFINE_SCHWARZ_EXTRUDE_KERNEL(3);\n"
"DEFINE_SCHWARZ_EXTRUDE_KERNEL(4);\n"
"DEFINE_SCHWARZ_EXTRUDE_KERNEL(5);\n"
"DEFINE_SCHWARZ_EXTRUDE_KERNEL(6);\n"
"DEFINE_SCHWARZ_EXTRUDE_KERNEL(7);\n"
"DEFINE_SCHWARZ_EXTRUDE_KERNEL(8);\n"
"DEFINE_SCHWARZ_EXTRUDE_KERNEL(9);\n"
"DEFINE_SCHWARZ_EXTRUDE_KERNEL(10);\n"
"DEFINE_SCHWARZ_EXTRUDE_KERNEL(11);\n"
"DEFINE_SCHWARZ_EXTRUDE_KERNEL(12);\n"
"DEFINE_SCHWARZ_EXTRUDE_KERNEL(13);\n"
"DEFINE_SCHWARZ_EXTRUDE_KERNEL(14);\n"
"DEFINE_SCHWARZ_EXTRUDE_KERNEL(15);\n"
"DEFINE_SCHWARZ_EXTRUDE_KERNEL(16);\n"
"\n"
"/**\n"
" * Device kernel for schwarz extrude\n"
" */\n"
"__kernel void schwarz_toext3d_kernel(__global double * __restrict__ a,\n"
"                                     __global double * __restrict__ b,\n"
"                                     const int nx) {\n"
"\n"
"  const int idx = get_local_id(0);\n"
"  const int nx2 = nx+2;\n"
"  const int el2 = get_group_id(0) * nx2*nx2*nx2;\n"
"  const int el = get_group_id(0) * nx*nx*nx;\n"
"  for(int i = idx; i<nx2*nx2*nx2; i+=get_local_size(0)){\n"
"    a[i+el2] = 0.0;\n"
"  }\n"
"\n"
"  barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"  for(int ijk = idx; ijk<nx*nx*nx; ijk+=get_local_size(0)){\n"
"    const int jk = ijk / nx;\n"
"    const int i = ijk - jk * nx;\n"
"    const int k = jk / nx;\n"
"    const int j = jk - k * nx;\n"
"    a[(i+1)+(j+1)*nx2+(k+1)*nx2*nx2+el2] = b[ijk+el];\n"
"  }\n"
"}\n"
"\n"
"__kernel void schwarz_toreg3d_kernel(__global double * __restrict__ b,\n"
"                                     __global double * __restrict__ a,\n"
"                                     const int nx) {\n"
"\n"
"  const int idx = get_local_id(0);\n"
"  const int nx2 = nx+2;\n"
"  const int el2 = get_group_id(0) * nx2*nx2*nx2;\n"
"  const int el = get_group_id(0) * nx*nx*nx;\n"
"  for(int ijk = idx; ijk<nx*nx*nx; ijk+=get_local_size(0)){\n"
"    const int jk = ijk / nx;\n"
"    const int i = ijk - jk * nx;\n"
"    const int k = jk / nx;\n"
"    const int j = jk - k * nx;\n"
"    b[ijk+el] = a[(i+1)+(j+1)*nx2+(k+1)*nx2*nx2+el2];\n"
"  }\n"
"}\n"
"\n"
"#endif // __MATH_SCHWARZ_KERNEL_CL__\n"
;
