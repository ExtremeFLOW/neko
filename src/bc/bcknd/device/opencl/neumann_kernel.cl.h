const char *neumann_kernel =
"/*\n"
" Copyright (c) 2025, The Neko Authors\n"
" All rights reserved.\n"
"\n"
" Redistribution and use in source and binary forms, with or without\n"
" modification, are permitted provided that the following conditions\n"
" are met:\n"
"\n"
"   * Redistributions of source code must retain the above copyright\n"
"     notice, this list of conditions and the following disclaimer.\n"
"\n"
"   * Redistributions in binary form must reproduce the above\n"
"     copyright notice, this list of conditions and the following\n"
"     disclaimer in the documentation and/or other materials provided\n"
"     with the distribution.\n"
"\n"
"   * Neither the name of the authors nor the names of its\n"
"     contributors may be used to endorse or promote products derived\n"
"     from this software without specific prior written permission.\n"
"\n"
" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"
" \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n"
" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n"
" FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n"
" COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n"
" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n"
" BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n"
" LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n"
" CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n"
" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n"
" ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n"
" POSSIBILITY OF SUCH DAMAGE.\n"
"*/\n"
"\n"
"#ifndef __BC_NEUMANN_KERNEL__\n"
"#define __BC_NEUMANN_KERNEL__\n"
"\n"
"/**\n"
" * Computes the linear index for area and normal arrays\n"
" * @note Fortran indexing input, C indexing output\n"
" */\n"
"#define coef_normal_area_idx(i, j, k, l, lx, nf) \\\n"
"  (((i) + (lx) * (((j) - 1) + (lx) * (((k) - 1) + (nf) * (((l) - 1))))) - 1)\n"
"\n"
"/**\n"
" * Device function to compute i,j,k,e indices from a linear index\n"
" * @note Assumes idx is a Fortran index\n"
" */\n"
"void nonlinear_index(const int idx, const int lx, int *index) {\n"
"  const int idx2 = idx -1;\n"
"  index[3] = idx2/(lx * lx * lx) ;\n"
"  index[2] = (idx2 - (lx*lx*lx)*index[3])/(lx * lx);\n"
"  index[1] = (idx2 - (lx*lx*lx)*index[3] - (lx*lx) * index[2]) / lx;\n"
"  index[0] = (idx2 - (lx*lx*lx)*index[3] - (lx*lx) * index[2]) - lx*index[1];\n"
"  index[0]++;\n"
"  index[1]++;\n"
"  index[2]++;\n"
"  index[3]++;\n"
"}\n"
"\n"
"/**\n"
" * Device kernel for neumann scalar boundary condition\n"
" */\n"
"__kernel\n"
"void neumann_apply_scalar_kernel(__global const int *msk,\n"
"                                 __global const int *facet,\n"
"                                 __global double *x,\n"
"                                 __global const double *flux,\n"
"                                 __global const double *area,\n"
"                                 const int lx,\n"
"                                 const int m) {\n"
"  int index[4];\n"
"  const int idx = get_global_id(0);\n"
"  const int str = get_global_size(0);\n"
"\n"
"  for (int i = (idx + 1); i < m; i += str) {\n"
"    const int k = (msk[i] - 1);\n"
"    const int f = (facet[i]);\n"
"    nonlinear_index(msk[i], lx, index);\n"
"\n"
"    switch(f) {\n"
"    case 1:\n"
"    case 2:\n"
"      {\n"
"        const int na_idx = coef_normal_area_idx(index[1], index[2],\n"
"                                              f, index[3], lx, 6);\n"
"        x[k] += flux[i-1] * area[na_idx];\n"
"        break;\n"
"      }\n"
"    case 3:\n"
"    case 4:\n"
"      {\n"
"        const int na_idx = coef_normal_area_idx(index[0], index[2],\n"
"                                              f, index[3], lx, 6);\n"
"        x[k] += flux[i-1] * area[na_idx];\n"
"        break;\n"
"      }\n"
"    case 5:\n"
"    case 6:\n"
"      {\n"
"        const int na_idx = coef_normal_area_idx(index[0], index[1],\n"
"                                              f, index[3], lx, 6);\n"
"        x[k] += flux[i-1] * area[na_idx];\n"
"        break;\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"#endif\n"
;
