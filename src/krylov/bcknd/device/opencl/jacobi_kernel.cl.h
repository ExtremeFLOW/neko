const char *jacobi_kernel =
"#ifndef __KRYLOV_JACOBI_KERNEL_CL__\n"
"#define __KRYLOV_JACOBI_KERNEL_CL__\n"
"/*\n"
" Copyright (c) 2022, The Neko Authors\n"
" All rights reserved.\n"
"\n"
" Redistribution and use in source and binary forms, with or without\n"
" modification, are permitted provided that the following conditions\n"
" are met:\n"
"\n"
"   * Redistributions of source code must retain the above copyright\n"
"     notice, this list of conditions and the following disclaimer.\n"
"\n"
"   * Redistributions in binary form must reproduce the above\n"
"     copyright notice, this list of conditions and the following\n"
"     disclaimer in the documentation and/or other materials provided\n"
"     with the distribution.\n"
"\n"
"   * Neither the name of the authors nor the names of its\n"
"     contributors may be used to endorse or promote products derived\n"
"     from this software without specific prior written permission.\n"
"\n"
" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"
" \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n"
" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n"
" FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n"
" COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n"
" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n"
" BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n"
" LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n"
" CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n"
" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n"
" ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n"
" POSSIBILITY OF SUCH DAMAGE.\n"
"*/\n"
"\n"
"/**\n"
" * Device kernel for jacobi\n"
" */\n"
"\n"
"#define DEFINE_JACOBI_KERNEL(LX)                                               \\\n"
"__kernel void jacobi_kernel_lx##LX(__global double * __restrict__ du,            \\\n"
"                                   __global const double * __restrict__ dxt,     \\\n"
"                                   __global const double * __restrict__ dyt,     \\\n"
"                                   __global const double * __restrict__ dzt,     \\\n"
"                                   __global const double * __restrict__ G11,     \\\n"
"                                   __global const double * __restrict__ G22,     \\\n"
"                                   __global const double * __restrict__ G33,     \\\n"
"                                   __global const double * __restrict__ G12,     \\\n"
"                                   __global const double * __restrict__ G13,     \\\n"
"                                   __global const double * __restrict__ G23,     \\\n"
"                                   const int nel) {                            \\\n"
"                                                                               \\\n"
"  const int idx = get_global_id(0);                                            \\\n"
"  const int e = idx / (LX*LX*LX);                                              \\\n"
"  const int ijk = idx - e*LX*LX*LX;                                            \\\n"
"  const int jk = ijk / LX;                                                     \\\n"
"  const int i = ijk - jk * LX;                                                 \\\n"
"  const int k = jk / LX;                                                       \\\n"
"  const int j = jk - k * LX;                                                   \\\n"
"                                                                               \\\n"
"  if (e >= nel)                                                                \\\n"
"    return;                                                                    \\\n"
"                                                                               \\\n"
"  double d = 0.0;                                                                \\\n"
"                                                                               \\\n"
"  for (int l = 0; l < LX; l++) {                                               \\\n"
"    double g = G11[l + LX*j + LX*LX*k + LX*LX*LX*e];                             \\\n"
"    double t = dxt[i + LX*l];                                                    \\\n"
"    d += g*t*t;                                                                \\\n"
"  }                                                                            \\\n"
"                                                                               \\\n"
"  for (int l = 0; l < LX; l++) {                                               \\\n"
"    double g = G22[i + LX*l + LX*LX*k + LX*LX*LX*e];                             \\\n"
"    double t = dyt[j + LX*l];                                                    \\\n"
"    d += g*t*t;                                                                \\\n"
"  }                                                                            \\\n"
"                                                                               \\\n"
"  for (int l = 0; l < LX; l++) {                                               \\\n"
"    double g = G33[i + LX*j + LX*LX*l + LX*LX*LX*e];                             \\\n"
"    double t = dzt[k + LX*l];                                                    \\\n"
"    d += g*t*t;                                                                \\\n"
"  }                                                                            \\\n"
"                                                                               \\\n"
"  /* Corrections for deformed elements */                                      \\\n"
"  if (i == 0 || i == LX-1) {                                                   \\\n"
"    d += G12[i + LX*j + LX*LX*k + LX*LX*LX*e] * dxt[i + LX*i] * dyt[j + LX*j]; \\\n"
"    d += G13[i + LX*j + LX*LX*k + LX*LX*LX*e] * dxt[i + LX*i] * dzt[k + LX*k]; \\\n"
"  }                                                                            \\\n"
"                                                                               \\\n"
"  if (j == 0 || j == LX-1) {                                                   \\\n"
"    d += G12[i + LX*j + LX*LX*k + LX*LX*LX*e] * dyt[j + LX*j] * dxt[i + LX*i]; \\\n"
"    d += G23[i + LX*j + LX*LX*k + LX*LX*LX*e] * dyt[j + LX*j] * dzt[k + LX*k]; \\\n"
"  }                                                                            \\\n"
"                                                                               \\\n"
"  if (k == 0 || k == LX-1) {                                                   \\\n"
"    d += G13[i + LX*j + LX*LX*k + LX*LX*LX*e] * dzt[k + LX*k] * dxt[i + LX*i]; \\\n"
"    d += G23[i + LX*j + LX*LX*k + LX*LX*LX*e] * dzt[k + LX*k] * dyt[j + LX*j]; \\\n"
"  }                                                                            \\\n"
"                                                                               \\\n"
"  du[idx] = d;                                                                 \\\n"
"}\n"
"\n"
"DEFINE_JACOBI_KERNEL(2)\n"
"DEFINE_JACOBI_KERNEL(3)\n"
"DEFINE_JACOBI_KERNEL(4)\n"
"DEFINE_JACOBI_KERNEL(5)\n"
"DEFINE_JACOBI_KERNEL(6)\n"
"DEFINE_JACOBI_KERNEL(7)\n"
"DEFINE_JACOBI_KERNEL(8)\n"
"DEFINE_JACOBI_KERNEL(9)\n"
"DEFINE_JACOBI_KERNEL(10)\n"
"DEFINE_JACOBI_KERNEL(11)\n"
"DEFINE_JACOBI_KERNEL(12)\n"
"DEFINE_JACOBI_KERNEL(13)\n"
"DEFINE_JACOBI_KERNEL(14)\n"
"DEFINE_JACOBI_KERNEL(15)\n"
"DEFINE_JACOBI_KERNEL(16)\n"
"\n"
"\n"
"#endif // __KRYLOV_JACOBI_KERNEL_CL__\n"
;
