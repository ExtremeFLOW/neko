const char *gs_kernels =
"/*\n"
" Copyright (c) 2021, The Neko Authors\n"
" All rights reserved.\n"
"\n"
" Redistribution and use in source and binary forms, with or without\n"
" modification, are permitted provided that the following conditions\n"
" are met:\n"
"\n"
"   * Redistributions of source code must retain the above copyright\n"
"     notice, this list of conditions and the following disclaimer.\n"
"\n"
"   * Redistributions in binary form must reproduce the above\n"
"     copyright notice, this list of conditions and the following\n"
"     disclaimer in the documentation and/or other materials provided\n"
"     with the distribution.\n"
"\n"
"   * Neither the name of the authors nor the names of its\n"
"     contributors may be used to endorse or promote products derived\n"
"     from this software without specific prior written permission.\n"
"\n"
" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"
" \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n"
" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n"
" FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n"
" COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n"
" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n"
" BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n"
" LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n"
" CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n"
" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n"
" ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n"
" POSSIBILITY OF SUCH DAMAGE.\n"
"*/\n"
"\n"
"\n"
"#ifndef __GS_GS_KERNELS__\n"
"#define __GS_GS_KERNELS__\n"
"\n"
"/**\n"
" * Device gather kernel for addition of data\n"
" * \\f$ v(dg(i)) = v(dg(i)) + u(gd(i)) \\f$\n"
" */\n"
"__kernel void gather_kernel_add(__global double * __restrict__ v,\n"
"				const int m,\n"
"				const int o,\n"
"				__global const int * __restrict__ dg,\n"
"				__global const double * __restrict__ u,\n"
"			        const int n,\n"
"				__global const int * __restrict__ gd,\n"
"				const int nb,\n"
"				__global const int * __restrict__ b,\n"
"				__global const int * __restrict__ bo) {\n"
"\n"
"  const int idx = get_global_id(0);\n"
"  const int str = get_global_size(0);\n"
"\n"
"  for (int i = idx; i < nb; i += str) {\n"
"    const int blk_len = b[i];\n"
"    const int k = bo[i];\n"
"    double tmp = u[gd[k] - 1];\n"
"    for (int j = 1; j < blk_len; j++) {\n"
"      tmp += u[gd[k + j] - 1];\n"
"    }\n"
"    v[dg[k] - 1] = tmp;\n"
"  }\n"
"  \n"
"  if (o < 0) {\n"
"    for (int i = ((abs(o) - 1) + idx); i < m ; i += str) {\n"
"      v[dg[i] - 1] = u[gd[i] - 1];\n"
"    }\n"
"  }\n"
"  else {\n"
"    if ((idx%2 == 0)) {\n"
"      for (int i = ((o - 1) + idx); i < m ; i += str) {\n"
"	double tmp = u[gd[i] - 1] + u[gd[i+1] - 1];\n"
"	v[dg[i] - 1] = tmp;\n"
"      }\n"
"    }\n"
"  }\n"
"  \n"
"}\n"
"\n"
"/**\n"
" * Device gather kernel for multiplication of data\n"
" * \\f$ v(dg(i)) = v(dg(i)) \\cdot u(gd(i)) \\f$\n"
" */\n"
"__kernel void gather_kernel_mul(__global double * __restrict__ v,\n"
"				const int m,\n"
"				const int o,\n"
"				__global const int * __restrict__ dg,\n"
"				__global const double * __restrict__ u,\n"
"				const int n,\n"
"				__global const int * __restrict__ gd,\n"
"				const int nb,\n"
"				__global const int * __restrict__ b,\n"
"				__global const int * __restrict__ bo) { \n"
"  \n"
"  const int idx = get_global_id(0);\n"
"  const int str = get_global_size(0);\n"
"\n"
"  for (int i = idx; i < nb; i += str) {\n"
"    const int blk_len = b[i];\n"
"    const int k = bo[i];\n"
"    double tmp = u[gd[k] - 1];\n"
"    for (int j = 1; j < blk_len; j++) {\n"
"      tmp *= u[gd[k + j] - 1];\n"
"    }\n"
"    v[dg[k] - 1] = tmp;\n"
"  }\n"
"  \n"
"  if (o < 0) {\n"
"    for (int i = ((abs(o) - 1) + idx); i < m ; i += str) {\n"
"      v[dg[i] - 1] = u[gd[i] - 1];\n"
"    }\n"
"  }\n"
"  else {\n"
"    if ((idx%2 == 0)) {\n"
"      for (int i = ((o - 1) + idx); i < m ; i += str) {\n"
"	double tmp = u[gd[i] - 1] * u[gd[i+1] - 1];\n"
"	v[dg[i] - 1] = tmp;\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"}\n"
"\n"
"/**\n"
" * Device gather kernel for minimum of data\n"
" * \\f$ v(dg(i)) = \\min(v(dg(i)), u(gd(i))) \\f$\n"
" */\n"
"__kernel void gather_kernel_min(__global double * __restrict__ v,\n"
"				const int m,\n"
"				const int o,\n"
"				__global const int * __restrict__ dg,\n"
"				__global const double * __restrict__ u,\n"
"				const int n,\n"
"				__global const int * __restrict__ gd,\n"
"				const int nb,\n"
"				__global const int * __restrict__ b,\n"
"				__global const int * __restrict__ bo) {\n"
"\n"
"  const int idx = get_global_id(0);\n"
"  const int str = get_global_size(0);\n"
"\n"
"  for (int i = idx; i < nb; i += str) {\n"
"    const int blk_len = b[i];\n"
"    const int k = bo[i];\n"
"    double tmp = u[gd[k] - 1];\n"
"    for (int j = 1; j < blk_len; j++) {\n"
"      tmp = fmin(u[gd[k + j] - 1], tmp);\n"
"    }\n"
"    v[dg[k] - 1] = tmp;\n"
"  }\n"
"  \n"
"  if (o < 0) {\n"
"    for (int i = ((abs(o) - 1) + idx); i < m ; i += str) {\n"
"      v[dg[i] - 1] = u[gd[i] - 1];\n"
"    }\n"
"  }\n"
"  else {\n"
"    if ((idx%2 == 0)) {\n"
"      for (int i = ((o - 1) + idx); i < m ; i += str) {\n"
"	double tmp = fmin(u[gd[i] - 1], u[gd[i+1] - 1]);\n"
"	v[dg[i] - 1] = tmp;\n"
"      }\n"
"    }\n"
"  }\n"
"  \n"
"}\n"
"\n"
"/**\n"
" * Device gather kernel for maximum of data\n"
" * \\f$ v(dg(i)) = \\max(v(dg(i)), u(gd(i))) \\f$\n"
" */\n"
"__kernel void gather_kernel_max(__global double * __restrict__ v,\n"
"				const int m,\n"
"				const int o,\n"
"				__global const int * __restrict__ dg,\n"
"				__global const double * __restrict__ u,\n"
"				const int n,\n"
"				__global const int * __restrict__ gd,\n"
"				const int nb,\n"
"				__global const int *b,\n"
"				__global const int *bo) {\n"
"\n"
"  const int idx = get_global_id(0);\n"
"  const int str = get_global_size(0);\n"
"\n"
"  for (int i = idx; i < nb; i += str) {\n"
"    const int blk_len = b[i];\n"
"    const int k = bo[i];\n"
"    double tmp = u[gd[k] - 1];\n"
"    for (int j = 1; j < blk_len; j++) {\n"
"      tmp = fmax(u[gd[k + j] - 1], tmp);\n"
"    }\n"
"    v[dg[k] - 1] = tmp;\n"
"  }\n"
"  \n"
"  if (o < 0) {\n"
"    for (int i = ((abs(o) - 1) + idx); i < m ; i += str) {\n"
"      v[dg[i] - 1] = u[gd[i] - 1];\n"
"    }\n"
"  }\n"
"  else {\n"
"    if ((idx%2 == 0)) {\n"
"      for (int i = ((o - 1) + idx); i < m ; i += str) {\n"
"	double tmp = fmax(u[gd[i] - 1], u[gd[i+1] - 1]);\n"
"	v[dg[i] - 1] = tmp;\n"
"      }\n"
"    }\n"
"  }\n"
"  \n"
"}\n"
"\n"
"/**\n"
" * Device scatter kernel\n"
" * \\f$ u(gd(i) = v(dg(i)) \\f$\n"
" */\n"
"__kernel void scatter_kernel(__global double * __restrict__ v,\n"
"			     const int m,\n"
"			     __global const int * __restrict__ dg,\n"
"			     __global double *u,\n"
"			     const int n,\n"
"			     __global const int * __restrict__ gd,\n"
"			     const int nb,\n"
"			     __global const int * __restrict__ b,\n"
"			     __global const int * __restrict__ bo) {\n"
"  \n"
"  const int idx = get_global_id(0);\n"
"  const int str = get_global_size(0);\n"
"  \n"
"  for (int i = idx; i < nb; i += str) {\n"
"    const int blk_len = b[i];\n"
"    const int k = bo[i];\n"
"    double tmp = v[dg[k] - 1];\n"
"    for (int j = 0; j < blk_len; j++) {\n"
"      u[gd[k + j] - 1] = tmp;\n"
"    }      \n"
"  }\n"
"\n"
"  int facet_offset = 0;\n"
"  if ( nb > 0) {\n"
"    facet_offset = bo[nb - 1] + b[nb - 1];\n"
"  }\n"
"  \n"
"  for (int i = (facet_offset + idx); i < m; i += str) {\n"
"    u[gd[i] - 1] = v[dg[i] - 1];\n"
"  }\n"
"  \n"
"}\n"
"\n"
"#endif // __GS_GS_KERNELS__\n"
;
