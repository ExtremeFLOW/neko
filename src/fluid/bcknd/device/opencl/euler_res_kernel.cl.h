const char *euler_res_kernel =
"/*\n"
" Copyright (c) 2025, The Neko Authors\n"
" All rights reserved.\n"
"\n"
" Redistribution and use in source and binary forms, with or without\n"
" modification, are permitted provided that the following conditions\n"
" are met:\n"
"\n"
"   * Redistributions of source code must retain the above copyright\n"
"     notice, this list of conditions and the following disclaimer.\n"
"\n"
"   * Redistributions in binary form must reproduce the above\n"
"     copyright notice, this list of conditions and the following\n"
"     disclaimer in the documentation and/or other materials provided\n"
"     with the distribution.\n"
"\n"
"   * Neither the name of the authors nor the names of its\n"
"     contributors may be used to endorse or promote products derived\n"
"     from this software without specific prior written permission.\n"
"\n"
" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"
" \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n"
" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n"
" FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n"
" COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n"
" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n"
" BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n"
" LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n"
" CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n"
" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n"
" ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n"
" POSSIBILITY OF SUCH DAMAGE.\n"
"*/\n"
"\n"
"#ifndef __FLUID_EULER_RES_KERNEL__\n"
"#define __FLUID_EULER_RES_KERNEL__\n"
"\n"
"__kernel \n"
"void euler_res_part_visc_kernel(__global double * __restrict__ rhs,\n"
"                                __global const double * __restrict__ Binv,\n"
"                                __global const double * __restrict__ lap_sol,\n"
"                                __global const double * __restrict__ h,\n"
"                                const double c_avisc,\n"
"                                const int n) {\n"
"  \n"
"  const int idx = get_global_id(0);\n"
"  const int str = get_global_size(0);\n"
"  \n"
"  for (int i = idx; i < n; i += str) {\n"
"    rhs[i] =  -rhs[i] - c_avisc * h[i] * Binv[i] * lap_sol[i];\n"
"  }\n"
"}\n"
"\n"
"__kernel\n"
"void euler_res_part_mx_flux_kernel(__global double * __restrict__ f_x,\n"
"                                   __global double * __restrict__ f_y,\n"
"                                   __global double * __restrict__ f_z,\n"
"                                   __global const double * __restrict__ m_x,\n"
"                                   __global const double * __restrict__ m_y,\n"
"                                   __global const double * __restrict__ m_z,\n"
"                                   __global const double * __restrict__ rho_field,\n"
"                                   __global const double * __restrict__ p,\n"
"                                   const int n) {\n"
"  \n"
"  const int idx = get_global_id(0);\n"
"  const int str = get_global_size(0);\n"
"  \n"
"  for (int i = idx; i < n; i += str) {\n"
"    f_x[i] = m_x[i] * m_x[i] / rho_field[i] + p[i];\n"
"    f_y[i] = m_x[i] * m_y[i] / rho_field[i];\n"
"    f_z[i] = m_x[i] * m_z[i] / rho_field[i];\n"
"  }\n"
"}\n"
"\n"
"__kernel\n"
"void euler_res_part_my_flux_kernel(__global double * __restrict__ f_x,\n"
"                                   __global double * __restrict__ f_y,\n"
"                                   __global double * __restrict__ f_z,\n"
"                                   __global const double * __restrict__ m_x,\n"
"                                   __global const double * __restrict__ m_y,\n"
"                                   __global const double * __restrict__ m_z,\n"
"                                   __global const double * __restrict__ rho_field,\n"
"                                   __global const double * __restrict__ p,\n"
"                                   const int n) {\n"
"  \n"
"  const int idx = get_global_id(0);\n"
"  const int str = get_global_size(0);\n"
"  \n"
"  for (int i = idx; i < n; i += str) {\n"
"    f_x[i] = m_y[i] * m_x[i] / rho_field[i];\n"
"    f_y[i] = m_y[i] * m_y[i] / rho_field[i] + p[i];\n"
"    f_z[i] = m_y[i] * m_z[i] / rho_field[i];\n"
"  }\n"
"}\n"
"\n"
"__kernel\n"
"void euler_res_part_mz_flux_kernel(__global double * __restrict__ f_x,\n"
"                                   __global double * __restrict__ f_y,\n"
"                                   __global double * __restrict__ f_z,\n"
"                                   __global const double * __restrict__ m_x,\n"
"                                   __global const double * __restrict__ m_y,\n"
"                                   __global const double * __restrict__ m_z,\n"
"                                   __global const double * __restrict__ rho_field,\n"
"                                   __global const double * __restrict__ p,\n"
"                                   const int n) {\n"
"  \n"
"  const int idx = get_global_id(0);\n"
"  const int str = get_global_size(0);\n"
"  \n"
"  for (int i = idx; i < n; i += str) {\n"
"    f_x[i] = m_z[i] * m_x[i] / rho_field[i];\n"
"    f_y[i] = m_z[i] * m_y[i] / rho_field[i];\n"
"    f_z[i] = m_z[i] * m_z[i] / rho_field[i] + p[i];\n"
"  }\n"
"}\n"
"\n"
"__kernel\n"
"void euler_res_part_E_flux_kernel(__global double * __restrict__ f_x,\n"
"                                  __global double * __restrict__ f_y,\n"
"                                  __global double * __restrict__ f_z,\n"
"                                  __global const double * __restrict__ m_x,\n"
"                                  __global const double * __restrict__ m_y,\n"
"                                  __global const double * __restrict__ m_z,\n"
"                                  __global const double * __restrict__ rho_field,\n"
"                                  __global const double * __restrict__ p,\n"
"                                  __global const double * __restrict__ E,\n"
"                                  const int n) {\n"
"\n"
"  const int idx = get_global_id(0);\n"
"  const int str = get_global_size(0);  \n"
"  \n"
"  for (int i = idx; i < n; i += str) {\n"
"    f_x[i] = (E[i] + p[i]) * m_x[i] / rho_field[i];\n"
"    f_y[i] = (E[i] + p[i]) * m_y[i] / rho_field[i];\n"
"    f_z[i] = (E[i] + p[i]) * m_z[i] / rho_field[i];\n"
"  }\n"
"}\n"
"\n"
"__kernel\n"
"void euler_res_part_coef_mult_kernel(__global double * __restrict__ rhs_rho,\n"
"                                     __global double * __restrict__ rhs_m_x,\n"
"                                     __global double * __restrict__ rhs_m_y,\n"
"                                     __global double * __restrict__ rhs_m_z,\n"
"                                     __global double * __restrict__ rhs_E,\n"
"                                     __global const double * __restrict__ mult,\n"
"                                     const int n) {\n"
"  \n"
"  const int idx = get_global_id(0);\n"
"  const int str = get_global_size(0);  \n"
"  \n"
"  for (int i = idx; i < n; i += str) {\n"
"    rhs_rho[i] = rhs_rho[i] * mult[i];\n"
"    rhs_m_x[i] = rhs_m_x[i] * mult[i];\n"
"    rhs_m_y[i] = rhs_m_y[i] * mult[i];\n"
"    rhs_m_z[i] = rhs_m_z[i] * mult[i];\n"
"    rhs_E[i] = rhs_E[i] * mult[i];\n"
"  }\n"
"}\n"
"\n"
"__kernel\n"
"void euler_res_part_rk_sum_kernel(__global double * __restrict__ rho,\n"
"                                  __global double * __restrict__ m_x,\n"
"                                  __global double * __restrict__ m_y,\n"
"                                  __global double * __restrict__ m_z,\n"
"                                  __global double * __restrict__ E,\n"
"                                  __global const double * __restrict__ k_rho_i,\n"
"                                  __global const double * __restrict__ k_m_x_i,\n"
"                                  __global const double * __restrict__ k_m_y_i,\n"
"                                  __global const double * __restrict__ k_m_z_i,\n"
"                                  __global const double * __restrict__ k_E_i,\n"
"                                  const double dt,\n"
"                                  const double c,\n"
"                                  const int n) {\n"
"  \n"
"  const int idx = get_global_id(0);\n"
"  const int str = get_global_size(0);  \n"
"  \n"
"  for (int i = idx; i < n; i += str) {\n"
"    rho[i] = rho[i] + dt * c * k_rho_i[i];\n"
"    m_x[i] = m_x[i] + dt * c * k_m_x_i[i];\n"
"    m_y[i] = m_y[i] + dt * c * k_m_y_i[i];\n"
"    m_z[i] = m_z[i] + dt * c * k_m_z_i[i];\n"
"    E[i] = E[i] + dt * c * k_E_i[i];\n"
"  }\n"
"}\n"
"\n"
"#endif // __FLUID_EULER_RES_KERNEL__\n"
;
