module test_matrix_scratch_registry
  use pfunit
  use matrix
  use matrix_math
  use matrix_scratch_registry
  use comm, only : NEKO_COMM, pe_rank, pe_size
  use num_types
  implicit none

contains

  @test
  subroutine test_matrix_scratch_registry_init_default()
    type(matrix_scratch_registry_t) :: scratch
    integer :: ierr

    call scratch%init()

    @assertEqual(scratch%get_nmatrices(), 0)
    @assertEqual(scratch%get_expansion_size(), 10)
    @assertEqual(scratch%get_size(), 10)
    @assertEqual(scratch%get_nmatrices_inuse(), 0)

    call scratch%free()
  end subroutine test_matrix_scratch_registry_init_default

  @test
  subroutine test_matrix_scratch_registry_init()
    type(matrix_scratch_registry_t) :: scratch
    integer :: ierr

    call scratch%init(5, 3)

    @assertEqual(scratch%get_nmatrices(), 0)
    @assertEqual(scratch%get_expansion_size(), 3)
    @assertEqual(scratch%get_size(), 5)
    @assertEqual(scratch%get_nmatrices_inuse(), 0)

    call scratch%free()
  end subroutine test_matrix_scratch_registry_init

  @test
  subroutine test_matrix_scratch_registry_request_matrix_fresh()
    type(matrix_scratch_registry_t) :: scratch
    type(matrix_t), pointer :: m1, m2, m3
    integer :: ierr, index1, index2, index3

    ! write(*,*) "TEST FRESH"

    call scratch%init(5, 3)

    call scratch%request_matrix(42, 42, m1, index1)
    call scratch%request_matrix(42, 42, m2, index2)
    call scratch%request_matrix(42, 42, m3, index3)
    @assertEqual(index1, 1)
    @assertEqual(index2, 2)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_nmatrices(), 3)
    @assertEqual(scratch%get_nmatrices_inuse(), 3)

    ! do something with the matrix
    call matrix_cfill(m1, 1.0_rp)
    call matrix_cfill(m2, 2.0_rp)
    call matrix_cfill(m3, 3.0_rp)
    @assertEqual(m1%x(1, 1), 1.0_rp)
    @assertEqual(m2%x(1, 1), 2.0_rp)
    @assertEqual(m3%x(1, 1), 3.0_rp)

    call scratch%free()
  end subroutine test_matrix_scratch_registry_request_matrix_fresh

  @test
  subroutine test_matrix_scratch_registry_relinquish_matrix()
    type(matrix_scratch_registry_t) :: scratch
    type(matrix_t), pointer :: m
    integer :: ierr, index
    !
    call scratch%init(5, 3)

    call scratch%request_matrix(42, 42, m, index)
    call scratch%relinquish_matrix(index)
    @assertEqual(scratch%get_inuse(index), .false.)
    @assertEqual(scratch%get_nmatrices_inuse(), 0)
    @assertEqual(scratch%get_nmatrices(), 1)

    call scratch%free()
  end subroutine test_matrix_scratch_registry_relinquish_matrix

  @test
  subroutine test_matrix_scratch_registry_expand()
    type(matrix_scratch_registry_t), target :: scratch
    type(matrix_t), pointer :: m1, m2
    integer :: ierr, index1, index2

    ! write(*,*) "TEST EXPAND"

    call scratch%init(1, 1)

    call scratch%request_matrix(42, 42, m1, index1)
    call matrix_cfill(m1, 1.0_rp)
    @assertEqual(m1%x(1, 1), 1.0_rp)

    ! add new matrix, trigging expand
    call scratch%request_matrix(84, 42, m2, index2)

    ! try to use the second matrix
    call matrix_cfill(m2, 2.0_rp)

    ! make sure values in m1 preserved after expansion
    @assertEqual(m1%x(1, 1), 1.0_rp)
    @assertEqual(m2%x(1, 1), 2.0_rp)
    @assertEqual(m1%size(), 42 * 42)
    @assertEqual(m2%size(), 84 * 42)
    @assertEqual(m1%get_nrows(), 42)
    @assertEqual(m1%get_ncols(), 42)
    @assertEqual(m2%get_nrows(), 84)
    @assertEqual(m2%get_ncols(), 42)
    @assertEqual(index1, 1)
    @assertEqual(index2, 2)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_nmatrices(), 2)
    @assertEqual(scratch%get_nmatrices_inuse(), 2)
    @assertEqual(scratch%get_size(), 2)

    call scratch%free()
  end subroutine test_matrix_scratch_registry_expand

  @test
  subroutine test_matrix_scratch_registry_combo()
    type(matrix_scratch_registry_t), target :: scratch
    type(matrix_t), pointer :: m1, m2, m3
    integer :: ierr, index1, index2, index3

    !  write(*,*) "TEST COMBO"
    call scratch%init(2, 2)

    ! add 2 matrices, no expansion
    call scratch%request_matrix(42, 42, m1, index1)
    call scratch%request_matrix(42, 42, m2, index2)
    call matrix_cfill(m1, 1.0_rp)
    call matrix_cfill(m2, 2.0_rp)

    @assertEqual(index1, 1)
    @assertEqual(index2, 2)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_nmatrices(), 2)
    @assertEqual(scratch%get_nmatrices_inuse(), 2)
    @assertEqual(scratch%get_size(), 2)

    ! get rid of one matrix
    call scratch%relinquish_matrix(index1)
    @assertEqual(scratch%get_inuse(index1), .false.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_nmatrices(), 2)
    @assertEqual(scratch%get_nmatrices_inuse(), 1)
    @assertEqual(scratch%get_size(), 2)

    ! get a new matrix, should get index 1
    call scratch%request_matrix(42, 42, m1, index1)
    call matrix_cfill(m1, 1.5_rp)
    @assertEqual(index1, 1)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_nmatrices(), 2)
    @assertEqual(scratch%get_nmatrices_inuse(), 2)
    @assertEqual(scratch%get_size(), 2)

    ! check that the matrices have survived
    @assertEqual(m1%x(1, 1), 1.5_rp)
    @assertEqual(m2%x(1, 1), 2.0_rp)

    ! get a another matrix, should get index 3 and triger expand
    call scratch%request_matrix(42, 42, m3, index3)
    call matrix_cfill(m3, 3.0_rp)
    @assertEqual(index3, 3)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_inuse(index3), .true.)
    @assertEqual(scratch%get_nmatrices(), 3)
    @assertEqual(scratch%get_nmatrices_inuse(), 3)
    @assertEqual(scratch%get_size(), 4)

    ! check that the matrices have survived
    @assertEqual(m1%x(1, 1), 1.5_rp)
    @assertEqual(m2%x(1, 1), 2.0_rp)
    @assertEqual(m3%x(1, 1), 3.0_rp)

    call scratch%free()
  end subroutine test_matrix_scratch_registry_combo

  @test
  subroutine test_matrix_scratch_registry_array_indices()
    type(matrix_scratch_registry_t), target :: scratch
    type(matrix_t), pointer :: m1, m2, m3
    integer :: ierr
    integer :: indices(3)

    !  write(*,*) "TEST COMBO"
    call scratch%init(2, 2)

    ! add 2 matrices, no expansion
    call scratch%request_matrix(42, 42, m1, indices(1))
    call scratch%request_matrix(42, 42, m2, indices(2))
    call scratch%request_matrix(42, 42, m3, indices(3))

    @assertEqual(indices(1), 1)
    @assertEqual(indices(2), 2)
    @assertEqual(indices(3), 3)

    call matrix_cfill(m1, 1.0_rp)
    call matrix_cfill(m2, 2.0_rp)
    call matrix_cfill(m3, 2.0_rp)

    ! get rid of the matrices
    call scratch%relinquish_matrix(indices)
    @assertEqual(scratch%get_inuse(indices(1)), .false.)
    @assertEqual(scratch%get_inuse(indices(2)), .false.)
    @assertEqual(scratch%get_inuse(indices(3)), .false.)
    @assertEqual(scratch%get_nmatrices(), 3)
    @assertEqual(scratch%get_nmatrices_inuse(), 0)

    ! get a new matrix, should get index 1
    call scratch%request_matrix(42, 42, m1, indices(1))
    call matrix_cfill(m1, 1.5_rp)
    @assertEqual(indices(1), 1)
    @assertEqual(scratch%get_inuse(indices(1)), .true.)
    @assertEqual(scratch%get_nmatrices(), 3)
    @assertEqual(scratch%get_nmatrices_inuse(), 1)

    call scratch%free()
  end subroutine test_matrix_scratch_registry_array_indices
end module test_matrix_scratch_registry
