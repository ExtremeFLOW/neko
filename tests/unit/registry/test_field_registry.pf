module test_field_registry
  use pfunit
  use field, only : field_t
  use point, only : point_t
  use space, only : space_t, GLL
  use mesh, only : mesh_t
  use dofmap, only : dofmap_t
  use field_registry, only : registry_t
  use comm, only : pe_rank, pe_size
  use neko_config, only : NEKO_BCKND_DEVICE
  use device, only : DEVICE_TO_HOST, HOST_TO_DEVICE
  use field_math, only : field_cfill
  use num_types, only : rp
  implicit none

contains

  subroutine test_registry_gen_msh(msh)
    type(mesh_t), intent(inout) :: msh
    type(point_t) :: p(12)

    call p(1)%init(0d0, 0d0, 0d0)
    call p(1)%set_id(1)
    call p(2)%init(1d0, 0d0, 0d0)
    call p(2)%set_id(2)
    call p(3)%init(0d0, 1d0, 0d0)
    call p(3)%set_id(4)
    call p(4)%init(1d0, 1d0, 0d0)
    call p(4)%set_id(3)
    call p(5)%init(2d0, 0d0, 0d0)
    call p(5)%set_id(5)
    call p(6)%init(2d0, 1d0, 0d0)
    call p(6)%set_id(6)
    call p(7)%init(0d0, 0d0, 1d0)
    call p(7)%set_id(7)
    call p(8)%init(1d0, 0d0, 1d0)
    call p(8)%set_id(8)
    call p(9)%init(1d0, 1d0, 1d0)
    call p(9)%set_id(9)
    call p(10)%init(0d0, 1d0, 1d0)
    call p(10)%set_id(10)
    call p(11)%init(2d0, 0d0, 1d0)
    call p(11)%set_id(11)
    call p(12)%init(2d0, 1d0, 1d0)
    call p(12)%set_id(12)

    call msh%init(3, 1)
    call msh%add_element(1, 1, p(1), p(2), p(4), p(3), &
         p(7), p(8), p(9), p(10))
    pe_rank = 1
    pe_size = 1
    call msh%generate_conn()

  end subroutine test_registry_gen_msh

  @test
  subroutine test_registry_init()
    type(registry_t) :: registry

    call registry%init()
    @assertEqual(25, registry%get_size())
    @assertEqual(0, registry%n_entries())
    @assertEqual(0, registry%n_fields())
    @assertEqual(0, registry%n_aliases())
    @assertEqual(5, registry%get_expansion_size())

    ! Test freeing the registry
    call registry%free()
    @assertEqual(0, registry%get_size())
    @assertEqual(0, registry%n_entries())
    @assertEqual(0, registry%n_fields())
    @assertEqual(0, registry%n_aliases())
    @assertEqual(5, registry%get_expansion_size())
  end subroutine test_registry_init

  @test
  subroutine test_registry_init_custom()
    type(registry_t) :: registry

    ! Test custom initialization and reinitialization
    call registry%init(5, 10)
    @assertEqual(5, registry%get_size())
    @assertEqual(0, registry%n_entries())
    @assertEqual(0, registry%n_fields())
    @assertEqual(0, registry%n_aliases())
    @assertEqual(10, registry%get_expansion_size())

    call registry%free()
  end subroutine test_registry_init_custom


  @test
  subroutine test_registry_add_field()
    type(space_t) :: Xh
    type(mesh_t) :: msh
    type(dofmap_t) :: dm
    integer, parameter :: lx = 4
    type(registry_t) :: registry
    type(field_t), pointer :: field

    call test_registry_gen_msh(msh)

    call Xh%init(GLL, lx, lx, lx)
    call dm%init(msh, Xh)

    call registry%init()

    call registry%add_field(dm, 'test_field')

    @assertEqual(1, registry%n_fields())

    field => registry%get_field('test_field')

    @assertEqual(field%name, 'test_field')

    call registry%add_field(dm, 'test_field', ignore_existing=.true.)
    @assertEqual(1, registry%n_fields())

    call registry%free()
  end subroutine test_registry_add_field

  @test
  subroutine test_registry_add_alias()
    type(space_t) :: Xh
    type(mesh_t) :: msh
    type(dofmap_t) :: dm
    integer, parameter :: lx = 4
    type(registry_t) :: registry
    type(field_t), pointer :: field, alias_ptr

    call test_registry_gen_msh(msh)

    call Xh%init(GLL, lx, lx, lx)
    call dm%init(msh, Xh)

    call registry%init()

    call registry%add_field(dm, 'test_field')
    call registry%add_alias('test_alias', 'test_field')
    call registry%add_alias('test_alias2', 'test_field')

    @assertEqual(1, registry%n_fields())
    @assertEqual(2, registry%n_aliases())

    field => registry%get_field('test_alias')
    @assertEqual(field%name, 'test_field')

    field => registry%get_field('test_alias2')
    @assertEqual(field%name, 'test_field')

    field => registry%get_field('test_field')
    alias_ptr => registry%get_field('test_alias')
    @assertAssociated(field, alias_ptr)

    call registry%free()
  end subroutine test_registry_add_alias

  @test
  subroutine test_registry_expand()
    type(space_t) :: Xh
    type(mesh_t) :: msh
    type(dofmap_t) :: dm
    integer, parameter :: lx = 4
    type(registry_t) :: registry
    type(field_t), pointer :: field1, field1_post, field2

    call test_registry_gen_msh(msh)

    call Xh%init(GLL, lx, lx, lx)
    call dm%init(msh, Xh)

    call registry%init(1, 1)

    call registry%add_field(dm, 'test_field1')
    field1 => registry%get_field('test_field1')
    call field_cfill(field1, 42.0_rp)

    call registry%add_field(dm, 'test_field2')
    field2 => registry%get_field('test_field2')
    call field_cfill(field2, 84.0_rp)

    @assertEqual(2, registry%n_entries())
    @assertEqual(2, registry%n_fields())

    if (NEKO_BCKND_DEVICE .eq. 1) then
       call field1%copy_from(DEVICE_TO_HOST, sync = .false.)
       call field2%copy_from(DEVICE_TO_HOST, sync = .true.)
    end if

    ! Check values post-expansion
    @assertEqual(field1%x(1,1,1,1), 42.0_rp)
    @assertEqual(field2%x(1,1,1,1), 84.0_rp)

    ! Check that we did indeed retain the objects
    field1_post => registry%get_field('test_field1')
    @assertAssociated(field1, field1_post)
    @assertEqual(field1_post%x(1,1,1,1), 42.0_rp)

    call registry%free()
  end subroutine test_registry_expand

end module test_field_registry
