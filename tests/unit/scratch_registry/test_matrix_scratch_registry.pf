module test_matrix_scratch_registry
  use pfunit
  use matrix, only : matrix_t
  use matrix_math, only : matrix_cfill
  use scratch_registry, only : scratch_registry_t
  use num_types, only : rp
  use device, only : DEVICE_TO_HOST, device_init, &
       device_finalize
  use neko_config, only : NEKO_BCKND_DEVICE
  implicit none

  @TestCase
  type, extends(TestCase) :: test_matrix_scratch_reg
   contains
     procedure :: setUp
     procedure :: tearDown
  end type test_matrix_scratch_reg

contains

  subroutine setUp(this)
    class(test_matrix_scratch_reg), intent(inout) :: this
    if (NEKO_BCKND_DEVICE .eq. 1) then
       call device_init
    end if
  end subroutine setUp

  subroutine tearDown(this)
    class(test_matrix_scratch_reg), intent(inout) :: this
    if (NEKO_BCKND_DEVICE .eq. 1) then
       call device_finalize
    end if
  end subroutine tearDown

  @test
  subroutine test_mat_scratch_reg_init_default(this)
    class(test_matrix_scratch_reg), intent(inout) :: this
    type(scratch_registry_t) :: scratch
    integer :: ierr

    call scratch%init()

    @assertEqual(scratch%get_n_entries(), 0)
    @assertEqual(scratch%get_expansion_size(), 10)
    @assertEqual(scratch%get_size(), 10)
    @assertEqual(scratch%get_n_inuse(), 0)

    call scratch%free()
  end subroutine test_mat_scratch_reg_init_default

  @test
  subroutine test_mat_scratch_reg_init(this)
    class(test_matrix_scratch_reg), intent(inout) :: this
    type(scratch_registry_t) :: scratch
    integer :: ierr

    call scratch%init(5, 3)

    @assertEqual(scratch%get_n_entries(), 0)
    @assertEqual(scratch%get_expansion_size(), 3)
    @assertEqual(scratch%get_size(), 5)
    @assertEqual(scratch%get_n_inuse(), 0)

    call scratch%free()
  end subroutine test_mat_scratch_reg_init

  @test
  subroutine test_mat_scratch_reg_req_mat_frsh(this)
    class(test_matrix_scratch_reg), intent(inout) :: this
    type(scratch_registry_t) :: scratch
    type(matrix_t), pointer :: m1, m2, m3
    integer :: ierr, index1, index2, index3

    ! write(*,*) "TEST FRESH"

    call scratch%init(5, 3)

    call scratch%request_matrix(42, 42, m1, index1, .false.)
    call scratch%request_matrix(42, 42, m2, index2, .false.)
    call scratch%request_matrix(42, 42, m3, index3, .false.)
    @assertEqual(index1, 1)
    @assertEqual(index2, 2)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_entries(), 3)
    @assertEqual(scratch%get_n_inuse(), 3)

    ! do something with the matrix
    call matrix_cfill(m1, 1.0_rp)
    call matrix_cfill(m2, 2.0_rp)
    call matrix_cfill(m3, 3.0_rp)

    call m1%copy_from(DEVICE_TO_HOST, sync = .false.)
    call m2%copy_from(DEVICE_TO_HOST, sync = .false.)
    call m3%copy_from(DEVICE_TO_HOST, sync = .true.)

    @assertEqual(m1%x(1, 1), 1.0_rp)
    @assertEqual(m2%x(1, 1), 2.0_rp)
    @assertEqual(m3%x(1, 1), 3.0_rp)

    call scratch%relinquish_matrix(index1)
    call scratch%relinquish_matrix(index2)
    call scratch%relinquish_matrix(index3)
    call scratch%free()
  end subroutine test_mat_scratch_reg_req_mat_frsh

  @test
  subroutine test_mat_scratch_reg_relq_mat(this)
    class(test_matrix_scratch_reg), intent(inout) :: this
    type(scratch_registry_t) :: scratch
    type(matrix_t), pointer :: m
    integer :: ierr, index
    !
    call scratch%init(5, 3)

    call scratch%request_matrix(42, 42, m, index, .false.)
    call scratch%relinquish_matrix(index)
    @assertEqual(scratch%get_inuse(index), .false.)
    @assertEqual(scratch%get_n_inuse(), 0)
    @assertEqual(scratch%get_n_entries(), 1)

    call scratch%free()
  end subroutine test_mat_scratch_reg_relq_mat

  @test
  subroutine test_vector_scratch_reg_relinq_mat_lst(this)
    class(test_matrix_scratch_reg), intent(inout) :: this
    type(scratch_registry_t) :: scratch
    type(matrix_t), pointer :: m1, m2
    integer :: ierr, indices(2)
    !
    call scratch%init(5, 3)

    call scratch%request_matrix(42, 42, m1, indices(1), .false.)
    call scratch%request_matrix(42, 42, m2, indices(2), .false.)
    call scratch%relinquish_matrix(indices)
    @assertEqual(scratch%get_inuse(indices(1)), .false.)
    @assertEqual(scratch%get_inuse(indices(2)), .false.)
    @assertEqual(scratch%get_n_inuse(), 0)
    @assertEqual(scratch%get_n_entries(), 2)

    call scratch%free()
  end subroutine test_vector_scratch_reg_relinq_mat_lst

  @test
  subroutine test_mat_scratch_reg_expand(this)
    class(test_matrix_scratch_reg), intent(inout) :: this
    type(scratch_registry_t), target :: scratch
    type(matrix_t), pointer :: m1, m2
    integer :: ierr, index1, index2

    ! write(*,*) "TEST EXPAND"

    call scratch%init(1, 1)

    call scratch%request_matrix(42, 42, m1, index1, .false.)
    call matrix_cfill(m1, 1.0_rp)

    call m1%copy_from(DEVICE_TO_HOST, sync = .true.)
    @assertEqual(m1%x(1, 1), 1.0_rp)

    ! add new matrix, trigging expand
    call scratch%request_matrix(84, 42, m2, index2, .false.)

    ! try to use the second matrix
    call matrix_cfill(m2, 2.0_rp)

    ! make sure values in m1 preserved after expansion
    call m1%copy_from(DEVICE_TO_HOST, sync = .false.)
    call m2%copy_from(DEVICE_TO_HOST, sync = .true.)

    @assertEqual(m1%x(1, 1), 1.0_rp)
    @assertEqual(m2%x(1, 1), 2.0_rp)
    @assertEqual(m1%size(), 42 * 42)
    @assertEqual(m2%size(), 84 * 42)
    @assertEqual(m1%get_nrows(), 42)
    @assertEqual(m1%get_ncols(), 42)
    @assertEqual(m2%get_nrows(), 84)
    @assertEqual(m2%get_ncols(), 42)
    @assertEqual(index1, 1)
    @assertEqual(index2, 2)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_entries(), 2)
    @assertEqual(scratch%get_n_inuse(), 2)
    @assertEqual(scratch%get_size(), 2)

    call scratch%relinquish_matrix(index1)
    call scratch%relinquish_matrix(index2)
    call scratch%free()
  end subroutine test_mat_scratch_reg_expand

  @test
  subroutine test_mat_scratch_reg_combo(this)
    class(test_matrix_scratch_reg), intent(inout) :: this
    type(scratch_registry_t), target :: scratch
    type(matrix_t), pointer :: m1, m2, m3
    integer :: ierr, index1, index2, index3

    !  write(*,*) "TEST COMBO"
    call scratch%init(2, 2)

    ! add 2 matrices, no expansion
    call scratch%request_matrix(42, 42, m1, index1, .false.)
    call scratch%request_matrix(42, 42, m2, index2, .false.)
    call matrix_cfill(m1, 1.0_rp)
    call matrix_cfill(m2, 2.0_rp)

    @assertEqual(index1, 1)
    @assertEqual(index2, 2)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_entries(), 2)
    @assertEqual(scratch%get_n_inuse(), 2)
    @assertEqual(scratch%get_size(), 2)

    ! get rid of one matrix
    call scratch%relinquish_matrix(index1)
    @assertEqual(scratch%get_inuse(index1), .false.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_entries(), 2)
    @assertEqual(scratch%get_n_inuse(), 1)
    @assertEqual(scratch%get_size(), 2)

    ! get a new matrix, should get index 1
    call scratch%request_matrix(42, 42, m1, index1, .false.)
    call matrix_cfill(m1, 1.5_rp)
    @assertEqual(index1, 1)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_entries(), 2)
    @assertEqual(scratch%get_n_inuse(), 2)
    @assertEqual(scratch%get_size(), 2)

    ! check that the matrices have survived
    call m1%copy_from(DEVICE_TO_HOST, sync = .false.)
    call m2%copy_from(DEVICE_TO_HOST, sync = .true.)
    @assertEqual(m1%x(1, 1), 1.5_rp)
    @assertEqual(m2%x(1, 1), 2.0_rp)

    ! get a another matrix, should get index 3 and triger expand
    call scratch%request_matrix(42, 42, m3, index3, .false.)
    call matrix_cfill(m3, 3.0_rp)
    @assertEqual(index3, 3)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_inuse(index3), .true.)
    @assertEqual(scratch%get_n_entries(), 3)
    @assertEqual(scratch%get_n_inuse(), 3)
    @assertEqual(scratch%get_size(), 4)

    ! check that the matrices have survived
    call m1%copy_from(DEVICE_TO_HOST, sync = .false.)
    call m2%copy_from(DEVICE_TO_HOST, sync = .false.)
    call m3%copy_from(DEVICE_TO_HOST, sync = .true.)
    @assertEqual(m1%x(1, 1), 1.5_rp)
    @assertEqual(m2%x(1, 1), 2.0_rp)
    @assertEqual(m3%x(1, 1), 3.0_rp)

    call scratch%relinquish_matrix(index1)
    call scratch%relinquish_matrix(index2)
    call scratch%relinquish_matrix(index3)
    call scratch%free()
  end subroutine test_mat_scratch_reg_combo

  @test
  subroutine test_mat_scratch_reg_array_indices(this)
    class(test_matrix_scratch_reg), intent(inout) :: this
    type(scratch_registry_t), target :: scratch
    type(matrix_t), pointer :: m1, m2, m3
    integer :: ierr
    integer :: indices(3)

    !  write(*,*) "TEST COMBO"
    call scratch%init(2, 2)

    ! add 2 matrices, no expansion
    call scratch%request_matrix(42, 42, m1, indices(1), .false.)
    call scratch%request_matrix(42, 42, m2, indices(2), .false.)
    call scratch%request_matrix(42, 42, m3, indices(3), .false.)

    @assertEqual(indices(1), 1)
    @assertEqual(indices(2), 2)
    @assertEqual(indices(3), 3)

    call matrix_cfill(m1, 1.0_rp)
    call matrix_cfill(m2, 2.0_rp)
    call matrix_cfill(m3, 2.0_rp)

    ! get rid of the matrices
    call scratch%relinquish_matrix(indices)
    @assertEqual(scratch%get_inuse(indices(1)), .false.)
    @assertEqual(scratch%get_inuse(indices(2)), .false.)
    @assertEqual(scratch%get_inuse(indices(3)), .false.)
    @assertEqual(scratch%get_n_entries(), 3)
    @assertEqual(scratch%get_n_inuse(), 0)

    ! get a new matrix, should get index 1
    call scratch%request_matrix(42, 42, m1, indices(1), .false.)
    call matrix_cfill(m1, 1.5_rp)
    @assertEqual(indices(1), 1)
    @assertEqual(scratch%get_inuse(indices(1)), .true.)
    @assertEqual(scratch%get_n_entries(), 3)
    @assertEqual(scratch%get_n_inuse(), 1)

    call scratch%relinquish_matrix(indices(1))
    call scratch%free()
  end subroutine test_mat_scratch_reg_array_indices
end module test_matrix_scratch_registry
