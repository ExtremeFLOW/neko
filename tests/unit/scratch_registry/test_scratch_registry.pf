module test_scratch_registry
  use pfunit
  use field, only : field_t
  use vector, only : vector_t
  use matrix, only : matrix_t
  use point, only : point_t
  use space, only : space_t, GLL
  use mesh, only : mesh_t
  use dofmap, only : dofmap_t
  use field_math, only : field_cfill
  use vector_math, only : vector_cfill
  use matrix_math, only : matrix_cfill
  use scratch_registry, only : scratch_registry_t
  use num_types, only : rp
  use device, only : DEVICE_TO_HOST, device_init, &
       device_finalize
  use comm, only : pe_rank, pe_size
  use neko_config, only : NEKO_BCKND_DEVICE
  implicit none

  @TestCase
  type, extends(TestCase) :: test_scratch_reg
   contains
     procedure :: setUp
     procedure :: tearDown
  end type test_scratch_reg

contains

  subroutine setUp(this)
    class(test_scratch_reg), intent(inout) :: this
    if (NEKO_BCKND_DEVICE .eq. 1) then
       call device_init
    end if
  end subroutine setUp

  subroutine tearDown(this)
    class(test_scratch_reg), intent(inout) :: this
    if (NEKO_BCKND_DEVICE .eq. 1) then
       call device_finalize
    end if
  end subroutine tearDown
  
  subroutine test_srtch_reg_gen_msh(msh)
    type(mesh_t), intent(inout) :: msh
    type(point_t) :: p(12)

    call p(1)%init(0d0, 0d0, 0d0)
    call p(1)%set_id(1)
    call p(2)%init(1d0, 0d0, 0d0)
    call p(2)%set_id(2)
    call p(3)%init(0d0, 1d0, 0d0)
    call p(3)%set_id(4)
    call p(4)%init(1d0, 1d0, 0d0)
    call p(4)%set_id(3)
    call p(5)%init(2d0, 0d0, 0d0)
    call p(5)%set_id(5)
    call p(6)%init(2d0, 1d0, 0d0)
    call p(6)%set_id(6)
    call p(7)%init(0d0, 0d0, 1d0)
    call p(7)%set_id(7)
    call p(8)%init(1d0, 0d0, 1d0)
    call p(8)%set_id(8)
    call p(9)%init(1d0, 1d0, 1d0)
    call p(9)%set_id(9)
    call p(10)%init(0d0, 1d0, 1d0)
    call p(10)%set_id(10)
    call p(11)%init(2d0, 0d0, 1d0)
    call p(11)%set_id(11)
    call p(12)%init(2d0, 1d0, 1d0)
    call p(12)%set_id(12)

    call msh%init(3, 1)
    call msh%add_element(1, 1, p(1), p(2), p(4), p(3), &
         p(7), p(8), p(9), p(10))
    pe_rank = 1
    pe_size = 1
    call msh%generate_conn()

  end subroutine test_srtch_reg_gen_msh

  @test
  subroutine test_srtch_reg_init_default(this)
    class(test_scratch_reg), intent(inout) :: this
    type(space_t) :: Xh
    type(mesh_t) :: msh
    type(dofmap_t) :: dm
    integer, parameter :: LX = 4
    type(scratch_registry_t) :: scratch
    integer :: ierr

    call test_srtch_reg_gen_msh(msh)

    call Xh%init(GLL, lx, lx, lx)
    call dm%init(msh, Xh)

    call scratch%init(dof = dm)

    @assertEqual(scratch%get_n_available(), 0)
    @assertEqual(scratch%get_expansion_size(), 10)
    @assertEqual(scratch%get_size(), 10)
    @assertEqual(scratch%get_n_inuse(), 0)

    call scratch%free()
  end subroutine test_srtch_reg_init_default

  @test
  subroutine test_srtch_reg_init(this)
    class(test_scratch_reg), intent(inout) :: this
    type(space_t) :: Xh
    type(mesh_t) :: msh
    type(dofmap_t) :: dm
    integer, parameter :: LX = 4
    type(scratch_registry_t) :: scratch
    integer :: ierr

    call test_srtch_reg_gen_msh(msh)
    call Xh%init(GLL, lx, lx, lx)
    call dm%init(msh, Xh)

    call scratch%init(5, 3, dm)

    @assertEqual(scratch%get_n_available(), 0)
    @assertEqual(scratch%get_expansion_size(), 3)
    @assertEqual(scratch%get_size(), 5)
    @assertEqual(scratch%get_n_inuse(), 0)

    call scratch%free()
  end subroutine test_srtch_reg_init

  @test
  subroutine test_srtch_reg_request_field_fresh(this)
    class(test_scratch_reg), intent(inout) :: this
    type(space_t) :: Xh
    type(mesh_t) :: msh
    type(dofmap_t) :: dm
    type(scratch_registry_t) :: scratch
    type(field_t), pointer :: f1
    type(vector_t), pointer :: v2
    type(matrix_t), pointer :: m3
    integer :: ierr, index1, index2, index3
    integer, parameter :: LX = 3

    ! write(*,*) "TEST FRESH"
    call test_srtch_reg_gen_msh(msh)
    call Xh%init(GLL, lx, lx, lx)
    call dm%init(msh, Xh)

    call scratch%init(5, 3, dm)

    call scratch%request_field(f1, index1, .false.)
    call scratch%request_vector(42, v2, index2, .false.)
    call scratch%request_matrix(42, 42, m3, index3, .false.)
    @assertEqual(index1, 1)
    @assertEqual(index2, 2)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_available(), 3)
    @assertEqual(scratch%get_n_inuse(), 3)

    ! do something with the field
    call field_cfill(f1, 1.0_rp)
    call vector_cfill(v2, 2.0_rp)
    call matrix_cfill(m3, 3.0_rp)

    call f1%copy_from(DEVICE_TO_HOST, sync = .false.)
    call v2%copy_from(DEVICE_TO_HOST, sync = .false.)
    call m3%copy_from(DEVICE_TO_HOST, sync = .true.)

    @assertEqual(f1%x(1, 1, 1, 1), 1.0_rp)
    @assertEqual(v2%x(1), 2.0_rp)
    @assertEqual(m3%x(1, 1), 3.0_rp)

    call scratch%relinquish(index1)
    call scratch%relinquish(index2)
    call scratch%relinquish(index3)
    call scratch%free()
  end subroutine test_srtch_reg_request_field_fresh

  @test
  subroutine test_srtch_reg_relinquish_field(this)
    class(test_scratch_reg), intent(inout) :: this
    type(space_t) :: Xh
    type(mesh_t) :: msh
    type(dofmap_t) :: dm
    type(scratch_registry_t) :: scratch
    type(field_t), pointer :: f
    integer :: ierr, index
    integer, parameter :: LX = 3

    call test_srtch_reg_gen_msh(msh)
    call Xh%init(GLL, lx, lx, lx)
    call dm%init(msh, Xh)

    call scratch%init(5, 3, dm)

    call scratch%request_field(f, index, .false.)
    call scratch%relinquish(index)
    @assertEqual(scratch%get_inuse(index), .false.)
    @assertEqual(scratch%get_n_inuse(), 0)
    @assertEqual(scratch%get_n_available(), 1)

    call scratch%free()
  end subroutine test_srtch_reg_relinquish_field

  @test
  subroutine test_vector_scratch_registry_relinquish_field_list(this)
    class(test_scratch_reg), intent(inout) :: this
    type(space_t) :: Xh
    type(mesh_t) :: msh
    type(dofmap_t) :: dm
    type(scratch_registry_t) :: scratch
    type(field_t), pointer :: f1
    type(vector_t), pointer :: v2
    integer :: ierr, indices(2)
    integer, parameter :: LX = 3

    call test_srtch_reg_gen_msh(msh)
    call Xh%init(GLL, lx, lx, lx)
    call dm%init(msh, Xh)

    call scratch%init(5, 3, dm)

    call scratch%request_field(f1, indices(1), .false.)
    call scratch%request_vector(42, v2, indices(2), .false.)
    call scratch%relinquish(indices)
    @assertEqual(scratch%get_inuse(indices(1)), .false.)
    @assertEqual(scratch%get_inuse(indices(2)), .false.)
    @assertEqual(scratch%get_n_inuse(), 0)
    @assertEqual(scratch%get_n_available(), 2)

    call scratch%free()
  end subroutine test_vector_scratch_registry_relinquish_field_list

  @test
  subroutine test_srtch_reg_expand(this)
    class(test_scratch_reg), intent(inout) :: this
    type(space_t) :: Xh
    type(mesh_t) :: msh
    type(dofmap_t) :: dm
    type(scratch_registry_t), target :: scratch
    type(field_t), pointer :: f1
    type(vector_t), pointer :: v2
    integer :: ierr, index1, index2
    integer, parameter :: LX = 2

    ! write(*,*) "TEST EXPAND"

    call test_srtch_reg_gen_msh(msh)
    call Xh%init(GLL, lx, lx, lx)
    call dm%init(msh, Xh)

    call scratch%init(1, 1, dm)

    call scratch%request_field(f1, index1, .false.)
    call field_cfill(f1, 1.0_rp)

    call f1%copy_from(DEVICE_TO_HOST, sync = .true.)
    @assertEqual(f1%x(1, 1, 1, 1), 1.0_rp)

    ! add new field, trigging expand
    call scratch%request_vector(42, v2, index2, .false.)

    ! try to use the second field
    call vector_cfill(v2, 2.0_rp)

    ! make sure values in f1 preserved after expansion
    call f1%copy_from(DEVICE_TO_HOST, sync = .false.)
    call v2%copy_from(DEVICE_TO_HOST, sync = .true.)

    @assertEqual(f1%x(1, 1, 1, 1), 1.0_rp)
    @assertEqual(v2%x(1), 2.0_rp)
    @assertEqual(index1, 1)
    @assertEqual(index2, 2)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_available(), 2)
    @assertEqual(scratch%get_n_inuse(), 2)
    @assertEqual(scratch%get_size(), 2)

    call scratch%relinquish(index1)
    call scratch%relinquish(index2)
    call scratch%free()
  end subroutine test_srtch_reg_expand

  @test
  subroutine test_srtch_reg_combo(this)
    class(test_scratch_reg), intent(inout) :: this
    type(space_t) :: Xh
    type(mesh_t) :: msh
    type(dofmap_t) :: dm
    type(scratch_registry_t), target :: scratch
    type(field_t), pointer :: f1
    type(vector_t), pointer :: v2
    type(matrix_t), pointer :: m3
    integer :: ierr, index1, index2, index3
    integer, parameter :: LX = 2

    call test_srtch_reg_gen_msh(msh)
    call Xh%init(GLL, lx, lx, lx)
    call dm%init(msh, Xh)

    !  write(*,*) "TEST COMBO"
    call scratch%init(2, 2, dm)

    ! add 2 fields, no expansion
    call scratch%request_field(f1, index1, .false.)
    call scratch%request_vector(42, v2, index2, .false.)
    call field_cfill(f1, 1.0_rp)
    call vector_cfill(v2, 2.0_rp)

    @assertEqual(index1, 1)
    @assertEqual(index2, 2)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_available(), 2)
    @assertEqual(scratch%get_n_inuse(), 2)
    @assertEqual(scratch%get_size(), 2)

    ! get rid of one field
    call scratch%relinquish(index1)
    @assertEqual(scratch%get_inuse(index1), .false.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_available(), 2)
    @assertEqual(scratch%get_n_inuse(), 1)
    @assertEqual(scratch%get_size(), 2)

    ! get a new field, should get index 1
    call scratch%request_field(f1, index1, .false.)
    call field_cfill(f1, 1.5_rp)
    @assertEqual(index1, 1)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_available(), 2)
    @assertEqual(scratch%get_n_inuse(), 2)
    @assertEqual(scratch%get_size(), 2)

    ! check that the fields have survived
    call f1%copy_from(DEVICE_TO_HOST, sync = .false.)
    call v2%copy_from(DEVICE_TO_HOST, sync = .true.)
    @assertEqual(f1%x(1, 1, 1, 1), 1.5_rp)
    @assertEqual(v2%x(1), 2.0_rp)

    ! get a another field, should get index 3 and triger expand
    call scratch%request_matrix(42, 42, m3, index3, .false.)
    call matrix_cfill(m3, 3.0_rp)
    @assertEqual(index3, 3)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_inuse(index3), .true.)
    @assertEqual(scratch%get_n_available(), 3)
    @assertEqual(scratch%get_n_inuse(), 3)
    @assertEqual(scratch%get_size(), 4)

    ! check that the fields have survived
    call f1%copy_from(DEVICE_TO_HOST, sync = .false.)
    call v2%copy_from(DEVICE_TO_HOST, sync = .false.)
    call m3%copy_from(DEVICE_TO_HOST, sync = .true.)
    @assertEqual(f1%x(1, 1, 1, 1), 1.5_rp)
    @assertEqual(v2%x(1), 2.0_rp)
    @assertEqual(m3%x(1, 1), 3.0_rp)

    call scratch%relinquish(index1)
    call scratch%relinquish(index2)
    call scratch%relinquish(index3)
    call scratch%free()
  end subroutine test_srtch_reg_combo

  @test
  subroutine test_srtch_reg_array_indices(this)
    class(test_scratch_reg), intent(inout) :: this
    type(space_t) :: Xh
    type(mesh_t) :: msh
    type(dofmap_t) :: dm
    type(scratch_registry_t), target :: scratch
    type(field_t), pointer :: f1
    type(vector_t), pointer :: v2
    type(matrix_t), pointer :: m3
    integer :: ierr
    integer :: indices(3)

    integer, parameter :: LX = 2

    call test_srtch_reg_gen_msh(msh)
    call Xh%init(GLL, lx, lx, lx)
    call dm%init(msh, Xh)

    !  write(*,*) "TEST COMBO"
    call scratch%init(2, 2, dm)

    ! add 2 fields, no expansion
    call scratch%request_field(f1, indices(1), .false.)
    call scratch%request_vector(42, v2, indices(2), .false.)
    call scratch%request_matrix(42, 42, m3, indices(3), .false.)

    @assertEqual(indices(1), 1)
    @assertEqual(indices(2), 2)
    @assertEqual(indices(3), 3)

    call field_cfill(f1, 1.0_rp)
    call vector_cfill(v2, 2.0_rp)
    call matrix_cfill(m3, 2.0_rp)

    ! get rid of the fields
    call scratch%relinquish(indices)
    @assertEqual(scratch%get_inuse(indices(1)), .false.)
    @assertEqual(scratch%get_inuse(indices(2)), .false.)
    @assertEqual(scratch%get_inuse(indices(3)), .false.)
    @assertEqual(scratch%get_n_available(), 3)
    @assertEqual(scratch%get_n_inuse(), 0)

    ! get a new field, should get index 1
    call scratch%request_field(f1, indices(1), .false.)
    call field_cfill(f1, 1.5_rp)
    @assertEqual(indices(1), 1)
    @assertEqual(scratch%get_inuse(indices(1)), .true.)
    @assertEqual(scratch%get_n_available(), 3)
    @assertEqual(scratch%get_n_inuse(), 1)

    call scratch%relinquish(indices(1))
    call scratch%free()
  end subroutine test_srtch_reg_array_indices
end module test_scratch_registry
