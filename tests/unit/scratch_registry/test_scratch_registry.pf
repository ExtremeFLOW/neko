module test_scratch_registry
  use pfunit
  use field
  use vector
  use device
  use matrix
  use point
  use space
  use mesh
  use dofmap
  use math
  use field_math
  use vector_math
  use matrix_math
  use scratch_registry
  use comm, only : NEKO_COMM, pe_rank, pe_size
  use num_types
  implicit none

contains

  subroutine test_scratch_registry_gen_msh(msh)
    type(mesh_t), intent(inout) :: msh
    type(point_t) :: p(12)

    call p(1)%init(0d0, 0d0, 0d0)
    call p(1)%set_id(1)
    call p(2)%init(1d0, 0d0, 0d0)
    call p(2)%set_id(2)
    call p(3)%init(0d0, 1d0, 0d0)
    call p(3)%set_id(4)
    call p(4)%init(1d0, 1d0, 0d0)
    call p(4)%set_id(3)
    call p(5)%init(2d0, 0d0, 0d0)
    call p(5)%set_id(5)
    call p(6)%init(2d0, 1d0, 0d0)
    call p(6)%set_id(6)
    call p(7)%init(0d0, 0d0, 1d0)
    call p(7)%set_id(7)
    call p(8)%init(1d0, 0d0, 1d0)
    call p(8)%set_id(8)
    call p(9)%init(1d0, 1d0, 1d0)
    call p(9)%set_id(9)
    call p(10)%init(0d0, 1d0, 1d0)
    call p(10)%set_id(10)
    call p(11)%init(2d0, 0d0, 1d0)
    call p(11)%set_id(11)
    call p(12)%init(2d0, 1d0, 1d0)
    call p(12)%set_id(12)

    call msh%init(3, 1)
    call msh%add_element(1, 1, p(1), p(2), p(4), p(3), &
         p(7), p(8), p(9), p(10))
    pe_rank = 1
    pe_size = 1
    call msh%generate_conn()

  end subroutine test_scratch_registry_gen_msh

  @test
  subroutine test_scratch_registry_init_default()
    type(space_t) :: Xh
    type(mesh_t) :: msh
    type(dofmap_t) :: dm
    integer, parameter :: LX = 4
    type(scratch_registry_t) :: scratch
    integer :: ierr

    call test_scratch_registry_gen_msh(msh)

    call Xh%init(GLL, lx, lx, lx)
    call dm%init(msh, Xh)

    call scratch%init()
    call scratch%set_dofmap(dm)

    @assertEqual(scratch%get_n_available(), 0)
    @assertEqual(scratch%get_expansion_size(), 10)
    @assertEqual(scratch%get_size(), 10)
    @assertEqual(scratch%get_n_inuse(), 0)

    call scratch%free()
  end subroutine test_scratch_registry_init_default

  @test
  subroutine test_scratch_registry_init()
    type(space_t) :: Xh
    type(mesh_t) :: msh
    type(dofmap_t) :: dm
    integer, parameter :: LX = 4
    type(scratch_registry_t) :: scratch
    integer :: ierr

    call test_scratch_registry_gen_msh(msh)
    call Xh%init(GLL, lx, lx, lx)
    call dm%init(msh, Xh)

    call scratch%init(5, 3, dm)

    @assertEqual(scratch%get_n_available(), 0)
    @assertEqual(scratch%get_expansion_size(), 3)
    @assertEqual(scratch%get_size(), 5)
    @assertEqual(scratch%get_n_inuse(), 0)

    call scratch%free()
  end subroutine test_scratch_registry_init

  @test
  subroutine test_scratch_registry_request_field_fresh()
    type(space_t) :: Xh
    type(mesh_t) :: msh
    type(dofmap_t) :: dm
    type(scratch_registry_t) :: scratch
    type(field_t), pointer :: f1, f2, f3
    integer :: ierr, index1, index2, index3
    integer, parameter :: LX = 3

    ! write(*,*) "TEST FRESH"
    call test_scratch_registry_gen_msh(msh)
    call Xh%init(GLL, lx, lx, lx)
    call dm%init(msh, Xh)

    call scratch%init(5, 3, dm)

    call scratch%request_field(f1, index1)
    call scratch%request_field(f2, index2)
    call scratch%request_field(f3, index3)
    @assertEqual(index1, 1)
    @assertEqual(index2, 2)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_available(), 3)
    @assertEqual(scratch%get_n_inuse(), 3)

    ! do something with the field
    call cfill(f1%x, 1.0_rp, f1%size())
    call cfill(f2%x, 2.0_rp, f2%size())
    call cfill(f3%x, 3.0_rp, f3%size())
    @assertEqual(f1%x(1,1,1,1), 1.0_rp)
    @assertEqual(f2%x(1,1,1,1), 2.0_rp)
    @assertEqual(f3%x(1,1,1,1), 3.0_rp)

    call scratch%free()
  end subroutine test_scratch_registry_request_field_fresh

  @test
  subroutine test_scratch_registry_relinquish_field()
    type(space_t) :: Xh
    type(mesh_t) :: msh
    type(dofmap_t) :: dm
    type(scratch_registry_t) :: scratch
    type(field_t), pointer :: f
    integer :: ierr, index
    integer, parameter :: LX = 3

    call test_scratch_registry_gen_msh(msh)
    call Xh%init(GLL, lx, lx, lx)
    call dm%init(msh, Xh)

    call scratch%init(5, 3, dm)

    call scratch%request_field(f, index)
    call scratch%relinquish_field(index)
    @assertEqual(scratch%get_inuse(index), .false.)
    @assertEqual(scratch%get_n_inuse(), 0)
    @assertEqual(scratch%get_n_available(), 1)

    call scratch%free()
  end subroutine test_scratch_registry_relinquish_field

  @test
  subroutine test_scratch_registry_request_vector_fresh()
    type(scratch_registry_t) :: scratch
    type(vector_t), pointer :: v1, v2, v3
    integer :: ierr, index1, index2, index3

    ! write(*,*) "TEST FRESH"

    call scratch%init(5, 3)

    call scratch%request_vector(42, v1, index1)
    call scratch%request_vector(42, v2, index2)
    call scratch%request_vector(42, v3, index3)
    @assertEqual(index1, 1)
    @assertEqual(index2, 2)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_available(), 3)
    @assertEqual(scratch%get_n_inuse(), 3)

    ! do something with the vector
    call vector_cfill(v1, 1.0_rp)
    call vector_cfill(v2, 2.0_rp)
    call vector_cfill(v3, 3.0_rp)

    call v1%copy_from(DEVICE_TO_HOST, sync = .false.)
    call v2%copy_from(DEVICE_TO_HOST, sync = .false.)
    call v3%copy_from(DEVICE_TO_HOST, sync = .false.)

    @assertEqual(v1%x(1), 1.0_rp)
    @assertEqual(v2%x(1), 2.0_rp)
    @assertEqual(v3%x(1), 3.0_rp)

    call scratch%free()
  end subroutine test_scratch_registry_request_vector_fresh

  @test
  subroutine test_scratch_registry_relinquish_vector()
    type(scratch_registry_t) :: scratch
    type(vector_t), pointer :: v
    integer :: ierr, index
    !
    call scratch%init(5, 3)

    call scratch%request_vector(42, v, index)
    call scratch%relinquish_vector(index)
    @assertEqual(scratch%get_inuse(index), .false.)
    @assertEqual(scratch%get_n_inuse(), 0)
    @assertEqual(scratch%get_n_available(), 1)

    call scratch%free()
  end subroutine test_scratch_registry_relinquish_vector

  @test
  subroutine test_scratch_registry_request_matrix_fresh()
    type(scratch_registry_t) :: scratch
    type(matrix_t), pointer :: m1, m2, m3
    integer :: ierr, index1, index2, index3

    ! write(*,*) "TEST FRESH"

    call scratch%init(5, 3)

    call scratch%request_matrix(42, 42, m1, index1)
    call scratch%request_matrix(42, 42, m2, index2)
    call scratch%request_matrix(42, 42, m3, index3)
    @assertEqual(index1, 1)
    @assertEqual(index2, 2)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_available(), 3)
    @assertEqual(scratch%get_n_inuse(), 3)

    ! do something with the matrix
    call matrix_cfill(m1, 1.0_rp)
    call matrix_cfill(m2, 2.0_rp)
    call matrix_cfill(m3, 3.0_rp)

    call m1%copy_from(DEVICE_TO_HOST, sync = .false.)
    call m2%copy_from(DEVICE_TO_HOST, sync = .false.)
    call m3%copy_from(DEVICE_TO_HOST, sync = .false.)

    @assertEqual(m1%x(1, 1), 1.0_rp)
    @assertEqual(m2%x(1, 1), 2.0_rp)
    @assertEqual(m3%x(1, 1), 3.0_rp)

    call scratch%free()
  end subroutine test_scratch_registry_request_matrix_fresh

  @test
  subroutine test_scratch_registry_relinquish_matrix()
    type(scratch_registry_t) :: scratch
    type(matrix_t), pointer :: m
    integer :: ierr, index
    !
    call scratch%init(5, 3)

    call scratch%request_matrix(42, 42, m, index)
    call scratch%relinquish_matrix(index)
    @assertEqual(scratch%get_inuse(index), .false.)
    @assertEqual(scratch%get_n_inuse(), 0)
    @assertEqual(scratch%get_n_available(), 1)

    call scratch%free()
  end subroutine test_scratch_registry_relinquish_matrix

  @test
  subroutine test_scratch_registry_request_mixed_fresh()
    type(space_t) :: Xh
    type(mesh_t) :: msh
    type(dofmap_t) :: dm
    type(scratch_registry_t) :: scratch
    type(field_t), pointer :: f1, f2, f3
    type(vector_t), pointer :: v1
    type(matrix_t), pointer :: m1
    integer :: ierr, index1, index2, index3, index4, index5
    integer, parameter :: LX = 3

    ! write(*,*) "TEST FRESH"
    call test_scratch_registry_gen_msh(msh)
    call Xh%init(GLL, lx, lx, lx)
    call dm%init(msh, Xh)

    call scratch%init(5, 3, dm)

    call scratch%request_field(f1, index1)
    call scratch%request_field(f2, index2)
    call scratch%request_field(f3, index3)
    call scratch%request_vector(42, v1, index4)
    call scratch%request_matrix(42, 42, m1, index5)

    @assertEqual(index1, 1)
    @assertEqual(index2, 2)
    @assertEqual(index3, 3)
    @assertEqual(index4, 4)
    @assertEqual(index5, 5)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_inuse(index3), .true.)
    @assertEqual(scratch%get_inuse(index4), .true.)
    @assertEqual(scratch%get_inuse(index5), .true.)
    @assertEqual(scratch%get_n_available(), 5)
    @assertEqual(scratch%get_n_inuse(), 5)

    ! do something with the field
    call cfill(f1%x, 1.0_rp, f1%size())
    call cfill(f2%x, 2.0_rp, f2%size())
    call cfill(f3%x, 3.0_rp, f3%size())
    call cfill(v1%x, 4.0_rp, v1%size())
    call cfill(m1%x, 5.0_rp, m1%size())
    @assertEqual(f1%x(1,1,1,1), 1.0_rp)
    @assertEqual(f2%x(1,1,1,1), 2.0_rp)
    @assertEqual(f3%x(1,1,1,1), 3.0_rp)
    @assertEqual(v1%x(1), 4.0_rp)
    @assertEqual(m1%x(1,1), 5.0_rp)

    call scratch%free()
  end subroutine test_scratch_registry_request_mixed_fresh

  @test
  subroutine test_scratch_registry_relinquish_mixed()
    type(space_t) :: Xh
    type(mesh_t) :: msh
    type(dofmap_t) :: dm
    type(scratch_registry_t) :: scratch
    type(field_t), pointer :: f
    type(vector_t), pointer :: v
    type(matrix_t), pointer :: m
    integer :: ierr, index, v_index, m_index
    integer, parameter :: LX = 3

    call test_scratch_registry_gen_msh(msh)
    call Xh%init(GLL, lx, lx, lx)
    call dm%init(msh, Xh)

    call scratch%init(5, 3, dm)

    call scratch%request_field(f, index)
    call scratch%relinquish_field(index)

    call scratch%request_vector(42, v, v_index)
    call scratch%relinquish_vector(v_index)

    call scratch%request_matrix(42, 42, m, m_index)
    call scratch%relinquish_matrix(m_index)

    @assertEqual(scratch%get_inuse(index), .false.)
    @assertEqual(scratch%get_n_inuse(), 0)
    @assertEqual(scratch%get_n_available(), 3)

    call scratch%free()
  end subroutine test_scratch_registry_relinquish_mixed

  @test
  subroutine test_scratch_registry_expand()
    type(space_t) :: Xh
    type(mesh_t) :: msh
    type(dofmap_t) :: dm
    type(scratch_registry_t), target :: scratch
    type(field_t), pointer :: f1, f2
    type(vector_t), pointer :: v1
    type(matrix_t), pointer :: m1
    integer :: ierr, index1, index2, index3, index4
    integer, parameter :: LX = 2

    ! write(*,*) "TEST EXPAND"

    call test_scratch_registry_gen_msh(msh)
    call Xh%init(GLL, lx, lx, lx)
    call dm%init(msh, Xh)

    call scratch%init(1, 1, dm)

    call scratch%request_field(f1, index1)
    call cfill(f1%x, 1.0_rp, f1%size())
    @assertEqual(f1%x(1,1,1,1), 1.0_rp)

    ! add new field, trigging expand
    call scratch%request_field(f2, index2)
    call scratch%request_vector(42, v1, index3)
    call scratch%request_matrix(42, 42, m1, index4)

    ! try to use the second field
    call cfill(f2%x, 2.0_rp, dm%size())

    ! make sure values in f1 preserved after expansion
    @assertEqual(f1%x(1,1,1,1), 1.0_rp)
    @assertEqual(f2%x(1,1,1,1), 2.0_rp)
    @assertEqual(index1, 1)
    @assertEqual(index2, 2)
    @assertEqual(index3, 3)
    @assertEqual(index4, 4)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_available(), 4)
    @assertEqual(scratch%get_n_inuse(), 4)
    @assertEqual(scratch%get_size(), 4)

    call scratch%free()
  end subroutine test_scratch_registry_expand

  @test
  subroutine test_scratch_registry_combo()
    type(space_t) :: Xh
    type(mesh_t) :: msh
    type(dofmap_t) :: dm
    type(scratch_registry_t), target :: scratch
    type(field_t), pointer :: f1, f2, f3
    integer :: ierr, index1, index2, index3
    integer, parameter :: LX = 2

    call test_scratch_registry_gen_msh(msh)
    call Xh%init(GLL, lx, lx, lx)
    call dm%init(msh, Xh)

    !  write(*,*) "TEST COMBO"
    call scratch%init(2, 2, dm)

    ! add 2 fields, no expansion
    call scratch%request_field(f1, index1)
    call scratch%request_field(f2, index2)
    call cfill(f1%x, 1.0_rp, f1%size())
    call cfill(f2%x, 2.0_rp, f2%size())

    @assertEqual(index1, 1)
    @assertEqual(index2, 2)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_available(), 2)
    @assertEqual(scratch%get_n_inuse(), 2)
    @assertEqual(scratch%get_size(), 2)

    ! get rid of one field
    call scratch%relinquish_field(index1)
    @assertEqual(scratch%get_inuse(index1), .false.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_available(), 2)
    @assertEqual(scratch%get_n_inuse(), 1)
    @assertEqual(scratch%get_size(), 2)

    ! get a new field, should get index 1
    call scratch%request_field(f1, index1)
    call cfill(f1%x, 1.5_rp, f1%size())
    @assertEqual(index1, 1)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_available(), 2)
    @assertEqual(scratch%get_n_inuse(), 2)
    @assertEqual(scratch%get_size(), 2)

    ! check that the fields have survived
    @assertEqual(f1%x(1,1,1,1), 1.5_rp)
    @assertEqual(f2%x(1,1,1,1), 2.0_rp)

    ! get a another field, should get index 3 and triger expand
    call scratch%request_field(f3, index3)
    call cfill(f3%x, 3.0_rp, f3%size())
    @assertEqual(index3, 3)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_inuse(index3), .true.)
    @assertEqual(scratch%get_n_available(), 3)
    @assertEqual(scratch%get_n_inuse(), 3)
    @assertEqual(scratch%get_size(), 4)

    ! check that the fields have survived
    @assertEqual(f1%x(1,1,1,1), 1.5_rp)
    @assertEqual(f2%x(1,1,1,1), 2.0_rp)
    @assertEqual(f3%x(1,1,1,1), 3.0_rp)

    call scratch%free()
  end subroutine test_scratch_registry_combo

  @test
  subroutine test_scratch_registry_array_indices()
    type(space_t) :: Xh
    type(mesh_t) :: msh
    type(dofmap_t) :: dm
    type(scratch_registry_t), target :: scratch
    type(field_t), pointer :: f1
    type(vector_t), pointer :: v1
    type(matrix_t), pointer :: m1
    integer :: ierr
    integer :: indices(3)

    integer, parameter :: LX = 2

    call test_scratch_registry_gen_msh(msh)
    call Xh%init(GLL, lx, lx, lx)
    call dm%init(msh, Xh)

    !  write(*,*) "TEST COMBO"
    call scratch%init(2, 2, dm)

    ! add 2 fields, no expansion
    call scratch%request_field(f1, indices(1))
    call scratch%request_vector(31, v1, indices(2))
    call scratch%request_matrix(62, 425, m1, indices(3))

    @assertEqual(indices(1), 1)
    @assertEqual(indices(2), 2)
    @assertEqual(indices(3), 3)

    call cfill(f1%x, 1.0_rp, f1%size())
    call cfill(v1%x, 2.0_rp, v1%size())
    call cfill(m1%x, 2.0_rp, m1%size())

    ! get rid of the fields
    call scratch%relinquish(indices)
    @assertEqual(scratch%get_inuse(indices(1)), .false.)
    @assertEqual(scratch%get_inuse(indices(2)), .false.)
    @assertEqual(scratch%get_inuse(indices(3)), .false.)
    @assertEqual(scratch%get_n_available(), 3)
    @assertEqual(scratch%get_n_inuse(), 0)

    ! get a new field, should get index 1
    call scratch%request_field(f1, indices(1))
    call cfill(f1%x, 1.5_rp, f1%size())
    @assertEqual(indices(1), 1)
    @assertEqual(scratch%get_inuse(indices(1)), .true.)
    @assertEqual(scratch%get_n_available(), 3)
    @assertEqual(scratch%get_n_inuse(), 1)

    call scratch%free()
  end subroutine test_scratch_registry_array_indices
end module test_scratch_registry
