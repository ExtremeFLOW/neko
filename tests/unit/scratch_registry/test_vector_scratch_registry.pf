module test_vector_scratch_registry
  use pfunit
  use vector, only : vector_t
  use vector_math, only : vector_cfill
  use scratch_registry, only : scratch_registry_t
  use num_types, only : rp
  use device, only : DEVICE_TO_HOST, device_init, device_finalize
  use neko_config, only : NEKO_BCKND_DEVICE
  implicit none


  @TestCase
  type, extends(TestCase) :: test_vector_scratch_reg
   contains
     procedure :: setUp
     procedure :: tearDown
  end type test_vector_scratch_reg

contains

  subroutine setUp(this)
    class(test_vector_scratch_reg), intent(inout) :: this
    if (NEKO_BCKND_DEVICE .eq. 1) then
       call device_init
    end if
  end subroutine setUp

  subroutine tearDown(this)
    class(test_vector_scratch_reg), intent(inout) :: this
    if (NEKO_BCKND_DEVICE .eq. 1) then
       call device_finalize
    end if
  end subroutine tearDown
  
  @test
  subroutine test_vec_scratch_reg_init_default(this)
    class(test_vector_scratch_reg), intent(inout) :: this
    type(scratch_registry_t) :: scratch
    integer :: ierr

    call scratch%init()

    @assertEqual(scratch%get_n_available(), 0)
    @assertEqual(scratch%get_expansion_size(), 10)
    @assertEqual(scratch%get_size(), 10)
    @assertEqual(scratch%get_n_inuse(), 0)

    call scratch%free()
  end subroutine test_vec_scratch_reg_init_default

  @test
  subroutine test_vec_scratch_reg_init(this)
    class(test_vector_scratch_reg), intent(inout) :: this
    type(scratch_registry_t) :: scratch
    integer :: ierr

    call scratch%init(5, 3)

    @assertEqual(scratch%get_n_available(), 0)
    @assertEqual(scratch%get_expansion_size(), 3)
    @assertEqual(scratch%get_size(), 5)
    @assertEqual(scratch%get_n_inuse(), 0)

    call scratch%free()
  end subroutine test_vec_scratch_reg_init

  @test
  subroutine test_vec_scratch_reg_request_vector_fresh(this)
    class(test_vector_scratch_reg), intent(inout) :: this
    type(scratch_registry_t) :: scratch
    type(vector_t), pointer :: v1, v2, v3
    integer :: ierr, index1, index2, index3

    ! write(*,*) "TEST FRESH"

    call scratch%init(5, 3)

    call scratch%request_vector(42, v1, index1, .false.)
    call scratch%request_vector(42, v2, index2, .false.)
    call scratch%request_vector(42, v3, index3, .false.)
    @assertEqual(index1, 1)
    @assertEqual(index2, 2)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_available(), 3)
    @assertEqual(scratch%get_n_inuse(), 3)

    ! do something with the vector
    call vector_cfill(v1, 1.0_rp)
    call vector_cfill(v2, 2.0_rp)
    call vector_cfill(v3, 3.0_rp)

    call v1%copy_from(DEVICE_TO_HOST, sync = .false.)
    call v2%copy_from(DEVICE_TO_HOST, sync = .false.)
    call v3%copy_from(DEVICE_TO_HOST, sync = .true.)

    @assertEqual(v1%x(1), 1.0_rp)
    @assertEqual(v2%x(1), 2.0_rp)
    @assertEqual(v3%x(1), 3.0_rp)

    call scratch%relinquish_vector(index1)
    call scratch%relinquish_vector(index2)
    call scratch%relinquish_vector(index3)
    call scratch%free()
  end subroutine test_vec_scratch_reg_request_vector_fresh

  @test
  subroutine test_vec_scratch_reg_relinquish_vector(this)
    class(test_vector_scratch_reg), intent(inout) :: this
    type(scratch_registry_t) :: scratch
    type(vector_t), pointer :: v
    integer :: ierr, index
    !
    call scratch%init(5, 3)

    call scratch%request_vector(42, v, index, .false.)
    call scratch%relinquish_vector(index)
    @assertEqual(scratch%get_inuse(index), .false.)
    @assertEqual(scratch%get_n_inuse(), 0)
    @assertEqual(scratch%get_n_available(), 1)

    call scratch%free()
  end subroutine test_vec_scratch_reg_relinquish_vector

  @test
  subroutine test_vec_scratch_reg_relinquish_vector_list(this)
    class(test_vector_scratch_reg), intent(inout) :: this
    type(scratch_registry_t) :: scratch
    type(vector_t), pointer :: v1, v2
    integer :: ierr, indices(2)
    !
    call scratch%init(5, 3)

    call scratch%request_vector(42, v1, indices(1), .false.)
    call scratch%request_vector(42, v2, indices(2), .false.)
    call scratch%relinquish_vector(indices)
    @assertEqual(scratch%get_inuse(indices(1)), .false.)
    @assertEqual(scratch%get_inuse(indices(2)), .false.)
    @assertEqual(scratch%get_n_inuse(), 0)
    @assertEqual(scratch%get_n_available(), 2)

    call scratch%free()
  end subroutine test_vec_scratch_reg_relinquish_vector_list

  @test
  subroutine test_vec_scratch_reg_expand(this)
    class(test_vector_scratch_reg), intent(inout) :: this
    type(scratch_registry_t), target :: scratch
    type(vector_t), pointer :: v1, v2
    integer :: ierr, index1, index2

    ! write(*,*) "TEST EXPAND"

    call scratch%init(1, 1)

    call scratch%request_vector(42, v1, index1, .false.)
    call vector_cfill(v1, 1.0_rp)

    call v1%copy_from(DEVICE_TO_HOST, sync = .true.)
    @assertEqual(v1%x(1), 1.0_rp)

    ! add new vector, trigging expand
    call scratch%request_vector(84, v2, index2, .false.)

    ! try to use the second vector
    call vector_cfill(v2, 2.0_rp)

    ! make sure values in v1 preserved after expansion
    call v1%copy_from(DEVICE_TO_HOST, sync = .false.)
    call v2%copy_from(DEVICE_TO_HOST, sync = .true.)

    @assertEqual(v1%x(1), 1.0_rp)
    @assertEqual(v2%x(1), 2.0_rp)
    @assertEqual(v1%size(), 42)
    @assertEqual(v2%size(), 84)
    @assertEqual(index1, 1)
    @assertEqual(index2, 2)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_available(), 2)
    @assertEqual(scratch%get_n_inuse(), 2)
    @assertEqual(scratch%get_size(), 2)

    call scratch%relinquish_vector(index1)
    call scratch%relinquish_vector(index2)
    call scratch%free()
  end subroutine test_vec_scratch_reg_expand

  @test
  subroutine test_vec_scratch_reg_combo(this)
    class(test_vector_scratch_reg), intent(inout) :: this
    type(scratch_registry_t), target :: scratch
    type(vector_t), pointer :: v1, v2, v3
    integer :: ierr, index1, index2, index3

    !  write(*,*) "TEST COMBO"
    call scratch%init(2, 2)

    ! add 2 vectors, no expansion
    call scratch%request_vector(42, v1, index1, .false.)
    call scratch%request_vector(42, v2, index2, .false.)
    call vector_cfill(v1, 1.0_rp)
    call vector_cfill(v2, 2.0_rp)

    @assertEqual(index1, 1)
    @assertEqual(index2, 2)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_available(), 2)
    @assertEqual(scratch%get_n_inuse(), 2)
    @assertEqual(scratch%get_size(), 2)

    ! get rid of one vector
    call scratch%relinquish_vector(index1)
    @assertEqual(scratch%get_inuse(index1), .false.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_available(), 2)
    @assertEqual(scratch%get_n_inuse(), 1)
    @assertEqual(scratch%get_size(), 2)

    ! get a new vector, should get index 1
    call scratch%request_vector(42, v1, index1, .false.)
    call vector_cfill(v1, 1.5_rp)
    @assertEqual(index1, 1)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_n_available(), 2)
    @assertEqual(scratch%get_n_inuse(), 2)
    @assertEqual(scratch%get_size(), 2)

    ! check that the vectors have survived
    call v1%copy_from(DEVICE_TO_HOST, sync = .false.)
    call v2%copy_from(DEVICE_TO_HOST, sync = .true.)
    @assertEqual(v1%x(1), 1.5_rp)
    @assertEqual(v2%x(1), 2.0_rp)

    ! get a another vector, should get index 3 and triger expand
    call scratch%request_vector(42, v3, index3, .false.)
    call vector_cfill(v3, 3.0_rp)
    @assertEqual(index3, 3)
    @assertEqual(scratch%get_inuse(index1), .true.)
    @assertEqual(scratch%get_inuse(index2), .true.)
    @assertEqual(scratch%get_inuse(index3), .true.)
    @assertEqual(scratch%get_n_available(), 3)
    @assertEqual(scratch%get_n_inuse(), 3)
    @assertEqual(scratch%get_size(), 4)

    ! check that the vectors have survived
    call v1%copy_from(DEVICE_TO_HOST, sync = .false.)
    call v2%copy_from(DEVICE_TO_HOST, sync = .false.)
    call v3%copy_from(DEVICE_TO_HOST, sync = .true.)
    @assertEqual(v1%x(1), 1.5_rp)
    @assertEqual(v2%x(1), 2.0_rp)
    @assertEqual(v3%x(1), 3.0_rp)

    call scratch%relinquish_vector(index1)
    call scratch%relinquish_vector(index2)
    call scratch%relinquish_vector(index3)
    call scratch%free()
  end subroutine test_vec_scratch_reg_combo

  @test
  subroutine test_vec_scratch_reg_array_indices(this)
    class(test_vector_scratch_reg), intent(inout) :: this
    type(scratch_registry_t), target :: scratch
    type(vector_t), pointer :: v1, v2, v3
    integer :: ierr
    integer :: indices(3)

    !  write(*,*) "TEST COMBO"
    call scratch%init(2, 2)

    ! add 2 vectors, no expansion
    call scratch%request_vector(42, v1, indices(1), .false.)
    call scratch%request_vector(42, v2, indices(2), .false.)
    call scratch%request_vector(42, v3, indices(3), .false.)

    @assertEqual(indices(1), 1)
    @assertEqual(indices(2), 2)
    @assertEqual(indices(3), 3)

    call vector_cfill(v1, 1.0_rp)
    call vector_cfill(v2, 2.0_rp)
    call vector_cfill(v3, 2.0_rp)

    ! get rid of the vectors
    call scratch%relinquish_vector(indices)
    @assertEqual(scratch%get_inuse(indices(1)), .false.)
    @assertEqual(scratch%get_inuse(indices(2)), .false.)
    @assertEqual(scratch%get_inuse(indices(3)), .false.)
    @assertEqual(scratch%get_n_available(), 3)
    @assertEqual(scratch%get_n_inuse(), 0)

    ! get a new vector, should get index 1
    call scratch%request_vector(42, v1, indices(1), .false.)
    call vector_cfill(v1, 1.5_rp)
    @assertEqual(indices(1), 1)
    @assertEqual(scratch%get_inuse(indices(1)), .true.)
    @assertEqual(scratch%get_n_available(), 3)
    @assertEqual(scratch%get_n_inuse(), 1)

    call scratch%relinquish_vector(indices(1))
    call scratch%free()
  end subroutine test_vec_scratch_reg_array_indices
end module test_vector_scratch_registry
