module point_interpolation_test
  use mpi
  use pfunit
  use device
  use point_interpolation, only : point_interpolator_t
  use num_types, only : rp
  use mesh
  use coefs
  use dofmap
  use gather_scatter
  use space
  use point
  implicit none

  @TestCase
  type, extends(MPITestCase) :: test_point_interpolator
  !  contains
  !    procedure :: setUp
  !    procedure :: tearDown
  end type test_point_interpolator

contains
  ! subroutine setUp(this)
  !   class(test_point_interpolator), intent(inout) :: this
  !   if (NEKO_BCKND_DEVICE .eq. 1) then
  !      call device_init
  !   end if
  ! end subroutine setUp

  ! subroutine tearDown(this)
  !   class(test_point_interpolator), intent(inout) :: this
  !   if (NEKO_BCKND_DEVICE .eq. 1) then
  !        call device_finalize
  !  end if
  ! end subroutine tearDown

  subroutine point_interpolation_test_gen_msh(msh)
    implicit none
    type(mesh_t) :: msh

    type(point_t) :: p(12)

    p(1) = point_t(1d0, 1d0, 1d0)
    call p(1)%set_id(1)
    p(2) = point_t(2d0, 1d0, 1d0)
    call p(2)%set_id(2)
    p(3) = point_t(1d0, 2d0, 1d0)
    call p(3)%set_id(4)
    p(4) = point_t(2d0, 2d0, 1d0)
    call p(4)%set_id(3)
    p(5) = point_t(1d0, 1d0, 2d0)
    call p(5)%set_id(5)
    p(6) = point_t(2d0, 1d0, 2d0)
    call p(6)%set_id(6)
    p(7) = point_t(1d0, 2d0, 2d0)
    call p(7)%set_id(7)
    p(8) = point_t(2d0, 2d0, 2d0)
    call p(8)%set_id(8)

    call mesh_init(msh, 3, 1)
    call mesh_add_element(msh, 1, p(1), p(2), p(3), p(4), p(5), p(6), p(7), p(8))

  end subroutine point_interpolation_test_gen_msh

  subroutine point_interpolation_test_gen_coef(msh, coef, lx)
    implicit none
    type(mesh_t) :: msh
    type(coef_t) :: coef
    integer :: lx
    type(dofmap_t) :: dof
    type(gs_t) :: gs
    type(space_t) :: xh

    call space_init(Xh, GLL, lx, lx, lx)
    dof = dofmap_t(msh, xh)
    call gs_init(gs, dof)
    call coef_init(coef, gs)

  end subroutine point_interpolation_test_gen_coef

  @test(npes=[1])
  subroutine point_interpolation_test_init(this)
    implicit none
    class(test_point_interpolator), intent(inout) :: this
    type(point_interpolator_t) :: interp
    type(coef_t) :: coef
    type(mesh_t) :: msh
    integer, parameter :: lx = 4
    integer :: ierr

    call MPI_Comm_dup(this%getMpiCommunicator(), NEKO_COMM%mpi_val, ierr)

    call point_interpolation_test_gen_msh(msh)
    ! call point_interpolation_test_gen_coef(msh, coef, lx)

    ! call interp%init(coef) ! initialize the interpolator object

    ! @assertTrue(associated(interp%coef))
    ! @assertTrue(associated(interp%xh))

  end subroutine point_interpolation_test_init

  @test(npes=[1])
  subroutine point_interpolation_test_interpolation(this)
    implicit none
    class(test_point_interpolator), intent(inout) :: this
    type(point_interpolator_t) :: interp
    type(coef_t) :: coef
    type(mesh_t) :: msh
    integer, parameter :: lx = 4
    integer :: ierr
    type(point_t) :: rst(4) ! A list of  r,s,t coordinates
    type(point_t) :: xyz(4), xyz_equal(4) ! the results of the interpolation

    integer :: e = 1 ! our element index (in this example we only use a 1-element mesh)

    ! call MPI_Comm_dup(this%getMpiCommunicator(), NEKO_COMM%mpi_val, ierr)
  !   call point_interpolation_test_gen_msh(msh)
  !   call point_interpolation_test_gen_coef(msh, coef, lx)

  !   ! Initialize the r,s,t values
  !   rst(1) = (/ 1.0_rp,  0.0_rp, -0.5_rp/)
  !   rst(2) = (/ 0.4_rp, -0.3_rp, -1.0_rp/)
  !   rst(3) = (/-1.0_rp, -1.0_rp, -1.0_rp/)
  !   rst(4) = (/ 1.0_rp,  1.0_rp,  1.0_rp/)

  !   xyz_equal(1) = (/2.0_rp,  1.5_rp , 1.25_rp/)
  !   xyz_equal(2) = (/1.7_rp, 1.35_rp, 1.0_rp/)
  !   xyz_equal(3) = (/1.0_rp, 1.0_rp, 1.0_rp/)
  !   xyz_equal(4) = (/ 2.0_rp,  2.0_rp,  2.0_rp/)

  !   call interp%init(coef) ! initialize the interpolator object

  !   xyz = interp%interpolate(4, rst, coef%dof%x(:,:,:,e), &
  !        coef%dof%y(:,:,:,e), coef%dof%z(:,:,:,e))

  !   @assertTrue(xyz(1) .eq. xyz_equal(1))
  !   @assertTrue(xyz(2) .eq. xyz_equal(2))
  !   @assertTrue(xyz(3) .eq. xyz_equal(3))
  !   @assertTrue(xyz(4) .eq. xyz_equal(4))

  end subroutine point_interpolation_test_interpolation

end module
