@test
subroutine test_alignment_edge_i4
  use pfunit
  use num_types, only : i4, i8, dp
  use alignment_edge, only : alignment_edge_t
  implicit none
  type(alignment_edge_t) :: edge
  integer(i4), parameter :: sz = 5
  integer(i4), dimension(sz) :: edg
  integer(i4), dimension(sz, 2) :: edg_bnd, edg_int
  integer(i4) :: il, jl

  ! initialise various operations
  ! I - identity
  ! P - permutation
  ! full edge
  ! I
  do il = 1, sz
     edg_bnd(il, 1) = il - 1
  end do
  ! P
  do il = 1, sz
     edg_bnd(sz + 1 - il, 2) = il - 1
  end do
  ! edge interior
  edg_int(:, :) = edg_bnd(:, :)
  edg_int(1, 2) = edg_bnd(1, 1)
  edg_int(sz, 2) = edg_bnd(sz, 1)


  call edge%init()

  ! check number of operations
  @assertEqual(edge%nop(), 1_i4)

  ! full edge test
  do il = 0, edge%nop()
     ! direct
     edg(:) = edg_bnd(:, 1)
     call edge%trns_f_i4(il)%ptr(sz, edg)
     do jl = 1, sz
        @assertEqual(edg(jl), edg_bnd(jl, il + 1))
     end do
     ! inverse
     call edge%trns_inv_f_i4(il)%ptr(sz, edg)
     do jl = 1, sz
        @assertEqual(edg(jl), edg_bnd(jl, 1))
     end do
  end do

  ! interior edge test
  do il = 0, edge%nop()
     ! direct
     edg(:) = edg_bnd(:, 1)
     call edge%trns_i_i4(il)%ptr(sz, edg)
     do jl = 1, sz
        @assertEqual(edg(jl), edg_int(jl, il + 1))
     end do
     ! inverse
     call edge%trns_inv_i_i4(il)%ptr(sz, edg)
     do jl = 1, sz
        @assertEqual(edg(jl), edg_bnd(jl, 1))
     end do
  end do

end subroutine test_alignment_edge_i4

@test
subroutine test_alignment_edge_i8
  use pfunit
  use num_types, only : i4, i8, dp
  use alignment_edge, only : alignment_edge_t
  implicit none
  type(alignment_edge_t) :: edge
  integer(i4), parameter :: sz = 4
  integer(i8), dimension(sz) :: edg
  integer(i8), dimension(sz, 2) :: edg_bnd, edg_int
  integer(i4) :: il, jl

  ! initialise various operations
  ! I - identity
  ! P - permutation
  ! full edge
  ! I
  do il = 1, sz
     edg_bnd(il, 1) = il - 1
  end do
  ! P
  do il = 1, sz
     edg_bnd(sz + 1 - il, 2) = il - 1
  end do
  ! edge interior
  edg_int(:, :) = edg_bnd(:, :)
  edg_int(1, 2) = edg_bnd(1, 1)
  edg_int(sz, 2) = edg_bnd(sz, 1)

  call edge%init()

  ! check number of operations
  @assertEqual(edge%nop(), 1)

  ! full edge test
  do il = 0, edge%nop()
     ! direct
     edg(:) = edg_bnd(:, 1)
     call edge%trns_f_i8(il)%ptr(sz, edg)
     do jl = 1, sz
        @assertEqual(edg(jl), edg_bnd(jl, il + 1))
     end do
     ! inverse
     call edge%trns_inv_f_i8(il)%ptr(sz, edg)
     do jl = 1, sz
        @assertEqual(edg(jl), edg_bnd(jl, 1))
     end do
  end do

  ! interior edge test
  do il = 0, edge%nop()
     ! direct
     edg(:) = edg_bnd(:, 1)
     call edge%trns_i_i8(il)%ptr(sz, edg)
     do jl = 1, sz
        @assertEqual(edg(jl), edg_int(jl, il + 1))
     end do
     ! inverse
     call edge%trns_inv_i_i8(il)%ptr(sz, edg)
     do jl = 1, sz
        @assertEqual(edg(jl), edg_bnd(jl, 1))
     end do
  end do

end subroutine test_alignment_edge_i8

@test
subroutine test_alignment_edge_dp
  use pfunit
  use num_types, only : i4, i8, dp
  use alignment_edge, only : alignment_edge_t
  implicit none
  type(alignment_edge_t) :: edge
  integer(i4), parameter :: sz = 4
  real(dp), dimension(sz) :: edg
  real(dp), dimension(sz, 2) :: edg_bnd, edg_int
  integer(i4) :: il, jl

  ! initialise various operations
  ! I - identity
  ! P - permutation
  ! full edge
  ! I
  do il = 1, sz
     edg_bnd(il, 1) = il - 1
  end do
  ! P
  do il = 1, sz
     edg_bnd(sz + 1 - il, 2) = il - 1
  end do
  ! edge interior
  edg_int(:, :) = edg_bnd(:, :)
  edg_int(1, 2) = edg_bnd(1, 1)
  edg_int(sz, 2) = edg_bnd(sz, 1)

  call edge%init()

  ! check number of operations
  @assertEqual(edge%nop(), 1)

  ! full edge test
  do il = 0, edge%nop()
     ! direct
     edg(:) = edg_bnd(:, 1)
     call edge%trns_f_dp(il)%ptr(sz, edg)
     do jl = 1, sz
        @assertEqual(edg(jl), edg_bnd(jl, il + 1), tolerance=1d-14)
     end do
     ! inverse
     call edge%trns_inv_f_dp(il)%ptr(sz, edg)
     do jl = 1, sz
        @assertEqual(edg(jl), edg_bnd(jl, 1), tolerance=1d-14)
     end do
  end do

  ! interior edge test
  do il = 0, edge%nop()
     ! direct
     edg(:) = edg_bnd(:, 1)
     call edge%trns_i_dp(il)%ptr(sz, edg)
     do jl = 1, sz
        @assertEqual(edg(jl), edg_int(jl, il + 1), tolerance=1d-14)
     end do
     ! inverse
     call edge%trns_inv_i_dp(il)%ptr(sz, edg)
     do jl = 1, sz
        @assertEqual(edg(jl), edg_bnd(jl, 1), tolerance=1d-14)
     end do
  end do

end subroutine test_alignment_edge_dp

@test
subroutine test_alignment_edge_op_set_i4
  use pfunit
  use num_types, only : i4, i8, dp
  use alignment_edge, only : alignment_edge_t, alignment_edge_op_set_t
  implicit none
  type(alignment_edge_t) :: edgev
  type(alignment_edge_op_set_t) :: edges
  integer(i4), parameter :: sz = 5
  integer(i4), dimension(sz) :: edgv, edgs
  integer(i4), dimension(sz) :: edg_bnd
  integer(i4) :: il, jl

  ! initial condition
  do il = 1, sz
     edg_bnd(il) = il - 1
  end do

  call edgev%init()

  ! full edge test
  do il = 0, edgev%nop()
     ! direct
     edgv(:) = edg_bnd(:)
     edgs(:) = edg_bnd(:)
     call edgev%trns_f_i4(il)%ptr(sz, edgv)
     call edges%init(il)
     call edges%trns_f_i4%ptr(sz, edgs)
     do jl = 1, sz
        @assertEqual(edgv(jl), edgs(jl))
     end do
     ! inverse
     call edges%trns_inv_f_i4%ptr(sz, edgs)
     do jl = 1, sz
        @assertEqual(edgs(jl), edg_bnd(jl))
     end do
  end do

  ! interior edge test
  do il = 0, edgev%nop()
     ! direct
     edgv(:) = edg_bnd(:)
     edgs(:) = edg_bnd(:)
     call edgev%trns_i_i4(il)%ptr(sz, edgv)
     call edges%init(il)
     call edges%trns_i_i4%ptr(sz, edgs)
     do jl = 1, sz
        @assertEqual(edgv(jl), edgs(jl))
     end do
     ! inverse
     call edges%trns_inv_i_i4%ptr(sz, edgs)
     do jl = 1, sz
        @assertEqual(edgs(jl), edg_bnd(jl))
     end do
  end do

end subroutine test_alignment_edge_op_set_i4

@test
subroutine test_alignment_edge_op_set_i8
  use pfunit
  use num_types, only : i4, i8, dp
  use alignment_edge, only : alignment_edge_t, alignment_edge_op_set_t
  implicit none
  type(alignment_edge_t) :: edgev
  type(alignment_edge_op_set_t) :: edges
  integer(i4), parameter :: sz = 5
  integer(i8), dimension(sz) :: edgv, edgs
  integer(i8), dimension(sz) :: edg_bnd
  integer(i4) :: il, jl

  ! initial condition
  do il = 1, sz
     edg_bnd(il) = il - 1
  end do

  call edgev%init()

  ! full edge test
  do il = 0, edgev%nop()
     ! direct
     edgv(:) = edg_bnd(:)
     edgs(:) = edg_bnd(:)
     call edgev%trns_f_i8(il)%ptr(sz, edgv)
     call edges%init(il)
     call edges%trns_f_i8%ptr(sz, edgs)
     do jl = 1, sz
        @assertEqual(edgv(jl), edgs(jl))
     end do
     ! inverse
     call edges%trns_inv_f_i8%ptr(sz, edgs)
     do jl = 1, sz
        @assertEqual(edgs(jl), edg_bnd(jl))
     end do
  end do

  ! interior edge test
  do il = 0, edgev%nop()
     ! direct
     edgv(:) = edg_bnd(:)
     edgs(:) = edg_bnd(:)
     call edgev%trns_i_i8(il)%ptr(sz, edgv)
     call edges%init(il)
     call edges%trns_i_i8%ptr(sz, edgs)
     do jl = 1, sz
        @assertEqual(edgv(jl), edgs(jl))
     end do
     ! inverse
     call edges%trns_inv_i_i8%ptr(sz, edgs)
     do jl = 1, sz
        @assertEqual(edgs(jl), edg_bnd(jl))
     end do
  end do

end subroutine test_alignment_edge_op_set_i8

@test
subroutine test_alignment_edge_op_set_dp
  use pfunit
  use num_types, only : i4, i8, dp
  use alignment_edge, only : alignment_edge_t, alignment_edge_op_set_t
  implicit none
  type(alignment_edge_t) :: edgev
  type(alignment_edge_op_set_t) :: edges
  integer(i4), parameter :: sz = 5
  real(dp), dimension(sz) :: edgv, edgs
  real(dp), dimension(sz) :: edg_bnd
  integer(i4) :: il, jl

  ! initial condition
  do il = 1, sz
     edg_bnd(il) = il - 1
  end do

  call edgev%init()

  ! full edge test
  do il = 0, edgev%nop()
     ! direct
     edgv(:) = edg_bnd(:)
     edgs(:) = edg_bnd(:)
     call edgev%trns_f_dp(il)%ptr(sz, edgv)
     call edges%init(il)
     call edges%trns_f_dp%ptr(sz, edgs)
     do jl = 1, sz
        @assertEqual(edgv(jl), edgs(jl))
     end do
     ! inverse
     call edges%trns_inv_f_dp%ptr(sz, edgs)
     do jl = 1, sz
        @assertEqual(edgs(jl), edg_bnd(jl))
     end do
  end do

  ! interior edge test
  do il = 0, edgev%nop()
     ! direct
     edgv(:) = edg_bnd(:)
     edgs(:) = edg_bnd(:)
     call edgev%trns_i_dp(il)%ptr(sz, edgv)
     call edges%init(il)
     call edges%trns_i_dp%ptr(sz, edgs)
     do jl = 1, sz
        @assertEqual(edgv(jl), edgs(jl))
     end do
     ! inverse
     call edges%trns_inv_i_dp%ptr(sz, edgs)
     do jl = 1, sz
        @assertEqual(edgs(jl), edg_bnd(jl))
     end do
  end do

end subroutine test_alignment_edge_op_set_dp
