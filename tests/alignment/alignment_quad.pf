@test
subroutine test_alignment_quad_i4
  use pfunit
  use num_types, only : i4, i8, dp
  use alignment_quad, only : alignment_quad_t
  implicit none
  type(alignment_quad_t) :: quad
  integer(i4), parameter :: sz = 5
  integer(i4), dimension(sz) :: work
  integer(i4), dimension(sz, sz) :: fcs
  integer(i4), dimension(sz, sz, 8) :: fcs_bnd, fcs_int
  integer(i4) :: il, jl, kl

  ! initialise various operations
  ! I - identity
  ! T - transpose
  ! PX - column permutation
  ! PY - row permutation
  ! full face
  ! I
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(il, jl, 1) = il -1 + (jl - 1)*sz
     end do
  end do
  ! T
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(jl, il, 2) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PX
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - il, jl, 3) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PXT
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(jl, sz + 1 - il, 4) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PYT
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - jl, il, 5) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PY
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(il, sz +1 - jl, 6) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PXPYT
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - jl, sz + 1 - il, 7) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PXPY
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - il, sz + 1 - jl, 8) = il -1 + (jl - 1)*sz
     end do
  end do
  ! face interior
  fcs_int(:, :, :) = fcs_bnd(:, :, :)
  do jl = 2, 8
     do il = 1, sz
        fcs_int(il, 1, jl) = fcs_bnd(il, 1, 1)
        fcs_int(il, sz, jl) = fcs_bnd(il, sz, 1)
        fcs_int(1, il, jl) = fcs_bnd(1, il, 1)
        fcs_int(sz, il, jl) = fcs_bnd(sz, il, 1)
     end do
  end do

  ! full face test
  do il = 1, 8
     call quad%set(il - 1)
     ! direct
     fcs(:, :) = fcs_bnd(:, :, 1)
     call quad%trans(.true., fcs, work)
     @assertEqual(quad%algn(), il -1)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_bnd(kl, jl, il))
        end do
     end do
     ! inverse
     call quad%trans_inv(.true., fcs, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_bnd(kl, jl, 1))
        end do
     end do
  end do

  ! interior edge test
  do il = 1, 8
     call quad%set(il - 1)
     ! direct
     fcs(:, :) = fcs_bnd(:, :, 1)
     call quad%trans(.false., fcs, work)
     @assertEqual(quad%algn(), il -1)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_int(kl, jl, il))
        end do
     end do
     ! inverse
     call quad%trans_inv(.false., fcs, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_bnd(kl, jl, 1))
        end do
     end do
  end do

end subroutine test_alignment_quad_i4

@test
subroutine test_alignment_quad_i8
  use pfunit
  use num_types, only : i4, i8, dp
  use alignment_quad, only : alignment_quad_t
  implicit none
  type(alignment_quad_t) :: quad
  integer(i4), parameter :: sz = 5
  integer(i8), dimension(sz) :: work
  integer(i8), dimension(sz, sz) :: fcs
  integer(i8), dimension(sz, sz, 8) :: fcs_bnd, fcs_int
  integer(i4) :: il, jl, kl

  ! initialise various operations
  ! I - identity
  ! T - transpose
  ! PX - column permutation
  ! PY - row permutation
  ! full face
  ! I
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(il, jl, 1) = il -1 + (jl - 1)*sz
     end do
  end do
  ! T
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(jl, il, 2) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PX
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - il, jl, 3) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PXT
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(jl, sz + 1 - il, 4) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PYT
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - jl, il, 5) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PY
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(il, sz +1 - jl, 6) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PXPYT
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - jl, sz + 1 - il, 7) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PXPY
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - il, sz + 1 - jl, 8) = il -1 + (jl - 1)*sz
     end do
  end do
  ! face interior
  fcs_int(:, :, :) = fcs_bnd(:, :, :)
  do jl = 2, 8
     do il = 1, sz
        fcs_int(il, 1, jl) = fcs_bnd(il, 1, 1)
        fcs_int(il, sz, jl) = fcs_bnd(il, sz, 1)
        fcs_int(1, il, jl) = fcs_bnd(1, il, 1)
        fcs_int(sz, il, jl) = fcs_bnd(sz, il, 1)
     end do
  end do

  ! full face test
  do il = 1, 8
     call quad%set(il - 1)
     ! direct
     fcs(:, :) = fcs_bnd(:, :, 1)
     call quad%trans(.true., fcs, work)
     @assertEqual(quad%algn(), il -1)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_bnd(kl, jl, il))
        end do
     end do
     ! inverse
     call quad%trans_inv(.true., fcs, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_bnd(kl, jl, 1))
        end do
     end do
  end do

  ! interior edge test
  do il = 1, 8
     call quad%set(il - 1)
     ! direct
     fcs(:, :) = fcs_bnd(:, :, 1)
     call quad%trans(.false., fcs, work)
     @assertEqual(quad%algn(), il -1)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_int(kl, jl, il))
        end do
     end do
     ! inverse
     call quad%trans_inv(.false., fcs, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_bnd(kl, jl, 1))
        end do
     end do
  end do

end subroutine test_alignment_quad_i8

@test
subroutine test_alignment_quad_dp
  use pfunit
  use num_types, only : i4, i8, dp
  use alignment_quad, only : alignment_quad_t
  implicit none
  type(alignment_quad_t) :: quad
  integer(i4), parameter :: sz = 5
  real(dp), dimension(sz) :: work
  real(dp), dimension(sz, sz) :: fcs
  real(dp), dimension(sz, sz, 8) :: fcs_bnd, fcs_int
  integer(i4) :: il, jl, kl

  ! initialise various operations
  ! I - identity
  ! T - transpose
  ! PX - column permutation
  ! PY - row permutation
  ! full face
  ! I
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(il, jl, 1) = il -1 + (jl - 1)*sz
     end do
  end do
  ! T
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(jl, il, 2) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PX
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - il, jl, 3) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PXT
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(jl, sz + 1 - il, 4) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PYT
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - jl, il, 5) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PY
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(il, sz +1 - jl, 6) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PXPYT
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - jl, sz + 1 - il, 7) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PXPY
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - il, sz + 1 - jl, 8) = il -1 + (jl - 1)*sz
     end do
  end do
  ! face interior
  fcs_int(:, :, :) = fcs_bnd(:, :, :)
  do jl = 2, 8
     do il = 1, sz
        fcs_int(il, 1, jl) = fcs_bnd(il, 1, 1)
        fcs_int(il, sz, jl) = fcs_bnd(il, sz, 1)
        fcs_int(1, il, jl) = fcs_bnd(1, il, 1)
        fcs_int(sz, il, jl) = fcs_bnd(sz, il, 1)
     end do
  end do

  ! full face test
  do il = 1, 8
     call quad%set(il - 1)
     ! direct
     fcs(:, :) = fcs_bnd(:, :, 1)
     call quad%trans(.true., fcs, work)
     @assertEqual(quad%algn(), il -1)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_bnd(kl, jl, il))
        end do
     end do
     ! inverse
     call quad%trans_inv(.true., fcs, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_bnd(kl, jl, 1))
        end do
     end do
  end do

  ! interior edge test
  do il = 1, 8
     call quad%set(il - 1)
     ! direct
     fcs(:, :) = fcs_bnd(:, :, 1)
     call quad%trans(.false., fcs, work)
     @assertEqual(quad%algn(), il -1)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_int(kl, jl, il))
        end do
     end do
     ! inverse
     call quad%trans_inv(.false., fcs, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_bnd(kl, jl, 1))
        end do
     end do
  end do

end subroutine test_alignment_quad_dp
