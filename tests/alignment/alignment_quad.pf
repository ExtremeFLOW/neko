@test
subroutine test_alignment_quad_i4
  use pfunit
  use num_types, only : i4, i8, dp
  use alignment_quad, only : alignment_quad_t
  implicit none
  type(alignment_quad_t) :: quad
  integer(i4), parameter :: sz = 5
  integer(i4), dimension(sz) :: work
  integer(i4), dimension(sz, sz) :: fcs
  integer(i4), dimension(sz, sz, 8) :: fcs_bnd, fcs_int
  integer(i4) :: il, jl, kl

  ! initialise various operations
  ! I - identity
  ! T - transpose
  ! PX - column permutation
  ! PY - row permutation
  ! full face
  ! I
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(il, jl, 1) = il -1 + (jl - 1)*sz
     end do
  end do
  ! T
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(jl, il, 2) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PX
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - il, jl, 3) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PXT
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(jl, sz + 1 - il, 4) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PYT
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - jl, il, 5) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PY
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(il, sz +1 - jl, 6) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PXPYT
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - jl, sz + 1 - il, 7) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PXPY
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - il, sz + 1 - jl, 8) = il -1 + (jl - 1)*sz
     end do
  end do
  ! face interior
  fcs_int(:, :, :) = fcs_bnd(:, :, :)
  do jl = 2, 8
     do il = 1, sz
        fcs_int(il, 1, jl) = fcs_bnd(il, 1, 1)
        fcs_int(il, sz, jl) = fcs_bnd(il, sz, 1)
        fcs_int(1, il, jl) = fcs_bnd(1, il, 1)
        fcs_int(sz, il, jl) = fcs_bnd(sz, il, 1)
     end do
  end do

  call quad%init()

  ! check number of operations
  @assertEqual(quad%nop(), 7)

  ! full face test
  do il = 0, quad%nop()
     ! direct
     fcs(:, :) = fcs_bnd(:, :, 1)
     call quad%trns_f_i4(il)%ptr(sz, fcs, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_bnd(kl, jl, il + 1))
        end do
     end do
     ! inverse
     call quad%trns_inv_f_i4(il)%ptr(sz, fcs, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_bnd(kl, jl, 1))
        end do
     end do
  end do

  ! interior face test
  do il = 0, quad%nop()
     ! direct
     fcs(:, :) = fcs_bnd(:, :, 1)
     call quad%trns_i_i4(il)%ptr(sz, fcs, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_int(kl, jl, il + 1))
        end do
     end do
     ! inverse
     call quad%trns_inv_i_i4(il)%ptr(sz, fcs, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_bnd(kl, jl, 1))
        end do
     end do
  end do

end subroutine test_alignment_quad_i4

@test
subroutine test_alignment_quad_i8
  use pfunit
  use num_types, only : i4, i8, dp
  use alignment_quad, only : alignment_quad_t
  implicit none
  type(alignment_quad_t) :: quad
  integer(i4), parameter :: sz = 5
  integer(i8), dimension(sz) :: work
  integer(i8), dimension(sz, sz) :: fcs
  integer(i8), dimension(sz, sz, 8) :: fcs_bnd, fcs_int
  integer(i4) :: il, jl, kl

  ! initialise various operations
  ! I - identity
  ! T - transpose
  ! PX - column permutation
  ! PY - row permutation
  ! full face
  ! I
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(il, jl, 1) = il -1 + (jl - 1)*sz
     end do
  end do
  ! T
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(jl, il, 2) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PX
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - il, jl, 3) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PXT
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(jl, sz + 1 - il, 4) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PYT
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - jl, il, 5) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PY
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(il, sz +1 - jl, 6) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PXPYT
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - jl, sz + 1 - il, 7) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PXPY
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - il, sz + 1 - jl, 8) = il -1 + (jl - 1)*sz
     end do
  end do
  ! face interior
  fcs_int(:, :, :) = fcs_bnd(:, :, :)
  do jl = 2, 8
     do il = 1, sz
        fcs_int(il, 1, jl) = fcs_bnd(il, 1, 1)
        fcs_int(il, sz, jl) = fcs_bnd(il, sz, 1)
        fcs_int(1, il, jl) = fcs_bnd(1, il, 1)
        fcs_int(sz, il, jl) = fcs_bnd(sz, il, 1)
     end do
  end do

  call quad%init()

  ! check number of operations
  @assertEqual(quad%nop(), 7)

  ! full face test
  do il = 0, quad%nop()
     ! direct
     fcs(:, :) = fcs_bnd(:, :, 1)
     call quad%trns_f_i8(il)%ptr(sz, fcs, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_bnd(kl, jl, il + 1))
        end do
     end do
     ! inverse
     call quad%trns_inv_f_i8(il)%ptr(sz, fcs, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_bnd(kl, jl, 1))
        end do
     end do
  end do

  ! interior face test
  do il = 0, quad%nop()
     ! direct
     fcs(:, :) = fcs_bnd(:, :, 1)
     call quad%trns_i_i8(il)%ptr(sz, fcs, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_int(kl, jl, il + 1))
        end do
     end do
     ! inverse
     call quad%trns_inv_i_i8(il)%ptr(sz, fcs, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_bnd(kl, jl, 1))
        end do
     end do
  end do

end subroutine test_alignment_quad_i8

@test
subroutine test_alignment_quad_dp
  use pfunit
  use num_types, only : i4, i8, dp
  use alignment_quad, only : alignment_quad_t
  implicit none
  type(alignment_quad_t) :: quad
  integer(i4), parameter :: sz = 5
  real(dp), dimension(sz) :: work
  real(dp), dimension(sz, sz) :: fcs
  real(dp), dimension(sz, sz, 8) :: fcs_bnd, fcs_int
  integer(i4) :: il, jl, kl

  ! initialise various operations
  ! I - identity
  ! T - transpose
  ! PX - column permutation
  ! PY - row permutation
  ! full face
  ! I
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(il, jl, 1) = il -1 + (jl - 1)*sz
     end do
  end do
  ! T
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(jl, il, 2) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PX
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - il, jl, 3) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PXT
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(jl, sz + 1 - il, 4) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PYT
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - jl, il, 5) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PY
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(il, sz +1 - jl, 6) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PXPYT
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - jl, sz + 1 - il, 7) = il -1 + (jl - 1)*sz
     end do
  end do
  ! PXPY
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(sz + 1 - il, sz + 1 - jl, 8) = il -1 + (jl - 1)*sz
     end do
  end do
  ! face interior
  fcs_int(:, :, :) = fcs_bnd(:, :, :)
  do jl = 2, 8
     do il = 1, sz
        fcs_int(il, 1, jl) = fcs_bnd(il, 1, 1)
        fcs_int(il, sz, jl) = fcs_bnd(il, sz, 1)
        fcs_int(1, il, jl) = fcs_bnd(1, il, 1)
        fcs_int(sz, il, jl) = fcs_bnd(sz, il, 1)
     end do
  end do

  call quad%init()

  ! check number of operations
  @assertEqual(quad%nop(), 7)

  ! full face test
  do il = 0, quad%nop()
     ! direct
     fcs(:, :) = fcs_bnd(:, :, 1)
     call quad%trns_f_dp(il)%ptr(sz, fcs, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_bnd(kl, jl, il + 1), tolerance=1d-14)
        end do
     end do
     ! inverse
     call quad%trns_inv_f_dp(il)%ptr(sz, fcs, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_bnd(kl, jl, 1), tolerance=1d-14)
        end do
     end do
  end do

  ! interior face test
  do il = 0, quad%nop()
     ! direct
     fcs(:, :) = fcs_bnd(:, :, 1)
     call quad%trns_i_dp(il)%ptr(sz, fcs, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_int(kl, jl, il + 1), tolerance=1d-14)
        end do
     end do
     ! inverse
     call quad%trns_inv_i_dp(il)%ptr(sz, fcs, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcs(kl, jl), fcs_bnd(kl, jl, 1), tolerance=1d-14)
        end do
     end do
  end do

end subroutine test_alignment_quad_dp

@test
subroutine test_alignment_quad_op_set_i4
  use pfunit
  use num_types, only : i4, i8, dp
  use alignment_quad, only : alignment_quad_t, alignment_quad_op_set_t
  implicit none
  type(alignment_quad_t) :: quadv
  type(alignment_quad_op_set_t) :: quads
  integer(i4), parameter :: sz = 5
  integer(i4), dimension(sz) :: work
  integer(i4), dimension(sz, sz) :: fcsv, fcss
  integer(i4), dimension(sz, sz) :: fcs_bnd
  integer(i4) :: il, jl, kl

  ! initial condition
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(il, jl) = il -1 + (jl - 1)*sz
     end do
  end do

  call quadv%init()

  ! full face test
  do il = 0, quadv%nop()
     ! direct
     fcsv(:, :) = fcs_bnd(:, :)
     fcss(:, :) = fcs_bnd(:, :)
     call quadv%trns_f_i4(il)%ptr(sz, fcsv, work)
     call quads%init(il)
     call quads%trns_f_i4%ptr(sz, fcss, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcsv(kl, jl), fcss(kl, jl))
        end do
     end do
     ! inverse
     call quads%trns_inv_f_i4%ptr(sz, fcss, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcss(kl, jl), fcs_bnd(kl, jl))
        end do
     end do
  end do

  ! interior face test
  do il = 0, quadv%nop()
     ! direct
     fcsv(:, :) = fcs_bnd(:, :)
     fcss(:, :) = fcs_bnd(:, :)
     call quadv%trns_i_i4(il)%ptr(sz, fcsv, work)
     call quads%init(il)
     call quads%trns_i_i4%ptr(sz, fcss, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcsv(kl, jl), fcss(kl, jl))
        end do
     end do
     ! inverse
     call quads%trns_inv_i_i4%ptr(sz, fcss, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcss(kl, jl), fcs_bnd(kl, jl))
        end do
     end do
  end do
end subroutine test_alignment_quad_op_set_i4

@test
subroutine test_alignment_quad_op_set_i8
  use pfunit
  use num_types, only : i4, i8, dp
  use alignment_quad, only : alignment_quad_t, alignment_quad_op_set_t
  implicit none
  type(alignment_quad_t) :: quadv
  type(alignment_quad_op_set_t) :: quads
  integer(i4), parameter :: sz = 5
  integer(i8), dimension(sz) :: work
  integer(i8), dimension(sz, sz) :: fcsv, fcss
  integer(i8), dimension(sz, sz) :: fcs_bnd
  integer(i4) :: il, jl, kl

  ! initial condition
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(il, jl) = il -1 + (jl - 1)*sz
     end do
  end do

  call quadv%init()

  ! full face test
  do il = 0, quadv%nop()
     ! direct
     fcsv(:, :) = fcs_bnd(:, :)
     fcss(:, :) = fcs_bnd(:, :)
     call quadv%trns_f_i8(il)%ptr(sz, fcsv, work)
     call quads%init(il)
     call quads%trns_f_i8%ptr(sz, fcss, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcsv(kl, jl), fcss(kl, jl))
        end do
     end do
     ! inverse
     call quads%trns_inv_f_i8%ptr(sz, fcss, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcss(kl, jl), fcs_bnd(kl, jl))
        end do
     end do
  end do

  ! interior face test
  do il = 0, quadv%nop()
     ! direct
     fcsv(:, :) = fcs_bnd(:, :)
     fcss(:, :) = fcs_bnd(:, :)
     call quadv%trns_i_i8(il)%ptr(sz, fcsv, work)
     call quads%init(il)
     call quads%trns_i_i8%ptr(sz, fcss, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcsv(kl, jl), fcss(kl, jl))
        end do
     end do
     ! inverse
     call quads%trns_inv_i_i8%ptr(sz, fcss, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcss(kl, jl), fcs_bnd(kl, jl))
        end do
     end do
  end do
end subroutine test_alignment_quad_op_set_i8

@test
subroutine test_alignment_quad_op_set_dp
  use pfunit
  use num_types, only : i4, i8, dp
  use alignment_quad, only : alignment_quad_t, alignment_quad_op_set_t
  implicit none
  type(alignment_quad_t) :: quadv
  type(alignment_quad_op_set_t) :: quads
  integer(i4), parameter :: sz = 5
  real(dp), dimension(sz) :: work
  real(dp), dimension(sz, sz) :: fcsv, fcss
  real(dp), dimension(sz, sz) :: fcs_bnd
  integer(i4) :: il, jl, kl

  ! initial condition
  do jl = 1, sz
     do il = 1, sz
        fcs_bnd(il, jl) = il -1 + (jl - 1)*sz
     end do
  end do

  call quadv%init()

  ! full face test
  do il = 0, quadv%nop()
     ! direct
     fcsv(:, :) = fcs_bnd(:, :)
     fcss(:, :) = fcs_bnd(:, :)
     call quadv%trns_f_dp(il)%ptr(sz, fcsv, work)
     call quads%init(il)
     call quads%trns_f_dp%ptr(sz, fcss, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcsv(kl, jl), fcss(kl, jl))
        end do
     end do
     ! inverse
     call quads%trns_inv_f_dp%ptr(sz, fcss, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcss(kl, jl), fcs_bnd(kl, jl))
        end do
     end do
  end do

  ! interior face test
  do il = 0, quadv%nop()
     ! direct
     fcsv(:, :) = fcs_bnd(:, :)
     fcss(:, :) = fcs_bnd(:, :)
     call quadv%trns_i_dp(il)%ptr(sz, fcsv, work)
     call quads%init(il)
     call quads%trns_i_dp%ptr(sz, fcss, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcsv(kl, jl), fcss(kl, jl))
        end do
     end do
     ! inverse
     call quads%trns_inv_i_dp%ptr(sz, fcss, work)
     do jl = 1, sz
        do kl = 1, sz
           @assertEqual(fcss(kl, jl), fcs_bnd(kl, jl))
        end do
     end do
  end do
end subroutine test_alignment_quad_op_set_dp
