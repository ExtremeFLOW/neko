module distance
  use pfunit
  use num_types
  use geometric_operators
  use point
  use tri
  use tet
  implicit none

contains

  @test
  subroutine test_distance_point_real
    real(kind=rp), dimension(3) :: p, point
    real(kind=rp) :: distance

    p = [1.0_rp, 2.0_rp, 3.0_rp]
    point = [4.0_rp, 5.0_rp, 6.0_rp]
    distance = distance_point_real(p, point)
    @assertEqual(sqrt(27.0_rp), distance)

  end subroutine test_distance_point_real

  @test
  subroutine test_distance_line
    real(kind=rp), dimension(3) :: p, point, direction
    real(kind=rp) :: distance

    p = [1.0_rp, 2.0_rp, 3.0_rp]
    point = [4.0_rp, 5.0_rp, 6.0_rp]
    direction = [1.0_rp, 1.0_rp, 1.0_rp]
    distance = distance_line(p, point, direction)
    @assertEqual(sqrt(3.0_rp), distance)

  end subroutine test_distance_line

  @test
  subroutine test_distance_line_ray
    real(kind=rp), dimension(3) :: p, point, direction
    real(kind=rp) :: distance

    p = [1.0_rp, 2.0_rp, 3.0_rp]
    point = [4.0_rp, 5.0_rp, 6.0_rp]
    direction = [1.0_rp, 1.0_rp, 1.0_rp]
    distance = distance_line_ray(p, point, direction)
    @assertEqual(sqrt(3.0_rp), distance)

  end subroutine test_distance_line_ray

  @test
  subroutine test_distance_line_segment
    real(kind=rp), dimension(3) :: p, point_0, point_1
    real(kind=rp) :: distance

    p = [1.0_rp, 2.0_rp, 3.0_rp]
    point_0 = [4.0_rp, 5.0_rp, 6.0_rp]
    point_1 = [7.0_rp, 8.0_rp, 9.0_rp]
    distance = distance_line_segment(p, point_0, point_1)
    @assertEqual(sqrt(27.0_rp), distance)

  end subroutine test_distance_line_segment

  @test
  subroutine test_distance_plane
    real(kind=rp), dimension(3) :: p, point, normal
    real(kind=rp) :: distance

    p = [1.0_rp, 2.0_rp, 3.0_rp]
    point = [4.0_rp, 5.0_rp, 6.0_rp]
    normal = [1.0_rp, 1.0_rp, 1.0_rp]
    distance = distance_plane(p, point, normal)
    @assertEqual(sqrt(3.0_rp), distance)

  end subroutine test_distance_plane

  @test
  subroutine test_distance_sphere
    real(kind=rp), dimension(3) :: p, sphere_center
    real(kind=rp) :: sphere_radius, distance

    p = [1.0_rp, 2.0_rp, 3.0_rp]
    sphere_center = [4.0_rp, 5.0_rp, 6.0_rp]
    sphere_radius = 1.0_rp
    distance = distance_sphere(p, sphere_center, sphere_radius)
    @assertEqual(sqrt(27.0_rp) - 1.0_rp, distance)

  end subroutine test_distance_sphere

  @test
  subroutine test_distance_point_t
    type(point_t) :: p, point
    real(kind=rp) :: distance

    p = point_t(1.0_rp, 2.0_rp, 3.0_rp)
    point = point_t(4.0_rp, 5.0_rp, 6.0_rp)
    distance = distance_point_t(p, point)
    @assertEqual(sqrt(27.0_rp), distance)

  end subroutine test_distance_point_t

  @test
  subroutine test_distance_triangle
    real(kind=rp), dimension(3) :: p
    type(tri_t) :: triangle
    real(kind=rp) :: distance_1, distance_2

    real(kind=rp), dimension(3) :: point_0, point_1, point_2

    p = [1.0_rp, 2.0_rp, 3.0_rp]
    point_0 = [4.0_rp, 5.0_rp, 6.0_rp]
    point_1 = [7.0_rp, 8.0_rp, 9.0_rp]
    point_2 = [10.0_rp, 11.0_rp, 12.0_rp]
    call triangle%init(0, point_0, point_1, point_2)

    distance_1 = distance_triangle(p, triangle)
    distance_2 = distance_element(p, triangle)
    @assertEqual(sqrt(27.0_rp), distance_1)
    @assertEqual(sqrt(27.0_rp), distance_2)

  end subroutine test_distance_triangle

  @test
  subroutine test_distance_tetrahedron
    real(kind=rp), dimension(3) :: p
    type(tet_t) :: tetrahedron
    real(kind=rp) :: distance_1, distance_2

    real(kind=rp), dimension(3) :: point_0, point_1, point_2, point_3

    p = [1.0_rp, 2.0_rp, 3.0_rp]
    point_0 = [4.0_rp, 5.0_rp, 6.0_rp]
    point_1 = [7.0_rp, 8.0_rp, 9.0_rp]
    point_2 = [10.0_rp, 11.0_rp, 12.0_rp]
    point_3 = [13.0_rp, 14.0_rp, 15.0_rp]
    call tetrahedron%init(0, point_0, point_1, point_2, point_3)

    distance_1 = distance_tetrahedron(p, tetrahedron)
    distance_2 = distance_element(p, tetrahedron)
    @assertEqual(sqrt(27.0_rp), distance_1)
    @assertEqual(sqrt(27.0_rp), distance_2)

    @assertEqual(1, 0)

  end subroutine test_distance_tetrahedron

end module distance
