@test
subroutine test_hex_mesh_simple
  use pfunit
  use num_types, only : i4, dp
  use polytope, only : polytope_t
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t, edge_ornt_t, NEKO_EDGE_NFACET
  use quad_new, only : quad_tpl_t, NEKO_QUAD_NFACET
  use hex_new, only : hex_elm_t, NEKO_HEX_NFACET
  use point, only : point_ptr, point_t
  implicit none
  class(polytope_t), pointer :: poly
  type(vertex_tpl_t), dimension(8) :: vrt
  type(edge_tpl_t), dimension(12) :: edt
  type(quad_tpl_t), dimension(6) :: qut
  type(hex_elm_t) :: hxm1
  type(topology_component_t), dimension(0) :: fctv
  integer(i4), dimension(8) :: idv, gsv, idp
  integer(i4), dimension(12) :: ide, gse
  integer(i4), dimension(6) :: idq, gsq, bnq
  integer(i4) :: il, jl, idh1
  integer(i4), dimension(8) :: permv
  integer(i4), dimension(12) :: perme
  integer(i4), dimension(6) :: permq
  type(point_t), dimension(8), target :: pts
  type(point_t), pointer :: point
  type(point_ptr), dimension(8) :: ptsp
  type(point_t) :: centroid
  integer(i4), parameter :: gdim = 3
  ! point coordinates
  real(dp), dimension(gdim, 8) :: crd = reshape((/ 0.0d0, 0.0d0, 0.0d0, &
       &  1.0d0, 0.0d0, 0.0d0,  0.0d0, 1.0d0, 0.0d0,  1.0d0, 1.0d0, 0.0d0, &
       &  0.0d0, 0.0d0, 1.0d0,  1.0d0, 0.0d0, 1.0d0,  0.0d0, 1.0d0, 1.0d0, &
       &  1.0d0, 1.0d0, 1.0d0 /), shape(crd))
  real(kind=dp), parameter :: diameter = 1.7320508075688772d0, tol = 1.0d-14
  real(kind=dp), dimension(3), parameter :: center = (/0.5d0, 0.5d0, 0.5d0/)

  do il = 1, 8
     idv(il) = il
     gsv(il) = il + 8
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  do il = 1, 8
     idp(il) = il + 20
     pts(il) = point_t(crd(1: 3, il), idp(il))
  end do

  ! Single self-periodic, not hanging hex
  call hex_permutations(0, permv, perme, permq)
  do il = 1, 8
     ptsp(il)%p => pts(il)
  end do
  idh1 = 1
  call hex_algn_msh_get(permv, perme, permq, vrt, ptsp, 0, idh1, gdim, &
       & edt, ide, gse, qut, idq, gsq, bnq, hxm1)

  ! hex dimensions
  @assertEqual(hxm1%id(), idh1)
  @assertEqual(hxm1%tdim(), 3)
  @assertTrue(hxm1%check_comp(6, 12, 8))

  ! pointers
  ! facets
  do il = 1, 6
     poly => hxm1%fct(il)
     @assertTrue(associated(poly))
     @assertEqual(poly%id(), idq(il))
     @assertEqual(poly%tdim(), 2)
     @assertTrue(poly%check_comp(4, 4, 0))
     @assertEqual(poly%bnd(), bnq(il))
     @assertEqual(poly%gsid(), gsq(il))
     @assertTrue(poly%equal(qut(il)))
  end do
  ! ridges
  do il = 1, 12
     poly => hxm1%rdg(il)
     @assertTrue(associated(poly))
     @assertEqual(poly%id(), ide(il))
     @assertEqual(poly%tdim(), 1)
     @assertTrue(poly%check_comp(2, 0, 0))
     @assertEqual(poly%bnd(), -1)
     @assertEqual(poly%gsid(), gse(il))
     @assertTrue(poly%equal(edt(il)))
  end do
  !peaks
  do il = 1, 8
     poly => hxm1%pek(il)
     @assertTrue(associated(poly))
     @assertEqual(poly%id(), idv(il))
     @assertEqual(poly%tdim(), 0)
     @assertTrue(poly%check_comp(0, 0, 0))
     @assertEqual(poly%bnd(), -1)
     @assertEqual(poly%gsid(), gsv(il))
     @assertTrue(poly%equal(vrt(il)))
  end do
  ! points
  @assertEqual(hxm1%gdim(), gdim)
  @assertEqual(hxm1%npts(), 8)
  do il = 1, 8
     point => hxm1%pnt(il)
     @assertTrue(point .eq. pts(il))
  end do

  ! self-periodic flag
  @assertFalse(hxm1%self_periodic())

  ! facet boundary flag
  do il = 1, 6
     @assertEqual(hxm1%fct_bnd(il), bnq(il))
  end do

  ! facet gather-scatter id
  do il = 1, 6
     @assertEqual(hxm1%fct_gsid(il), gsq(il))
  end do

  ! ridge gather-scatter id
  do il = 1, 12
     @assertEqual(hxm1%rdg_gsid(il), gse(il))
  end do

  ! peak gather-scatter id
  do il = 1, 8
     @assertEqual(hxm1%pek_gsid(il), gsv(il))
  end do

  ! facet alignment
  do il = 1, 6
     @assertEqual(hxm1%falgn(il), 0)
  end do

  ! quad diameter
  @assertEqual(hxm1%diameter(), diameter, tolerance = tol)

  ! quad centre
  centroid = hxm1%centroid()
  do il = 1, gdim
     @assertEqual(centroid%x(il), center(il), tolerance = tol)
  end do

  ! get facet local direction
  call hxm1%fct_dir(1, il, jl)
  @assertEqual(il, 3)
  @assertEqual(jl, 2)
  call hxm1%fct_dir(2, il, jl)
  @assertEqual(il, 3)
  @assertEqual(jl, 2)
  call hxm1%fct_dir(3, il, jl)
  @assertEqual(il, 3)
  @assertEqual(jl, 1)
  call hxm1%fct_dir(4, il, jl)
  @assertEqual(il, 3)
  @assertEqual(jl, 1)
  call hxm1%fct_dir(5, il, jl)
  @assertEqual(il, 2)
  @assertEqual(jl, 1)
  call hxm1%fct_dir(6, il, jl)
  @assertEqual(il, 2)
  @assertEqual(jl, 1)

  ! get ridge local direction
  do il = 1, 12
     call hxm1%rdg_dir(il, jl)
     @assertEqual(jl, (il - 1) / 4 + 1)
  end do

  do il =1, 8
     call vrt(il)%free()
  end do
  do il =1, 12
     call edt(il)%free()
  end do
  do il =1, 6
     call qut(il)%free()
  end do
  call hxm1%free()

end subroutine test_hex_mesh_simple

@test
subroutine test_hex_elm_add_simple
  use pfunit
  use num_types, only : i4, dp
  use polytope, only : polytope_t
  use topology, only : topology_element_t
  use element_new, only : mesh_element_t
  use vertex, only : vertex_tpl_add
  use edge, only : edge_tpl_add
  use quad_new, only : quad_tpl_add
  use hex_new, only : rdg_to_pek, fct_to_rdg, hex_elm_add
  use point, only : point_t
  implicit none
  type(topology_element_t), dimension(8) :: vrt
  type(topology_element_t), dimension(12) :: edg
  type(topology_element_t), dimension(6) :: qad
  type(mesh_element_t) :: hex
  integer(i4) :: id, bne, il
  integer(i4), dimension(8) :: idp, idv
  integer(i4), dimension(12) :: ide
  integer(i4), dimension(6) :: idq, bnq
  integer(i4), dimension(2, 3) :: rdg_hng
  integer(i4), parameter :: gdim = 3
  ! point coordinates
  real(dp), dimension(gdim, 8) :: crd = reshape((/ 0.0d0, 0.0d0, 0.0d0, &
       &  1.0d0, 0.0d0, 0.0d0,  0.0d0, 1.0d0, 0.0d0,  1.0d0, 1.0d0, 0.0d0, &
       &  0.0d0, 0.0d0, 1.0d0,  1.0d0, 0.0d0, 1.0d0,  0.0d0, 1.0d0, 1.0d0, &
       &  1.0d0, 1.0d0, 1.0d0 /), shape(crd))
  type(point_t), dimension(8) :: pts
  class(polytope_t), pointer :: poly
  type(point_t), pointer :: point

  ! points
  do il = 1, 8
     idp(il) = il + 20
     pts(il) = point_t(crd(1: 3, il), idp(il))
  end do
  ! vertices
  do il = 1, 8
     idv(il) = il
     call vertex_tpl_add(vrt(il)%obj, idv(il))
  end do
  ! edges
  bne = -1
  do il = 1, 12
     ide(il) = il
     call edge_tpl_add(edg(il)%obj, ide(il), bne, vrt(rdg_to_pek(1, il))%obj, &
          & vrt(rdg_to_pek(2, il))%obj)
  end do
  ! quads
  do il = 1, 6
     idq(il) = il
     bnq(il) = 10 + il
     call quad_tpl_add(qad(il)%obj, idq(il), bnq(il), &
          & edg(fct_to_rdg(1, il))%obj, edg(fct_to_rdg(2, il))%obj, &
          & edg(fct_to_rdg(3, il))%obj, edg(fct_to_rdg(4, il))%obj, 0, 0, 0, 0)
  end do

  id = 100
  call hex_elm_add(hex%obj, id, &
       & qad(1)%obj, qad(2)%obj, qad(3)%obj, qad(4)%obj, qad(5)%obj, &
       & qad(6)%obj, 0, 0, 0, 0, 0, 0, .false., &
       & .false., .false., .false., .false., .false., 0, 0, 0, 0, 0, 0, &
       & 0, rdg_hng, &
       & gdim, pts(1), pts(2), pts(3), pts(4), pts(5), pts(6), pts(7), pts(8))

  ! hex dimensions
  @assertEqual(hex%obj%id(), id)
  @assertEqual(hex%obj%tdim(), 3)
  @assertTrue(hex%obj%check_comp(6, 12, 8))

  ! pointers
  ! facets
  do il = 1, 6
     poly => hex%obj%fct(il)
     @assertTrue(associated(poly))
     @assertEqual(poly%id(), idq(il))
     @assertEqual(poly%tdim(), 2)
     @assertTrue(poly%check_comp(4, 4, 0))
     @assertEqual(poly%bnd(), bnq(il))
     @assertTrue(poly%equal(qad(il)%obj))
  end do
  ! ridges
  do il = 1, 12
     poly => hex%obj%rdg(il)
     @assertTrue(associated(poly))
     @assertEqual(poly%id(), ide(il))
     @assertEqual(poly%tdim(), 1)
     @assertTrue(poly%check_comp(2, 0, 0))
     @assertEqual(poly%bnd(), -1)
     @assertTrue(poly%equal(edg(il)%obj))
  end do
  !peaks
  do il = 1, 8
     poly => hex%obj%pek(il)
     @assertTrue(associated(poly))
     @assertEqual(poly%id(), idv(il))
     @assertEqual(poly%tdim(), 0)
     @assertTrue(poly%check_comp(0, 0, 0))
     @assertEqual(poly%bnd(), -1)
     @assertTrue(poly%equal(vrt(il)%obj))
  end do
  ! points
  @assertEqual(hex%obj%gdim(), gdim)
  @assertEqual(hex%obj%npts(), 8)
  do il = 1, 8
     point => hex%obj%pnt(il)
     @assertTrue(point .eq. pts(il))
  end do

end subroutine test_hex_elm_add_simple


@test
subroutine test_hex_mesh_permute
  use pfunit
  use num_types, only : i4, dp
  use polytope, only : polytope_t
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t, edge_ornt_t, NEKO_EDGE_NFACET
  use quad_new, only : quad_tpl_t, NEKO_QUAD_NFACET
  use hex_new, only : hex_elm_t, NEKO_HEX_NFACET
  use point, only : point_ptr, point_t
  implicit none
  class(polytope_t), pointer :: poly
  type(vertex_tpl_t), dimension(8) :: vrt
  type(edge_tpl_t), dimension(24) :: edt
  type(quad_tpl_t), dimension(12) :: qut
  type(hex_elm_t) :: hxm1, hxm2
  type(topology_component_t), dimension(0) :: fctv
  integer(i4), dimension(8) :: idv, gsv, idp
  integer(i4), dimension(24) :: ide, gse
  integer(i4), dimension(12) :: idq, gsq, bnq
  integer(i4) :: il, jl, itmp, idh1
  integer(i4), dimension(8) :: permv
  integer(i4), dimension(12) :: perme
  integer(i4), dimension(6) :: permq
  type(point_t), dimension(8), target :: pts
  type(point_ptr), dimension(8) :: ptsp
  integer(i4), parameter :: gdim = 3
  ! point coordinates
  real(dp), dimension(gdim, 8) :: crd = reshape((/ 0.0d0, 0.0d0, 0.0d0, &
       &  1.0d0, 0.0d0, 0.0d0,  0.0d0, 1.0d0, 0.0d0,  1.0d0, 1.0d0, 0.0d0, &
       &  0.0d0, 0.0d0, 1.0d0,  1.0d0, 0.0d0, 1.0d0,  0.0d0, 1.0d0, 1.0d0, &
       &  1.0d0, 1.0d0, 1.0d0 /), shape(crd))
  integer(i4), dimension(:, :), allocatable :: facetp
  logical :: equal

  do il = 1, 8
     idv(il) = il
     gsv(il) = il + 8
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  do il = 1, 8
     idp(il) = il + 20
     pts(il) = point_t(crd(1: 3, il), idp(il))
  end do

  ! Single self-periodic, not hanging hex
  call hex_permutations(0, permv, perme, permq)
  do il = 1, 8
     ptsp(il)%p => pts(il)
  end do
  idh1 = 1
  call hex_algn_msh_get(permv, perme, permq, vrt, ptsp, 0, idh1, gdim, &
       & edt(1: 12), ide(1: 12), gse(1: 12), qut(1: 6), idq(1: 6), &
       & gsq(1: 6), bnq(1: 6), hxm1)

  ! equality with respect to various alignment
  do il = 0, 7
     call hex_permutations(il, permv, perme, permq)
     call hex_algn_msh_get(permv, perme, permq, vrt, ptsp, 0, idh1, gdim, &
       & edt(13: 24), ide(13: 24), gse(13: 24), qut(7: 12), idq(7: 12), &
       & gsq(7: 12), bnq(7: 12), hxm2)
     call hex_permutations_inv(il, permv, perme, permq)

     ! hex equality test
     @assertTrue(hxm1%equal(hxm2))

     ! share tests
     call hxm1%fct_share(hxm2, itmp, facetp)
     @assertEqual(itmp, 6)
     do jl = 1, itmp
        @assertEqual(facetp(1, jl), jl)
        @assertEqual(facetp(2, jl), permq(jl))
     end do
     deallocate(facetp)

     call hxm1%rdg_share(hxm2, itmp, facetp)
     @assertEqual(itmp, 12)
     do jl = 1, itmp
        @assertEqual(facetp(1, jl), jl)
        @assertEqual(facetp(2, jl), perme(jl))
     end do
     deallocate(facetp)

     call hxm1%pek_share(hxm2, itmp, facetp)
     @assertEqual(itmp, 8)
     do jl = 1, itmp
        @assertEqual(facetp(1, jl), jl)
        @assertEqual(facetp(2, jl), permv(jl))
     end do
     deallocate(facetp)

     ! facet alignment test
     ! We compare facet 3 of hxm1 with corresponding facet of hxm2
     poly => hxm2%fct(permq(3))
     call hxm1%facet(3)%obj%equal_algn(poly, equal, itmp)
     @assertTrue(equal)
     @assertEqual(itmp, il)

  end do

  do il =1, 8
     call vrt(il)%free()
  end do
  do il =1, 24
     call edt(il)%free()
  end do
  do il =1, 12
     call qut(il)%free()
  end do
  call hxm1%free()
  call hxm2%free()

end subroutine test_hex_mesh_permute




! MISSING TESTS FOR NONCONFORMING VERSION



! We consider just some of the hex transformations. Focusing on
! facet 3 of the non-transformed hex we aim at reproducing all 8
! possible transformations of facet quad.
subroutine hex_permutations(algn, permv, perme, permq)
  use num_types, only : i4
  implicit none
  integer(i4), intent(in) :: algn
  integer(i4), dimension(8), intent(out) :: permv
  integer(i4), dimension(12), intent(out) :: perme
  integer(i4), dimension(6), intent(out) :: permq

  select case(algn)
  case(0) ! I
     permv = (/ 1, 2, 3, 4, 5, 6, 7, 8 /)
     perme = (/ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 /)
     permq = (/ 1, 2, 3, 4, 5, 6 /)
  case(1) ! T
     permv = (/ 1, 5, 2, 6, 3, 7, 4, 8 /)
     perme = (/ 9, 10, 11, 12, 1, 3, 2, 4, 5, 7, 6, 8 /)
     permq = (/ 5, 6, 1, 2, 3, 4 /)
  case(2) ! PX
     permv = (/ 2, 4, 1, 3, 6, 8, 5, 7 /)
     perme = (/ 6, 5, 8, 7, 1, 2, 3, 4, 10, 12, 9, 11 /)
     permq = (/ 3, 4, 2, 1, 5, 6 /)
  case(3) ! PXT
     permv = (/ 2, 6, 4, 8, 1, 5, 3, 7 /)
     perme = (/ 10, 12, 9, 11, 6, 8, 5, 7, 1, 3, 2, 4 /)
     permq = (/ 5, 6, 3, 4, 2, 1 /)
  case(4) ! PYT
     permv = (/ 5, 1, 7, 3, 6, 2, 8, 4 /)
     perme = (/ 9, 11, 10, 12, 7, 5, 8, 6, 3, 1, 4, 2 /)
     permq = (/ 6, 5, 3, 4, 1, 2 /)
  case(5) ! PY
     permv = (/ 5, 6, 1, 2, 7, 8, 3, 4 /)
     perme = (/ 3, 1, 4, 2, 9, 10, 11, 12, 7, 8, 5, 6 /)
     permq = (/ 1, 2, 6, 5, 3, 4 /)
  case(6) ! PXPYT
     permv = (/ 6, 2, 5, 1, 8, 4, 7, 3 /)
     perme = (/ 10, 9, 12, 11, 3, 1, 4, 2, 8, 6, 7, 5 /)
     permq = (/ 6, 5, 2, 1, 3, 4 /)
  case(7) ! PXPY
     permv = (/ 6, 5, 8, 7, 2, 1, 4, 3 /)
     perme = (/ 3, 4, 1, 2, 8, 7, 6, 5, 10, 9, 12, 11 /)
     permq = (/ 2, 1, 3, 4, 6, 5 /)
  end select

end subroutine hex_permutations

! We consider just some of the hex transformations. Focusing on
! facet 3 of the non-transformed hex we aim at reproducing all 8
! possible transformations of facet quad.
subroutine hex_permutations_inv(algn, permv, perme, permq)
  use num_types, only : i4
  implicit none
  integer(i4), intent(in) :: algn
  integer(i4), dimension(8), intent(out) :: permv
  integer(i4), dimension(12), intent(out) :: perme
  integer(i4), dimension(6), intent(out) :: permq

  select case(algn)
  case(0) ! I
     permv = (/ 1, 2, 3, 4, 5, 6, 7, 8 /)
     perme = (/ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 /)
     permq = (/ 1, 2, 3, 4, 5, 6 /)
  case(1) ! T
     permv = (/ 1, 3, 5, 7, 2, 4, 6, 8 /)
     perme = (/ 5, 7, 6, 8, 9, 11, 10, 12, 1, 2, 3, 4 /)
     permq = (/ 3, 4, 5, 6, 1, 2 /)
  case(2) ! PX
     permv = (/ 3, 1, 4, 2, 7, 5, 8, 6 /)
     perme = (/ 5, 6, 7, 8, 2, 1, 4, 3, 11, 9, 12, 10 /)
     permq = (/ 4, 3, 1, 2, 5, 6 /)
  case(3) ! PXT
     permv = (/ 5, 1, 7, 3, 6, 2, 8, 4 /)
     perme = (/ 9, 11, 10, 12, 7, 5, 8, 6, 3, 1, 4, 2 /)
     permq = (/ 6, 5, 3, 4, 1, 2 /)
  case(4) ! PYT
     permv = (/ 2, 6, 4, 8, 1, 5, 3, 7 /)
     perme = (/ 10, 12, 9, 11, 6, 8, 5, 7, 1, 3, 2, 4 /)
     permq = (/ 5, 6, 3, 4, 2, 1 /)
  case(5) ! PY
     permv = (/ 3, 4, 7, 8, 1, 2, 5, 6 /)
     perme = (/ 2, 4, 1, 3, 11, 12, 9, 10, 5, 6, 7, 8 /)
     permq = (/ 1, 2, 5, 6, 4, 3 /)
  case(6) ! PXPYT
     permv = (/ 4, 2, 8, 6, 3, 1, 7, 5 /)
     perme = (/ 6, 8, 5, 7, 12, 10, 11, 9, 2, 1, 4, 3 /)
     permq = (/ 4, 3, 5, 6, 2, 1 /)
  case(7) ! PXPY
     permv = (/ 6, 5, 8, 7, 2, 1, 4, 3 /)
     perme = (/ 3, 4, 1, 2, 8, 7, 6, 5, 10, 9, 12, 11 /)
     permq = (/ 2, 1, 3, 4, 6, 5 /)
  end select

end subroutine hex_permutations_inv

subroutine hex_algn_msh_get(permv, perme, permq, vrt, pts, istr, idh, gdim, &
     & edt, ide, gse, qut, idq, gsq, bnq, hxm)
  use num_types, only : i4
  use topology, only : topology_component_t
  use element_new, only : element_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t, edge_ornt_t, NEKO_EDGE_NFACET
  use quad_new, only : quad_tpl_t, quad_act_t, NEKO_QUAD_NFACET
  use hex_new, only : hex_elm_t, NEKO_HEX_NFACET, NEKO_HEX_NRIDGE, &
       & NEKO_HEX_NPEAK, fct_to_rdg, rdg_to_pek
  use point, only : point_ptr
  implicit none
  integer(i4), dimension(8), intent(in) :: permv
  integer(i4), dimension(12), intent(in) :: perme
  integer(i4), dimension(6), intent(in) :: permq
  type(vertex_tpl_t), dimension(8), intent(in) :: vrt
  type(point_ptr), dimension(8), intent(in) :: pts
  integer(i4), intent(in) :: istr, idh, gdim
  type(edge_tpl_t), dimension(12), intent(out) :: edt
  integer(i4), dimension(12), intent(out) :: ide, gse
  type(quad_tpl_t), dimension(6), intent(out) :: qut
  integer(i4), dimension(6), intent(out) :: idq, gsq, bnq
  type(hex_elm_t), intent(out) :: hxm
  type(topology_component_t), dimension(NEKO_EDGE_NFACET) :: fcte
  type(topology_component_t), dimension(NEKO_QUAD_NFACET) :: fctq
  type(element_component_t), dimension(NEKO_HEX_NFACET) :: fcth
  type(point_ptr), dimension(NEKO_HEX_NPEAK) :: ptsl
  integer(i4) :: il, bne, algn, hng
  logical :: ifintp
  integer(i4), dimension(2, 3) :: rdg_hng

  do il = 1, NEKO_HEX_NRIDGE
     ide(il) = istr + il
     gse(il) = istr + il + 24
  end do
  bne = -1
  do il = 1, NEKO_HEX_NRIDGE
     allocate(vertex_ornt_t :: fcte(1)%obj)
     call fcte(1)%obj%init(vrt(permv(rdg_to_pek(1, il))), -1)
     allocate(vertex_ornt_t :: fcte(2)%obj)
     call fcte(2)%obj%init(vrt(permv(rdg_to_pek(2, il))), -1)
     call edt(il)%init(ide(perme(il)), 2, fcte, bne)
     call edt(il)%set_gsid(gse(perme(il)))
  end do

  do il = 1, NEKO_HEX_NFACET
     idq(il) = istr + il
     gsq(il) = istr + il + 12
     bnq(il) = 1
  end do
  ! simple edge alignment
  algn = 0
  do il = 1, NEKO_HEX_NFACET
     allocate(edge_ornt_t :: fctq(1)%obj)
     call fctq(1)%obj%init(edt(fct_to_rdg(1, il)), algn)
     allocate(edge_ornt_t :: fctq(2)%obj)
     call fctq(2)%obj%init(edt(fct_to_rdg(2, il)), algn)
     allocate(edge_ornt_t :: fctq(3)%obj)
     call fctq(3)%obj%init(edt(fct_to_rdg(3, il)), algn)
     allocate(edge_ornt_t :: fctq(4)%obj)
     call fctq(4)%obj%init(edt(fct_to_rdg(4, il)), algn)
     call qut(il)%init(idq(permq(il)), 4, fctq, bnq(il))
     call qut(il)%set_gsid(gsq(permq(il)))
  end do

  do il = 1, NEKO_HEX_NPEAK
     ptsl(il)%p => pts(permv(il))%p
  end do

  ! non self-periodic hex
  ! simple quad alignment
  algn = 0
  ifintp = .false.
  hng = 0
  do il = 1, NEKO_HEX_NFACET
     allocate(quad_act_t :: fcth(il)%obj)
     call fcth(il)%obj%init(qut(il), algn, ifintp, hng, il)
  end do
  call hxm%init(idh, 6, fcth, 8, ptsl, gdim, 0, rdg_hng)

end subroutine hex_algn_msh_get
