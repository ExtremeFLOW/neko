@test
subroutine test_hex_mesh_simple
  use pfunit
  use num_types, only : i4, dp
  use polytope, only : polytope_t
  use polytope_topology, only : topology_object_t
  use polytope_mesh, only : mesh_object_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t, edge_ornt_t, NEKO_EDGE_NFACET
  use quad_new, only : quad_tpl_t, NEKO_QUAD_NFACET
  use hex_new, only : hex_msh_t, NEKO_HEX_NFACET
  use point, only : point_ptr, point_t
  implicit none
  class(polytope_t), pointer :: poly
  type(vertex_tpl_t), dimension(8) :: vrt
  type(edge_tpl_t), dimension(12) :: edt
  type(quad_tpl_t), dimension(6) :: qut
  type(hex_msh_t) :: hxm1
  type(topology_object_t), dimension(0) :: fctv
  integer(i4), dimension(8) :: idv, gsv, idp
  integer(i4), dimension(12) :: ide, gse
  integer(i4), dimension(6) :: idq, gsq, bnq
  integer(i4) :: il, jl, idh1
  integer(i4), dimension(8) :: permv
  integer(i4), dimension(12) :: perme
  integer(i4), dimension(6) :: permq
  type(point_t), dimension(8), target :: pts
  type(point_t), pointer :: point
  type(point_ptr), dimension(8) :: ptsp
  type(point_t) :: centroid
  integer(i4), parameter :: gdim = 3
  ! point coordinates
  real(dp), dimension(gdim, 8) :: crd = reshape((/ 0.0d0, 0.0d0, 0.0d0, &
       &  1.0d0, 0.0d0, 0.0d0,  0.0d0, 1.0d0, 0.0d0,  1.0d0, 1.0d0, 0.0d0, &
       &  0.0d0, 0.0d0, 1.0d0,  1.0d0, 0.0d0, 1.0d0,  0.0d0, 1.0d0, 1.0d0, &
       &  1.0d0, 1.0d0, 1.0d0 /), shape(crd))
  real(kind=dp), parameter :: diameter = 1.7320508075688772d0, tol = 1d-14
  real(kind=dp), dimension(3), parameter :: center = (/0.5d0, 0.5d0, 0.5d0/)

  do il = 1, 8
     idv(il) = il
     gsv(il) = il + 8
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  do il = 1, 8
     idp(il) = il + 20
     pts(il) = point_t(crd(1: 3, il), idp(il))
  end do

  ! Single self-periodic, not hanging hex
  call hex_permutations(0, permv, perme, permq)
  do il = 1, 8
     ptsp(il)%p => pts(il)
  end do
  idh1 = 1
  call hex_algn_msh_get(permv, perme, permq, vrt, ptsp, 0, idh1, gdim, &
       & edt, ide, gse, qut, idq, gsq, bnq, hxm1)

  ! hex dimensions
  @assertEqual(hxm1%id(), idh1)
  @assertEqual(hxm1%tdim(), 3)
  @assertTrue(hxm1%equal_elem(6, 12, 8))

  ! pointers
  ! facets
  do il = 1, 6
     poly => hxm1%fct(il)
     @assertTrue(associated(poly))
     @assertEqual(poly%id(), idq(il))
     @assertEqual(poly%tdim(), 2)
     @assertTrue(poly%equal_elem(4, 4, 0))
     @assertEqual(poly%bnd(), bnq(il))
     @assertEqual(poly%gsid(), gsq(il))
     @assertTrue(poly%equal(qut(il)))
  end do
  ! ridges
  do il = 1, 12
     poly => hxm1%rdg(il)
     @assertTrue(associated(poly))
     @assertEqual(poly%id(), ide(il))
     @assertEqual(poly%tdim(), 1)
     @assertTrue(poly%equal_elem(2, 0, 0))
     @assertEqual(poly%bnd(), -1)
     @assertEqual(poly%gsid(), gse(il))
     @assertTrue(poly%equal(edt(il)))
  end do
  !peaks
  do il = 1, 8
     poly => hxm1%pek(il)
     @assertTrue(associated(poly))
     @assertEqual(poly%id(), idv(il))
     @assertEqual(poly%tdim(), 0)
     @assertTrue(poly%equal_elem(0, 0, 0))
     @assertEqual(poly%bnd(), -1)
     @assertEqual(poly%gsid(), gsv(il))
     @assertTrue(poly%equal(vrt(il)))
  end do
  ! points
  @assertEqual(hxm1%gdim(), gdim)
  @assertEqual(hxm1%npts(), 8)
  do il = 1, 8
     point => hxm1%pnt(il)
     @assertTrue(point .eq. pts(il))
  end do

  ! self-periodic flag
  @assertFalse(hxm1%selfp())

  ! facet boundary flag
  do il = 1, 6
     @assertEqual(hxm1%fct_bnd(il), bnq(il))
  end do

  ! facet gather-scatter id
  do il = 1, 6
     @assertEqual(hxm1%fct_gsid(il), gsq(il))
  end do

  ! ridge gather-scatter id
  do il = 1, 12
     @assertEqual(hxm1%rdg_gsid(il), gse(il))
  end do

  ! peak gather-scatter id
  do il = 1, 8
     @assertEqual(hxm1%pek_gsid(il), gsv(il))
  end do

  ! facet alignment
  do il = 1, 6
     @assertEqual(hxm1%falgn(il), 0)
  end do

  ! quad diameter
  @assertEqual(hxm1%diameter(), diameter, tolerance=tol)

  ! quad centre
  centroid = hxm1%centroid()
  do il = 1, gdim
     @assertEqual(centroid%x(il), center(il), tolerance=tol)
  end do

  ! get facet local direction
  call hxm1%fct_dir(1, il, jl)
  @assertEqual(il, 3)
  @assertEqual(jl, 2)
  call hxm1%fct_dir(2, il, jl)
  @assertEqual(il, 3)
  @assertEqual(jl, 2)
  call hxm1%fct_dir(3, il, jl)
  @assertEqual(il, 3)
  @assertEqual(jl, 1)
  call hxm1%fct_dir(4, il, jl)
  @assertEqual(il, 3)
  @assertEqual(jl, 1)
  call hxm1%fct_dir(5, il, jl)
  @assertEqual(il, 2)
  @assertEqual(jl, 1)
  call hxm1%fct_dir(6, il, jl)
  @assertEqual(il, 2)
  @assertEqual(jl, 1)

  ! get ridge local direction
  do il = 1, 12
     call hxm1%rdg_dir(il, jl)
     @assertEqual(jl, (il - 1) / 4 + 1)
  end do

end subroutine test_hex_mesh_simple

subroutine hex_permutations(algn, permv, perme, permq)
  use num_types, only : i4
  implicit none
  integer(i4), intent(in) :: algn
  integer(i4), dimension(8), intent(out) :: permv
  integer(i4), dimension(12), intent(out) :: perme
  integer(i4), dimension(6), intent(out) :: permq

  select case(algn)
  case(0) ! I
     permv = (/ 1, 2, 3, 4, 5, 6, 7, 8 /)
     perme = (/ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 /)
     permq = (/ 1, 2, 3, 4, 5, 6 /)
  end select

end subroutine hex_permutations

subroutine hex_algn_msh_get(permv, perme, permq, vrt, pts, istr, idh, gdim, &
     & edt, ide, gse, qut, idq, gsq, bnq, hxm)
  use num_types, only : i4
  use polytope_topology, only : topology_object_t
  use polytope_mesh, only : mesh_object_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t, edge_ornt_t, NEKO_EDGE_NFACET
  use quad_new, only : quad_tpl_t, quad_act_t, NEKO_QUAD_NFACET
  use hex_new, only : hex_msh_t, NEKO_HEX_NFACET, NEKO_HEX_NRIDGE, &
       & NEKO_HEX_NPEAK, fct_to_rdg, rdg_to_pek
  use point, only : point_ptr
  implicit none
  integer(i4), dimension(8), intent(in) :: permv
  integer(i4), dimension(12), intent(in) :: perme
  integer(i4), dimension(6), intent(in) :: permq
  type(vertex_tpl_t), dimension(8), intent(in) :: vrt
  type(point_ptr), dimension(8), intent(in) :: pts
  integer(i4), intent(in) :: istr, idh, gdim
  type(edge_tpl_t), dimension(12), intent(out) :: edt
  integer(i4), dimension(12), intent(out) :: ide, gse
  type(quad_tpl_t), dimension(6), intent(out) :: qut
  integer(i4), dimension(6), intent(out) :: idq, gsq, bnq
  type(hex_msh_t), intent(out) :: hxm
  type(topology_object_t), dimension(NEKO_EDGE_NFACET) :: fcte
  type(topology_object_t), dimension(NEKO_QUAD_NFACET) :: fctq
  type(mesh_object_t), dimension(NEKO_HEX_NFACET) :: fcth
  type(point_ptr), dimension(NEKO_HEX_NPEAK) :: ptsl
  integer(i4) :: il, bne, algn, hng
  logical :: ifintp
  integer(i4), dimension(2, 3) :: rdg_hng

  do il = 1, NEKO_HEX_NRIDGE
     ide(il) = istr + il
     gse(il) = istr + il + 24
  end do
  bne = -1
  do il = 1, NEKO_HEX_NRIDGE
     allocate(vertex_ornt_t :: fcte(1)%obj)
     call fcte(1)%obj%init(vrt(permv(rdg_to_pek(1, il))), -1)
     allocate(vertex_ornt_t :: fcte(2)%obj)
     call fcte(2)%obj%init(vrt(permv(rdg_to_pek(2, il))), -1)
     call edt(il)%init(ide(perme(il)), 2, fcte, bne)
     call edt(il)%set_gsid(gse(perme(il)))
  end do

  do il = 1, NEKO_HEX_NFACET
     idq(il) = istr + il
     gsq(il) = istr + il + 12
     bnq(il) = 1
  end do
  ! simple edge alignment
  algn = 0
  do il = 1, NEKO_HEX_NFACET
     allocate(edge_ornt_t :: fctq(1)%obj)
     call fctq(1)%obj%init(edt(perme(fct_to_rdg(1, il))), algn)
     allocate(edge_ornt_t :: fctq(2)%obj)
     call fctq(2)%obj%init(edt(perme(fct_to_rdg(2, il))), algn)
     allocate(edge_ornt_t :: fctq(3)%obj)
     call fctq(3)%obj%init(edt(perme(fct_to_rdg(3, il))), algn)
     allocate(edge_ornt_t :: fctq(4)%obj)
     call fctq(4)%obj%init(edt(perme(fct_to_rdg(4, il))), algn)
     call qut(il)%init(idq(permq(il)), 4, fctq, bnq(il))
     call qut(il)%set_gsid(gsq(permq(il)))
  end do

  do il = 1, NEKO_HEX_NPEAK
     ptsl(il)%p => pts(permv(il))%p
  end do

  ! non self-periodic hex
  ! simple quad alignment
  algn = 0
  ifintp = .false.
  hng = 0
  do il = 1, NEKO_HEX_NFACET
     allocate(quad_act_t :: fcth(il)%obj)
     call fcth(il)%obj%init(qut(il), algn, ifintp, hng, il)
  end do
  call hxm%init(idh, 6, fcth, 8, ptsl, gdim, 0, rdg_hng)

end subroutine hex_algn_msh_get

! MISSING TESTS FOR SHARE AND EQUAL (EQUAL NOT FINALISED YET)
! MISSING TESTS FOR NONCONFORMING VERSION (NOT FINALISED YET)
