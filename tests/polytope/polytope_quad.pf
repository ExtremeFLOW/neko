@test
subroutine test_quad_topology_simple
  use pfunit
  use num_types, only : i4
  use polytope, only : polytope_t
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t
  use quad_new, only : quad_tpl_t
  implicit none
  class(polytope_t), pointer :: poly
  type(vertex_tpl_t), dimension(4) :: vrt
  type(edge_tpl_t), dimension(4) :: edt
  type(quad_tpl_t) :: qut1
  type(topology_component_t), dimension(0) :: fctv
  integer(i4), dimension(4) :: idv, gsv
  integer(i4), dimension(4) :: ide, gse, bne
  integer(i4) :: il, algn, idq1, bnq1, gsq1
  integer(i4), dimension(4) :: permv, perme

  do il = 1, 4
     idv(il) = il
     gsv(il) = il + 8
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  ! Single non self-periodic, not hanging quad
  call quad_permutations(0, permv, perme)
  idq1 = 10
  gsq1 = 20
  bnq1 = 30
  bne = (/ 1, 1, 2, 2 /)
  call quad_algn_tpl_get(permv, perme, vrt, 5, bne, idq1, gsq1, bnq1, edt, &
       & ide, gse, qut1)

  ! quad dimensions
  @assertEqual(qut1%id(), idq1)
  @assertEqual(qut1%tdim(), 2)
  @assertTrue(qut1%check_comp(4, 4, 0))

  ! pointers
  ! facets
  do il = 1, 4
     poly => qut1%fct(il)
     @assertTrue(associated(poly))
     @assertEqual(poly%id(), ide(il))
     @assertEqual(poly%tdim(), 1)
     @assertTrue(poly%check_comp(2, 0, 0))
     @assertEqual(poly%bnd(), bne(il))
     @assertEqual(poly%gsid(), gse(il))
     @assertTrue(poly%equal(edt(il)))
  end do
  ! ridges
  do il = 1, 4
     poly => qut1%rdg(il)
     @assertTrue(associated(poly))
     @assertEqual(poly%id(), idv(il))
     @assertEqual(poly%tdim(), 0)
     @assertTrue(poly%check_comp(0, 0, 0))
     @assertEqual(poly%bnd(), -1)
     @assertEqual(poly%gsid(), gsv(il))
     @assertTrue(poly%equal(vrt(il)))
  end do

  ! boundary
  @assertEqual(qut1%bnd(), bnq1)

  ! gather-scatter id
  @assertEqual(qut1%gsid(), gsq1)

  ! self-periodic flag
  @assertFalse(qut1%self_periodic())

  ! facet alignment tests
  algn = 0
  do il = 1, 4
     @assertEqual(qut1%falgn(il), algn)
  end do

   do il =1, 4
     call vrt(il)%free()
     call edt(il)%free()
  end do
  call qut1%free()

end subroutine test_quad_topology_simple

@test
subroutine test_quad_tpl_add
  use pfunit
  use num_types, only : i4
  use topology, only : topology_t
  use vertex, only : vertex_tpl_add
  use edge, only : edge_tpl_add
  use quad_new, only : quad_tpl_add
  implicit none
  class(topology_t), allocatable :: qad, vrt1, vrt2, vrt3, vrt4, edg1, edg2, &
       & edg3, edg4
  integer(i4) :: id, bnd

  id = 1
  call vertex_tpl_add(vrt1, id)
  id = 2
  call vertex_tpl_add(vrt2, id)
  id = 3
  call vertex_tpl_add(vrt3, id)
  id = 4
  call vertex_tpl_add(vrt4, id)

  id = 1
  call edge_tpl_add(edg1, id, -1, vrt1, vrt3)
  id = 2
  call edge_tpl_add(edg2, id, -1, vrt2, vrt4)
  id = 3
  call edge_tpl_add(edg3, id, -1, vrt1, vrt2)
  id = 4
  call edge_tpl_add(edg4, id, -1, vrt3, vrt4)


  id = 100
  bnd = 200
  call quad_tpl_add(qad, id, bnd, edg1, edg2, edg3, edg4, 0, 0, 0, 0)

  ! edge dimensions
  @assertEqual(qad%id(), id)
  @assertEqual(qad%bnd(), bnd)
  @assertEqual(qad%tdim(), 2)
  @assertTrue(qad%check_comp(4, 4, 0))

  call qad%free()
  call edg1%free()
  call edg2%free()
  call edg3%free()
  call edg4%free()
  call vrt1%free()
  call vrt2%free()
  call vrt3%free()
  call vrt4%free()
  deallocate(qad, edg1, edg2, edg3, edg4, vrt1, vrt2, vrt3, vrt4)

end subroutine test_quad_tpl_add

@test
subroutine test_quad_topology_permute
  use pfunit
  use num_types, only : i4
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t
  use quad_new, only : quad_tpl_t
  implicit none
  type(vertex_tpl_t), dimension(4) :: vrt
  type(edge_tpl_t), dimension(4) :: edt, edtP
  type(quad_tpl_t) :: qut1, qut1P
  type(topology_component_t), dimension(0) :: fctv
  integer(i4), dimension(4) :: idv, gsv
  integer(i4), dimension(4) :: ide, gse, bne, ideP, gseP
  integer(i4) :: il, jl, itmp, idq1, bnq1, gsq1
  integer(i4), dimension(4) :: permv, perme
  integer(i4), dimension(:, :), allocatable :: facetp

  do il = 1, 4
     idv(il) = il
     gsv(il) = il + 8
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  ! Single non self-periodic, not hanging quad
  call quad_permutations(0, permv, perme)
  idq1 = 10
  gsq1 = 20
  bnq1 = 30
  bne = (/ 1, 1, 2, 2 /)
  call quad_algn_tpl_get(permv, perme, vrt, 0, bne, idq1, gsq1, bnq1, edt, &
       & ide, gse, qut1)

  ! equality with respect to various alignment
  do il = 0, 7
     call quad_permutations(il, permv, perme)
     call quad_algn_tpl_get(permv, perme, vrt(1: 4), 0, bne, idq1, gsq1, bnq1, &
          & edtP, ideP, gseP, qut1P)
     call quad_permutations_inv(il, permv, perme)

     @assertTrue(qut1%equal(qut1P))

     call qut1%fct_share(qut1P, itmp, facetp)
     @assertEqual(itmp, 4)
     do jl = 1, 4
        @assertEqual(facetp(1, jl), jl)
        @assertEqual(facetp(2, jl), perme(jl))
     end do
     deallocate(facetp)

     call qut1%rdg_share(qut1P, itmp, facetp)
     @assertEqual(itmp, 4)
     do jl = 1, 4
        @assertEqual(facetp(1, jl), jl)
        @assertEqual(facetp(2, jl), permv(jl))
     end do
     deallocate(facetp)
  end do

  do il =1, 4
     call vrt(il)%free()
     call edt(il)%free()
  end do
  do il =1, 4
     call edtP(il)%free()
  end do
  call qut1%free()
  call qut1P%free()

end subroutine test_quad_topology_permute


@test
subroutine test_quad_topology_share
  use pfunit
  use num_types, only : i4
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t, edge_ornt_t, NEKO_EDGE_NFACET
  use quad_new, only : quad_tpl_t, NEKO_QUAD_NFACET
  implicit none
  type(vertex_tpl_t), dimension(8) :: vrt
  type(edge_tpl_t), dimension(8) :: edt
  type(quad_tpl_t) :: qut1, qut2
  type(topology_component_t), dimension(0) :: fctv
  integer(i4), dimension(8) :: idv, gsv
  integer(i4), dimension(8) :: ide, gse, bne
  integer(i4) :: il, jl, itmp, algn, idq1, bnq1, gsq1, idq2, bnq2, gsq2
  integer(i4), dimension(4) :: permv, perme
  integer(i4), dimension(:, :), allocatable :: facetp
  type(topology_component_t), dimension(NEKO_EDGE_NFACET) :: fcte
  type(topology_component_t), dimension(NEKO_QUAD_NFACET) :: fctq

  do il = 1, 8
     idv(il) = il
     gsv(il) = il + 8
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  ! Two non self-periodic, not hanging, separate quads
  call quad_permutations(0, permv, perme)
  idq1 = 10
  gsq1 = 20
  bnq1 = 30
  idq2 = 40
  gsq2 = 50
  bnq2 = 60
  bne = (/ 1, 1, 2, 2, 1, 1, 2, 2 /)
  call quad_algn_tpl_get(permv, perme, vrt(1: 4), 0, bne(1: 4), idq1, gsq1, &
       & bnq1, edt(1: 4), ide(1: 4), gse(1: 4), qut1)
  call quad_algn_tpl_get(permv, perme, vrt(5: 8), 10, bne(5: 8), idq2, gsq2, &
       & bnq2, edt(5: 8), ide(5: 8), gse(5: 8), qut2)

  ! quad equality
  @assertFalse(qut1%equal(qut2))

  ! shared facets
  call qut1%fct_share(qut2, itmp, facetp)
  @assertEqual(itmp, 0)
  deallocate(facetp)

  ! shared ridges
  call qut1%rdg_share(qut2, itmp, facetp)
  @assertEqual(itmp, 0)
  deallocate(facetp)


  ! second non self-periodic quad; single vertex shared
  ! modify edges 5 and 7
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(4), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(7), -1)
  call edt(5)%init(ide(5), 2, fcte, bne(5))
  call edt(5)%set_gsid(gse(5))

  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(4), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(6), -1)
  call edt(7)%init(ide(7), 2, fcte, bne(7))
  call edt(7)%set_gsid(gse(7))

  ! quad equality
  @assertFalse(qut1%equal(qut2))

  ! simple edge alignment
  algn = 0
  do il = 1, 4
     allocate(edge_ornt_t :: fctq(il)%obj)
     call fctq(il)%obj%init(edt(il + 4), algn)
  end do
  call qut2%init(idq2, 4, fctq, bnq2)
  call qut2%set_gsid(gsq2)

  ! shared facets
  call qut1%fct_share(qut2, itmp, facetp)
  @assertEqual(itmp, 0)
  deallocate(facetp)

  ! shared ridges
  call qut1%rdg_share(qut2, itmp, facetp)
  @assertEqual(itmp, 1)
  @assertEqual(facetp(1, 1), 4)
  @assertEqual(facetp(2, 1), 1)
  deallocate(facetp)


  ! second non self-periodic quad; single edge shared
  ! modify edges 7 and 8
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(2), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(6), -1)
  call edt(7)%init(ide(7), 2, fcte, bne(7))
  call edt(7)%set_gsid(gse(7))

  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(4), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(8), -1)
  call edt(8)%init(ide(8), 2, fcte, bne(8))
  call edt(8)%set_gsid(gse(8))

  ! simple edge alignment
  algn = 0
  allocate(edge_ornt_t :: fctq(1)%obj)
  call fctq(1)%obj%init(edt(2), algn)
  do il = 2, 4
     allocate(edge_ornt_t :: fctq(il)%obj)
     call fctq(il)%obj%init(edt(il + 4), algn)
  end do
  call qut2%init(idq2, 4, fctq, bnq2)
  call qut2%set_gsid(gsq2)

  ! quad equality
  @assertFalse(qut1%equal(qut2))

  ! shared facets
  call qut1%fct_share(qut2, itmp, facetp)
  @assertEqual(itmp, 1)
  @assertEqual(facetp(1, 1), 2)
  @assertEqual(facetp(2, 1), 1)
  deallocate(facetp)

  ! shared ridges
  call qut1%rdg_share(qut2, itmp, facetp)
  @assertEqual(itmp, 2)
  @assertEqual(facetp(1, 1), 2)
  @assertEqual(facetp(2, 1), 1)
  @assertEqual(facetp(1, 2), 4)
  @assertEqual(facetp(2, 2), 3)
  deallocate(facetp)

  do il =1, 8
     call vrt(il)%free()
     call edt(il)%free()
  end do
  call qut1%free()
  call qut2%free()

end subroutine test_quad_topology_share

@test
subroutine test_quad_topology_periodic_stripe
  use pfunit
  use num_types, only : i4
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t, edge_ornt_t, NEKO_EDGE_NFACET
  use quad_new, only : quad_tpl_t, NEKO_QUAD_NFACET
  implicit none
  type(vertex_tpl_t), dimension(4) :: vrt
  type(edge_tpl_t), dimension(6) :: edt
  type(quad_tpl_t) :: qut1, qut2
  type(topology_component_t), dimension(0) :: fctv
  integer(i4), dimension(8) :: idv, gsv
  integer(i4), dimension(6) :: ide, gse, bne
  integer(i4) :: il, jl, itmp, algn, idq1, bnq1, gsq1, idq2, bnq2, gsq2
  integer(i4), dimension(4) :: permv, perme
  integer(i4), dimension(:, :), allocatable :: facetp
  type(topology_component_t), dimension(NEKO_EDGE_NFACET) :: fcte
  type(topology_component_t), dimension(NEKO_QUAD_NFACET) :: fctq

  do il = 1, 4
     idv(il) = il
     gsv(il) = il + 8
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  ! Two non self-periodic, not hanging quads in periodic stripe
  call quad_permutations(0, permv, perme)
  idq1 = 10
  gsq1 = 20
  bnq1 = 30
  idq2 = 40
  gsq2 = 50
  bnq2 = 60
  bne = (/ 1, 1, 2, 2, 2, 2 /)
  call quad_algn_tpl_get(permv, perme, vrt(1: 4), 0, bne(1: 4), idq1, gsq1, &
       & bnq1, edt(1: 4), ide(1: 4), gse(1: 4), qut1)

  ! add edges 5 and 6
  ide(5) = 15
  gse(5) = 25
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(2), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(1), -1)
  call edt(5)%init(ide(5), 2, fcte, bne(5))
  call edt(5)%set_gsid(gse(5))

  ide(6) = 35
  gse(6) = 45
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(4), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(3), -1)
  call edt(6)%init(ide(6), 2, fcte, bne(6))
  call edt(6)%set_gsid(gse(6))

  ! simple edge alignment
  algn = 0
  allocate(edge_ornt_t :: fctq(1)%obj)
  call fctq(1)%obj%init(edt(2), algn)
  allocate(edge_ornt_t :: fctq(2)%obj)
  call fctq(2)%obj%init(edt(1), algn)
  do il = 3, 4
     allocate(edge_ornt_t :: fctq(il)%obj)
     call fctq(il)%obj%init(edt(il + 2), algn)
  end do
  call qut2%init(idq2, 4, fctq, bnq2)
  call qut2%set_gsid(gsq2)

  ! shared facets
  call qut1%fct_share(qut2, itmp, facetp)
  @assertEqual(itmp, 2)
  @assertEqual(facetp(1, 1), 1)
  @assertEqual(facetp(2, 1), 2)
  @assertEqual(facetp(1, 2), 2)
  @assertEqual(facetp(2, 2), 1)
  deallocate(facetp)

  ! shared ridges
  call qut1%rdg_share(qut2, itmp, facetp)
  @assertEqual(itmp, 4)
  @assertEqual(facetp(1, 1), 1)
  @assertEqual(facetp(2, 1), 2)
  @assertEqual(facetp(1, 2), 2)
  @assertEqual(facetp(2, 2), 1)
  @assertEqual(facetp(1, 3), 3)
  @assertEqual(facetp(2, 3), 4)
  @assertEqual(facetp(1, 4), 4)
  @assertEqual(facetp(2, 4), 3)
  deallocate(facetp)

  ! quad equality
  @assertFalse(qut1%equal(qut2))

  do il =1, 4
     call vrt(il)%free()
  end do
  do il =1, 6
     call edt(il)%free()
  end do
  call qut1%free()
  call qut2%free()

end subroutine test_quad_topology_periodic_stripe


@test
subroutine test_quad_topology_Mobius_stripe
  use pfunit
  use num_types, only : i4
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t, edge_ornt_t, NEKO_EDGE_NFACET
  use quad_new, only : quad_tpl_t, NEKO_QUAD_NFACET
  implicit none
  type(vertex_tpl_t), dimension(4) :: vrt
  type(edge_tpl_t), dimension(6) :: edt
  type(quad_tpl_t) :: qut1, qut2
  type(topology_component_t), dimension(0) :: fctv
  integer(i4), dimension(8) :: idv, gsv
  integer(i4), dimension(6) :: ide, gse, bne
  integer(i4) :: il, jl, itmp, algn, idq1, bnq1, gsq1, idq2, bnq2, gsq2
  integer(i4), dimension(4) :: permv, perme
  integer(i4), dimension(:, :), allocatable :: facetp
  type(topology_component_t), dimension(NEKO_EDGE_NFACET) :: fcte
  type(topology_component_t), dimension(NEKO_QUAD_NFACET) :: fctq

  do il = 1, 4
     idv(il) = il
     gsv(il) = il + 8
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  ! Two non self-periodic, not hanging quads in periodic stripe
  call quad_permutations(0, permv, perme)
  idq1 = 10
  gsq1 = 20
  bnq1 = 30
  idq2 = 40
  gsq2 = 50
  bnq2 = 60
  bne = (/ 1, 1, 2, 2, 2, 2 /)
  call quad_algn_tpl_get(permv, perme, vrt(1: 4), 0, bne(1: 4), idq1, gsq1, &
       & bnq1, edt(1: 4), ide(1: 4), gse(1: 4), qut1)

  ! add edges 5 and 6
  ide(5) = 15
  gse(5) = 25
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(2), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(3), -1)
  call edt(5)%init(ide(5), 2, fcte, bne(5))
  call edt(5)%set_gsid(gse(5))

  ide(6) = 35
  gse(6) = 45
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(4), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(1), -1)
  call edt(6)%init(ide(6), 2, fcte, bne(6))
  call edt(6)%set_gsid(gse(6))

  ! simple edge alignment
  algn = 0
  allocate(edge_ornt_t :: fctq(1)%obj)
  call fctq(1)%obj%init(edt(2), algn)
  ! permutation
  algn = 1
  allocate(edge_ornt_t :: fctq(2)%obj)
  call fctq(2)%obj%init(edt(1), algn)
  ! simple edge alignment
  algn = 0
  do il = 3, 4
     allocate(edge_ornt_t :: fctq(il)%obj)
     call fctq(il)%obj%init(edt(il + 2), algn)
  end do
  call qut2%init(idq2, 4, fctq, bnq2)
  call qut2%set_gsid(gsq2)

  ! facet alignment tests
  @assertEqual(qut2%falgn(1), 0)
  @assertEqual(qut2%falgn(2), 1)
  do il = 3, 4
     @assertEqual(qut2%falgn(il), 0)
  end do

  ! shared facets
  call qut1%fct_share(qut2, itmp, facetp)
  @assertEqual(itmp, 2)
  @assertEqual(facetp(1, 1), 1)
  @assertEqual(facetp(2, 1), 2)
  @assertEqual(facetp(1, 2), 2)
  @assertEqual(facetp(2, 2), 1)
  deallocate(facetp)

  ! shared ridges
  call qut1%rdg_share(qut2, itmp, facetp)
  @assertEqual(itmp, 4)
  @assertEqual(facetp(1, 1), 1)
  @assertEqual(facetp(2, 1), 4)
  @assertEqual(facetp(1, 2), 2)
  @assertEqual(facetp(2, 2), 1)
  @assertEqual(facetp(1, 3), 3)
  @assertEqual(facetp(2, 3), 2)
  @assertEqual(facetp(1, 4), 4)
  @assertEqual(facetp(2, 4), 3)
  deallocate(facetp)

  ! quad equality
  @assertFalse(qut1%equal(qut2))

  do il =1, 4
     call vrt(il)%free()
  end do
  do il =1, 6
     call edt(il)%free()
  end do
  call qut1%free()
  call qut2%free()

end subroutine test_quad_topology_Mobius_stripe

@test
subroutine test_quad_topology_selfperiodic_simple
  use pfunit
  use num_types, only : i4
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t, edge_ornt_t, NEKO_EDGE_NFACET
  use quad_new, only : quad_tpl_t, NEKO_QUAD_NFACET
  implicit none
  type(vertex_tpl_t), dimension(2) :: vrt
  type(edge_tpl_t), dimension(3) :: edt
  type(quad_tpl_t) :: qut1
  type(topology_component_t), dimension(0) :: fctv
  integer(i4), dimension(2) :: idv, gsv
  integer(i4), dimension(3) :: ide, gse, bne
  integer(i4) :: il, jl, itmp, algn, idq1, bnq1, gsq1
  type(topology_component_t), dimension(NEKO_EDGE_NFACET) :: fcte
  type(topology_component_t), dimension(NEKO_QUAD_NFACET) :: fctq

  do il = 1, 2
     idv(il) = il
     gsv(il) = il + 8
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  ! create edges 1, 2 ,3
  bne = (/ 1, 2, 2 /)
  ide = (/ 15, 35, 55 /)
  gse = (/ 25, 45, 65 /)
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(1), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(2), -1)
  call edt(1)%init(ide(1), 2, fcte, bne(1))
  call edt(1)%set_gsid(gse(1))

  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(1), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(1), -1)
  call edt(2)%init(ide(2), 2, fcte, bne(2))
  call edt(2)%set_gsid(gse(2))

  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(2), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(2), -1)
  call edt(3)%init(ide(3), 2, fcte, bne(3))
  call edt(3)%set_gsid(gse(3))

  ! simple edge alignment
  algn = 0
  allocate(edge_ornt_t :: fctq(1)%obj)
  call fctq(1)%obj%init(edt(1), algn)
  allocate(edge_ornt_t :: fctq(2)%obj)
  call fctq(2)%obj%init(edt(1), algn)
  do il = 3, 4
     allocate(edge_ornt_t :: fctq(il)%obj)
     call fctq(il)%obj%init(edt(il - 1), algn)
  end do
  call qut1%init(idq1, 4, fctq, bnq1)
  call qut1%set_gsid(gsq1)

  ! self-periodic flag; vertex has no components
  @assertTrue(qut1%self_periodic())

  do il =1, 2
     call vrt(il)%free()
  end do
  do il =1, 3
     call edt(il)%free()
  end do
  call qut1%free()

end subroutine test_quad_topology_selfperiodic_simple

@test
subroutine test_quad_topology_selfperiodic_Mobius
  use pfunit
  use num_types, only : i4
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t, edge_ornt_t, NEKO_EDGE_NFACET
  use quad_new, only : quad_tpl_t, NEKO_QUAD_NFACET
  implicit none
  type(vertex_tpl_t), dimension(2) :: vrt
  type(edge_tpl_t), dimension(3) :: edt
  type(quad_tpl_t) :: qut1
  type(topology_component_t), dimension(0) :: fctv
  integer(i4), dimension(2) :: idv, gsv
  integer(i4), dimension(3) :: ide, gse, bne
  integer(i4) :: il, jl, itmp, algn, idq1, bnq1, gsq1
  type(topology_component_t), dimension(NEKO_EDGE_NFACET) :: fcte
  type(topology_component_t), dimension(NEKO_QUAD_NFACET) :: fctq

  do il = 1, 2
     idv(il) = il
     gsv(il) = il + 8
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  ! create edges 1, 2 ,3
  bne = (/ 1, 2, 2 /)
  ide = (/ 15, 35, 55 /)
  gse = (/ 25, 45, 65 /)
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(1), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(2), -1)
  call edt(1)%init(ide(1), 2, fcte, bne(1))
  call edt(1)%set_gsid(gse(1))

  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(1), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(2), -1)
  call edt(2)%init(ide(2), 2, fcte, bne(2))
  call edt(2)%set_gsid(gse(2))

  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(2), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(1), -1)
  call edt(3)%init(ide(3), 2, fcte, bne(3))
  call edt(3)%set_gsid(gse(3))

  ! simple edge alignment
  algn = 0
  allocate(edge_ornt_t :: fctq(1)%obj)
  call fctq(1)%obj%init(edt(1), algn)
  ! permutation
  algn = 1
  allocate(edge_ornt_t :: fctq(2)%obj)
  call fctq(2)%obj%init(edt(1), algn)
  ! simple edge alignment
  algn = 0
  do il = 3, 4
     allocate(edge_ornt_t :: fctq(il)%obj)
     call fctq(il)%obj%init(edt(il - 1), algn)
  end do
  call qut1%init(idq1, 4, fctq, bnq1)
  call qut1%set_gsid(gsq1)

  ! self-periodic flag; vertex has no components
  @assertTrue(qut1%self_periodic())

  do il =1, 2
     call vrt(il)%free()
  end do
  do il =1, 3
     call edt(il)%free()
  end do
  call qut1%free()

end subroutine test_quad_topology_selfperiodic_Mobius

@test
subroutine test_quad_topology_selfperiodic_torus
  use pfunit
  use num_types, only : i4
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t, edge_ornt_t, NEKO_EDGE_NFACET
  use quad_new, only : quad_tpl_t, NEKO_QUAD_NFACET
  implicit none
  type(vertex_tpl_t) :: vrt
  type(edge_tpl_t), dimension(2) :: edt
  type(quad_tpl_t) :: qut1
  type(topology_component_t), dimension(0) :: fctv
  integer(i4) :: idv, gsv
  integer(i4), dimension(2) :: ide, gse, bne
  integer(i4) :: il, jl, itmp, algn, idq1, bnq1, gsq1
  type(topology_component_t), dimension(NEKO_EDGE_NFACET) :: fcte
  type(topology_component_t), dimension(NEKO_QUAD_NFACET) :: fctq

  idv = 1
  gsv = 8
  call vrt%init(idv, 0, fctv, -1)
  call vrt%set_gsid(gsv)

  ! create edges 1, 2
  bne = (/ 1, 2 /)
  ide = (/ 15, 35 /)
  gse = (/ 25, 45 /)
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt, -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt, -1)
  call edt(1)%init(ide(1), 2, fcte, bne(1))
  call edt(1)%set_gsid(gse(1))

  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt, -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt, -1)
  call edt(2)%init(ide(2), 2, fcte, bne(2))
  call edt(2)%set_gsid(gse(2))


  ! simple edge alignment
  algn = 0
  do il = 1, 2
     allocate(edge_ornt_t :: fctq(il)%obj)
     call fctq(il)%obj%init(edt(1), algn)
  end do
  do il = 3, 4
     allocate(edge_ornt_t :: fctq(il)%obj)
     call fctq(il)%obj%init(edt(2), algn)
  end do
  call qut1%init(idq1, 4, fctq, bnq1)
  call qut1%set_gsid(gsq1)

  ! self-periodic flag; vertex has no components
  @assertTrue(qut1%self_periodic())

  call vrt%free()
  do il =1, 2
     call edt(il)%free()
  end do
  call qut1%free()

end subroutine test_quad_topology_selfperiodic_torus

@test
subroutine test_quad_actualisation_simple
  use pfunit
  use num_types, only : i4
  use polytope, only : polytope_t
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t
  use quad_new, only : quad_tpl_t, quad_act_t, NEKO_QUAD_NFACET
  implicit none
  class(polytope_t), pointer :: poly, polye
  type(vertex_tpl_t), dimension(4) :: vrt
  type(edge_tpl_t), dimension(4) :: edt
  type(quad_tpl_t) :: qut1
  type(quad_act_t) :: qua1
  type(topology_component_t), dimension(0) :: fctv
  integer(i4), dimension(4) :: idv, gsv, ide, gse, bne
  integer(i4) :: il, algn, hng, pos, idq1, bnq1, gsq1
  integer(i4), dimension(4) :: permv, perme
  logical :: equal, ifintp

  do il = 1, 4
     idv(il) = il
     gsv(il) = il + 8
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  ! Non self-periodic quad
  algn = 0 ! Identity
  bne = (/ 1, 1, 2, 2 /)
  call quad_permutations(algn, permv, perme)
  idq1 = 1
  bnq1 = 2
  gsq1 = 3
  call quad_algn_tpl_get(permv, perme, vrt(1: 4), 0, bne(1: 4), idq1, gsq1, &
       & bnq1, edt(1: 4), ide(1: 4), gse(1: 4), qut1)

  ! get quad actualisation
  algn = 1 ! Transpose
  ifintp = .true.
  hng = 2
  pos = 6
  call qua1%init(qut1, algn, ifintp, hng, pos)

  ! pointer
  call qua1%polyp(poly)
  @assertTrue(associated(poly))
  @assertEqual(poly%id(), idq1)
  @assertEqual(poly%tdim(), 2)
  @assertTrue(poly%check_comp(4, 4, 0))
  @assertEqual(poly%bnd(), bnq1)
  @assertEqual(poly%gsid(), gsq1)
  @assertTrue(poly%equal(qut1))

  ! component pointers
  ! facets
  do il = 1, 4
     polye => poly%fct(il)
     @assertTrue(associated(polye))
     @assertEqual(polye%id(), ide(il))
     @assertEqual(polye%tdim(), 1)
     @assertTrue(polye%check_comp(2, 0, 0))
     @assertEqual(polye%bnd(), bne(il))
     @assertEqual(polye%gsid(), gse(il))
     @assertTrue(polye%equal(edt(il)))
  end do
  ! ridges
  do il = 1, 4
     polye => poly%rdg(il)
     @assertTrue(associated(polye))
     @assertEqual(polye%id(), idv(il))
     @assertEqual(polye%tdim(), 0)
     @assertTrue(polye%check_comp(0, 0, 0))
     @assertEqual(polye%bnd(), -1)
     @assertEqual(polye%gsid(), gsv(il))
     @assertTrue(polye%equal(vrt(il)))
  end do

  ! alignment
  @assertTrue(qua1%ifalgn())
  @assertEqual(qua1%algn(), algn)

  ! interpolation and hanging information
  @assertTrue(qua1%ifintp())
  @assertEqual(qua1%hng(), hng)

  ! position
  @assertEqual(qua1%pos(), pos)

  ! equality and alignment tests
  @assertTrue(qua1%equal(qut1))

  call qua1%equal_algn(qut1, equal, algn)
  @assertTrue(equal)
  @assertEqual(algn, 0)

  @assertFalse(qua1%test(qut1))

  do il =1, 4
     call vrt(il)%free()
     call edt(il)%free()
  end do
  call qut1%free()
  call qua1%free()

end subroutine test_quad_actualisation_simple

@test
subroutine test_quad_actualisation_permute
  use pfunit
  use num_types, only : i4
  use polytope, only : polytope_t
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t
  use quad_new, only : quad_tpl_t, quad_act_t, NEKO_QUAD_NFACET
  implicit none
  class(polytope_t), pointer :: poly, polye
  type(vertex_tpl_t), dimension(4) :: vrt
  type(edge_tpl_t), dimension(4) :: edt, edtP
  type(quad_tpl_t) :: qut1, qut1P
  type(quad_act_t) :: qua1
  type(topology_component_t), dimension(0) :: fctv
  integer(i4), dimension(4) :: idv, gsv, ide, gse, bne, ideP, gseP
  integer(i4) :: il, algn, hng, pos, idq1, bnq1, gsq1
  integer(i4), dimension(4) :: permv, perme
  logical :: equal, ifintp

  do il = 1, 4
     idv(il) = il
     gsv(il) = il + 8
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  ! Non self-periodic quad
  algn = 0 ! Identity
  bne = (/ 1, 1, 2, 2 /)
  call quad_permutations(algn, permv, perme)
  idq1 = 1
  bnq1 = 2
  gsq1 = 3
  call quad_algn_tpl_get(permv, perme, vrt(1: 4), 0, bne(1: 4), idq1, gsq1, &
       & bnq1, edt(1: 4), ide(1: 4), gse(1: 4), qut1)

  ! get quad actualisation
  algn = 2 ! PX
  ifintp = .true.
  hng = 2
  pos = 6
  call qua1%init(qut1, algn, ifintp, hng, pos)

  ! equality and alignment tests
  do il = 0, 7
     call quad_permutations(il, permv, perme)
     call quad_algn_tpl_get(permv, perme, vrt(1: 4), 0, bne(1: 4), idq1, gsq1, &
          & bnq1, edtP, ideP, gseP, qut1P)
     call qua1%equal_algn(qut1P, equal, algn)
     @assertTrue(equal)
     @assertEqual(algn, il)
     if (il == 2) then
        @assertTrue(qua1%test(qut1P))
     else
        @assertFalse(qua1%test(qut1P))
     end if
  end do

  do il =1, 4
     call vrt(il)%free()
     call edt(il)%free()
  end do
  do il =1, 4
     call edtP(il)%free()
  end do
  call qut1%free()
  call qut1P%free()
  call qua1%free()

end subroutine test_quad_actualisation_permute

@test
subroutine test_quad_actualisation_separate
  use pfunit
  use num_types, only : i4
  use polytope, only : polytope_t
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t
  use quad_new, only : quad_tpl_t, quad_act_t, NEKO_QUAD_NFACET
  implicit none
  class(polytope_t), pointer :: poly, polye
  type(vertex_tpl_t), dimension(8) :: vrt
  type(edge_tpl_t), dimension(8) :: edt
  type(quad_tpl_t) :: qut1, qut2
  type(quad_act_t) :: qua1
  type(topology_component_t), dimension(0) :: fctv
  integer(i4), dimension(8) :: idv, gsv, ide, gse, bne
  integer(i4) :: il, algn, hng, pos, idq1, bnq1, gsq1, idq2, bnq2, gsq2
  integer(i4), dimension(4) :: permv, perme
  logical :: equal, ifintp

  do il = 1, 8
     idv(il) = il
     gsv(il) = il + 8
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  ! Two separate non self-periodic quads
  algn = 0 ! Identity
  bne = (/ 1, 1, 2, 2, 1, 1, 2, 2 /)
  call quad_permutations(algn, permv, perme)
  idq1 = 1
  bnq1 = 2
  gsq1 = 3
  call quad_algn_tpl_get(permv, perme, vrt(1: 4), 0, bne(1: 4), idq1, gsq1, &
       & bnq1, edt(1: 4), ide(1: 4), gse(1: 4), qut1)
  idq2 = 4
  bnq2 = 5
  gsq2 = 6
  call quad_algn_tpl_get(permv, perme, vrt(5: 8), 4, bne, idq2, gsq2, bnq2, &
       & edt(5: 8), ide(5: 8), gse(5: 8), qut2)

  ! get quad actualisation
  algn = 2 ! PX
  ifintp = .true.
  hng = 2
  pos = 6
  call qua1%init(qut1, algn, ifintp, hng, pos)

  @assertFalse(qua1%equal(qut2))
  call qua1%equal_algn(qut2, equal, algn)
  @assertFalse(equal)
  @assertEqual(algn, -1)
  @assertFalse(qua1%test(qut2))

  do il =1, 8
     call vrt(il)%free()
     call edt(il)%free()
  end do
  call qut1%free()
  call qut2%free()
  call qua1%free()

end subroutine test_quad_actualisation_separate

@test
subroutine test_quad_mesh_simple
  use pfunit
  use num_types, only : i4, dp
  use polytope, only : polytope_t
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t
  use quad_new, only : quad_elm_t
  use point, only : point_ptr, point_t
  implicit none
  class(polytope_t), pointer :: poly
  type(vertex_tpl_t), dimension(4) :: vrt
  type(edge_tpl_t), dimension(4) :: edt
  type(quad_elm_t) :: qum1
  type(topology_component_t), dimension(0) :: fctv
  integer(i4), dimension(8) :: idv, gsv, idp
  integer(i4), dimension(8) :: ide, gse, bne
  integer(i4) :: il, jl, itmp, idq1
  integer(i4), dimension(4) :: permv, perme
  type(point_t), dimension(4), target :: pts
  type(point_t), pointer :: point
  type(point_ptr), dimension(4) :: ptsp
  type(point_t) :: centroid
  integer(i4), parameter :: gdim = 3
  ! point coordinates
  real(dp), dimension(gdim, 4) :: crd = reshape((/ 0.0d0, 0.0d0, 0.0d0, &
       &  1.0d0, 0.0d0, 0.0d0,  0.0d0, 1.0d0, 0.0d0,  1.0d0, 1.0d0, 0.0d0 /), &
       & shape(crd))
  real(kind=dp), parameter :: diameter = 1.414213562373095d0, tol = 1.0d-14
  real(kind=dp), dimension(3), parameter :: center = (/0.5d0, 0.5d0, 0.0d0/)

  do il = 1, 4
     idv(il) = il
     gsv(il) = il + 8
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  do il = 1, 4
     idp(il) = il + 20
     pts(il) = point_t(crd(1: 3, il), idp(il))
  end do

  ! Two non self-periodic, not hanging quad
  ! first quad
  call quad_permutations(0, permv, perme)
  do il = 1, 4
     ptsp(il)%p => pts(il)
  end do
  bne(1) = 1
  bne(2) = 1
  bne(3) = 2
  bne(4) = 2
  idq1 = 1
  call quad_algn_msh_get(permv, perme, vrt(1: 4), ptsp, 0, bne(1: 4), idq1, &
       & gdim, edt(1: 4), ide(1: 4), gse(1: 4), qum1)

  ! quad dimensions
  @assertEqual(qum1%id(), idq1)
  @assertEqual(qum1%tdim(), 2)
  @assertTrue(qum1%check_comp(4, 4, 0))

  ! pointers
  ! facets
  do il = 1, 4
     poly => qum1%fct(il)
     @assertTrue(associated(poly))
     @assertEqual(poly%id(), ide(il))
     @assertEqual(poly%tdim(), 1)
     @assertTrue(poly%check_comp(2, 0, 0))
     @assertEqual(poly%bnd(), bne(il))
     @assertEqual(poly%gsid(), gse(il))
     @assertTrue(poly%equal(edt(il)))
  end do
  ! ridges
  do il = 1, 4
     poly => qum1%rdg(il)
     @assertTrue(associated(poly))
     @assertEqual(poly%id(), idv(il))
     @assertEqual(poly%tdim(), 0)
     @assertTrue(poly%check_comp(0, 0, 0))
     @assertEqual(poly%bnd(), -1)
     @assertEqual(poly%gsid(), gsv(il))
     @assertTrue(poly%equal(vrt(il)))
  end do
  ! points
  @assertEqual(qum1%gdim(), gdim)
  @assertEqual(qum1%npts(), 4)
  do il = 1, 4
     point => qum1%pnt(il)
     @assertTrue(point .eq. pts(il))
  end do

  ! self-periodic flag
  @assertFalse(qum1%self_periodic())

  ! facet boundary flag
  do il = 1, 4
     @assertEqual(qum1%fct_bnd(il), bne(il))
  end do

  ! facet gather-scatter id
  do il = 1, 4
     @assertEqual(qum1%fct_gsid(il), gse(il))
  end do

  ! ridge gather-scatter id
  do il = 1, 4
     @assertEqual(qum1%rdg_gsid(il), gsv(il))
  end do

  ! facet alignment
  do il = 1, 4
     @assertEqual(qum1%falgn(il), 0)
  end do

  ! quad diameter
  @assertEqual(qum1%diameter(), diameter, tolerance = tol)

  ! quad centre
  centroid = qum1%centroid()
  do il = 1, gdim
     @assertEqual(centroid%x(il), center(il), tolerance = tol)
  end do

  ! get facet local direction
  call qum1%fct_dir(1, il, jl)
  @assertEqual(il, 2)
  @assertEqual(jl, -1)
  call qum1%fct_dir(2, il, jl)
  @assertEqual(il, 2)
  call qum1%fct_dir(3, il, jl)
  @assertEqual(il, 1)
  call qum1%fct_dir(4, il, jl)
  @assertEqual(il, 1)

  do il =1, 4
     call vrt(il)%free()
     call edt(il)%free()
  end do
  call qum1%free()

end subroutine test_quad_mesh_simple

@test
subroutine test_quad_elm_add
  use pfunit
  use num_types, only : i4, dp
  use polytope, only : polytope_t
  use topology, only : topology_element_t
  use element_new, only : mesh_element_t
  use vertex, only : vertex_tpl_add
  use edge, only : edge_tpl_add
  use quad_new, only : fct_to_rdg, quad_elm_add
  use point, only : point_t
  implicit none
  type(topology_element_t), dimension(4) :: vrt, edg
  type(mesh_element_t) :: qad
  integer(i4) :: id, il
  integer(i4), dimension(4) :: idp, idv, ide, bne
  integer(i4), dimension(2, 3) :: rdg_hng
  integer(i4), parameter :: gdim = 3
  ! point coordinates
  real(dp), dimension(gdim, 4) :: crd = reshape((/ 0.0d0, 0.0d0, 0.0d0, &
       &  1.0d0, 0.0d0, 0.0d0,  0.0d0, 1.0d0, 0.0d0,  1.0d0, 1.0d0, 0.0d0 /), &
       & shape(crd))
  type(point_t), dimension(4) :: pts
  class(polytope_t), pointer :: poly
  type(point_t), pointer :: point

  ! points
  do il = 1, 4
     idp(il) = il + 20
     pts(il) = point_t(crd(1: 3, il), idp(il))
  end do
  ! vertices
  do il = 1, 4
     idv(il) = il
     call vertex_tpl_add(vrt(il)%obj, idv(il))
  end do
  ! edges
  do il = 1, 4
     ide(il) = il
     bne(il) = 10 + il
     call edge_tpl_add(edg(il)%obj, ide(il), bne(il), &
          &vrt(fct_to_rdg(1, il))%obj, vrt(fct_to_rdg(2, il))%obj)
  end do

  id = 100
  call quad_elm_add(qad%obj, id, &
       & edg(1)%obj, edg(2)%obj, edg(3)%obj, edg(4)%obj, &
       & 0, 0, 0, 0, .false., .false., .false., .false., 0, 0, 0, 0, &
       & 0, rdg_hng, &
       & gdim, pts(1), pts(2), pts(3), pts(4))

  ! quad dimensions
  @assertEqual(qad%obj%id(), id)
  @assertEqual(qad%obj%tdim(), 2)
  @assertTrue(qad%obj%check_comp(4, 4, 0))

  ! pointers
  ! facets
  do il = 1, 4
     poly => qad%obj%fct(il)
     @assertTrue(associated(poly))
     @assertEqual(poly%id(), ide(il))
     @assertEqual(poly%tdim(), 1)
     @assertTrue(poly%check_comp(2, 0, 0))
     @assertEqual(poly%bnd(), bne(il))
     @assertTrue(poly%equal(edg(il)%obj))
  end do
  ! ridges
  do il = 1, 4
     poly => qad%obj%rdg(il)
     @assertTrue(associated(poly))
     @assertEqual(poly%id(), idv(il))
     @assertEqual(poly%tdim(), 0)
     @assertTrue(poly%check_comp(0, 0, 0))
     @assertEqual(poly%bnd(), -1)
     @assertTrue(poly%equal(vrt(il)%obj))
  end do
  ! points
  @assertEqual(qad%obj%gdim(), gdim)
  @assertEqual(qad%obj%npts(), 4)
  do il = 1, 4
     point => qad%obj%pnt(il)
     @assertTrue(point .eq. pts(il))
  end do

  call qad%obj%free()
  deallocate(qad%obj)
  do il = 1, 4
     call edg(il)%obj%free()
     deallocate(edg(il)%obj)
  end do
  do il = 1, 4
     call vrt(il)%obj%free()
     deallocate(vrt(il)%obj)
  end do

end subroutine test_quad_elm_add

@test
subroutine test_quad_mesh_permute
  use pfunit
  use num_types, only : i4, dp
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t
  use quad_new, only : quad_elm_t
  use point, only : point_ptr, point_t
  implicit none
  type(vertex_tpl_t), dimension(4) :: vrt
  type(edge_tpl_t), dimension(8) :: edt
  type(quad_elm_t) :: qum1, qum2
  type(topology_component_t), dimension(0) :: fctv
  integer(i4), dimension(4) :: idv, gsv, idp
  integer(i4), dimension(8) :: ide, gse, bne
  integer(i4) :: il, jl, itmp, idq1
  integer(i4), dimension(4) :: permv, perme
  type(point_t), dimension(4), target :: pts
  type(point_t), pointer :: point
  type(point_ptr), dimension(4) :: ptsp
  type(point_t) :: centroid
  integer(i4), parameter :: gdim = 3
  ! point coordinates
  real(dp), dimension(gdim, 4) :: crd = reshape((/ 0.0d0, 0.0d0, 0.0d0, &
       &  1.0d0, 0.0d0, 0.0d0,  0.0d0, 1.0d0, 0.0d0,  1.0d0, 1.0d0, 0.0d0 /), &
       & shape(crd))
  integer(i4), dimension(:, :), allocatable :: facetp

  do il = 1, 4
     idv(il) = il
     gsv(il) = il + 8
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  do il = 1, 4
     idp(il) = il + 20
     pts(il) = point_t(crd(1: 3, il), idp(il))
  end do

  ! Two non self-periodic, not hanging quad
  ! first quad
  call quad_permutations(0, permv, perme)
  do il = 1, 4
     ptsp(il)%p => pts(il)
  end do
  bne(1) = 1
  bne(2) = 1
  bne(3) = 2
  bne(4) = 2
  idq1 = 1
  call quad_algn_msh_get(permv, perme, vrt(1: 4), ptsp, 0, bne(1: 4), idq1, &
       & gdim, edt(1: 4), ide(1: 4), gse(1: 4), qum1)

  ! equality with respect to various alignment
  do il = 0, 7
     call quad_permutations(il, permv, perme)
     call quad_algn_msh_get(permv, perme, vrt(1: 4), ptsp, 0, bne(1: 4), idq1, &
          & gdim, edt(5: 8), ide(5: 8), gse(5: 8), qum2)
     call quad_permutations_inv(il, permv, perme)

     !  NOT FINISHED; MISSING SORTING
!     @assertTrue(qum1%equal(qum2))

     call qum1%fct_share(qum2, itmp, facetp)
     @assertEqual(itmp, 4)
     do jl = 1, 4
        @assertEqual(facetp(1, jl), jl)
        @assertEqual(facetp(2, jl), perme(jl))
     end do
     deallocate(facetp)

     call qum1%rdg_share(qum2, itmp, facetp)
     @assertEqual(itmp, 4)
     do jl = 1, 4
        @assertEqual(facetp(1, jl), jl)
        @assertEqual(facetp(2, jl), permv(jl))
     end do
     deallocate(facetp)
  end do

  do il =1, 4
     call vrt(il)%free()
  end do
  do il =1, 8
     call edt(il)%free()
  end do
  call qum1%free()
  call qum2%free()

end subroutine test_quad_mesh_permute

@test
subroutine test_quad_mesh_share
  use pfunit
  use num_types, only : i4, dp
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t
  use quad_new, only : quad_elm_t
  use point, only : point_ptr, point_t
  implicit none
  type(vertex_tpl_t), dimension(8) :: vrt
  type(edge_tpl_t), dimension(8) :: edt
  type(quad_elm_t) :: qum1, qum2
  type(topology_component_t), dimension(0) :: fctv
  integer(i4), dimension(8) :: idv, gsv, idp
  integer(i4), dimension(8) :: ide, gse, bne
  integer(i4) :: il, jl, itmp, idq1, idq2
  integer(i4), dimension(:, :), allocatable :: facetp
  integer(i4), dimension(4) :: permv, perme
  type(point_t), dimension(8), target :: pts
  type(point_t), pointer :: point
  type(point_ptr), dimension(4) :: ptsp
  type(point_t) :: centroid
  integer(i4), parameter :: gdim = 3
  ! point coordinates
  real(dp), dimension(gdim, 8) :: crd = reshape((/ 0.0d0, 0.0d0, 0.0d0, &
       &  1.0d0, 0.0d0, 0.0d0,  0.0d0, 1.0d0, 0.0d0,  1.0d0, 1.0d0, 0.0d0, &
       &  2.0d0, 0.0d0, 0.0d0,  3.0d0, 0.0d0, 0.0d0,  2.0d0, 1.0d0, 0.0d0, &
       &  3.0d0, 1.0d0, 0.0d0 /), shape(crd))

  do il = 1, 8
     idv(il) = il
     gsv(il) = il + 8
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  do il = 1, 8
     idp(il) = il + 20
     pts(il) = point_t(crd(1: 3, il), idp(il))
  end do

  ! Two non self-periodic, not hanging, separate quads
  ! first quad
  call quad_permutations(0, permv, perme)
  do il = 1, 4
     ptsp(il)%p => pts(il)
  end do
  bne(1) = 1
  bne(2) = 1
  bne(3) = 2
  bne(4) = 2
  idq1 = 1
  call quad_algn_msh_get(permv, perme, vrt(1: 4), ptsp, 0, bne(1: 4), idq1, &
       & gdim, edt(1: 4), ide(1: 4), gse(1: 4), qum1)
  do il = 1, 4
     ptsp(il)%p => pts(il + 4)
  end do
  bne(5) = 1
  bne(6) = 1
  bne(7) = 2
  bne(8) = 2
  idq2 = 2
  call quad_algn_msh_get(permv, perme, vrt(5: 8), ptsp, 4, bne(5: 8), idq2, &
       & gdim, edt(5: 8), ide(5: 8), gse(5: 8), qum2)

  ! shared facets
  call qum1%fct_share(qum2, itmp, facetp)
  @assertEqual(itmp, 0)
  deallocate(facetp)

  ! shared ridges
  call qum1%rdg_share(qum2, itmp, facetp)
  @assertEqual(itmp, 0)
  deallocate(facetp)

  ! quad equality; NOT FINISHED; MISSING SORTING
!  @assertFalse(qum1%equal(qum2))

  do il =1, 8
     call vrt(il)%free()
     call edt(il)%free()
  end do
  call qum1%free()
  call qum2%free()

end subroutine test_quad_mesh_share




! MISSING MESH TESTS FOR EQUAL (EQUAL NOT FINALISED YET)
! MISSING MESH TESTS FOR ALIGNED FACES
! MISSING TESTS FOR NONCONFORMING VERSION




subroutine quad_permutations(algn, permv, perme)
  use num_types, only : i4
  implicit none
  integer(i4), intent(in) :: algn
  integer(i4), dimension(4), intent(out) :: permv, perme

  select case(algn)
  case(0) ! I
     permv = (/ 1, 2, 3, 4 /)
     perme = (/ 1, 2, 3, 4 /)
  case(1) ! T
     permv = (/ 1, 3, 2, 4 /)
     perme = (/ 3, 4, 1, 2 /)
  case(2) ! PX
     permv = (/ 2, 1, 4, 3 /)
     perme = (/ 2, 1, 3, 4 /)
  case(3) ! PXT
     permv = (/ 2, 4, 1, 3 /)
     perme = (/ 3, 4, 2, 1 /)
  case(4) ! PYT
     permv = (/ 3, 1, 4, 2 /)
     perme = (/ 4, 3, 1, 2 /)
  case(5) ! PY
     permv = (/ 3, 4, 1, 2 /)
     perme = (/ 1, 2, 4, 3 /)
  case(6) ! PXPYT
     permv = (/ 4, 2, 3, 1 /)
     perme = (/ 4, 3, 2, 1 /)
  case(7) ! PXPY
     permv = (/ 4, 3, 2, 1 /)
     perme = (/ 2, 1, 4, 3 /)
  end select

end subroutine quad_permutations

subroutine quad_permutations_inv(algn, permv, perme)
  use num_types, only : i4
  implicit none
  integer(i4), intent(in) :: algn
  integer(i4), dimension(4), intent(out) :: permv, perme

  select case(algn)
  case(0) ! I
     permv = (/ 1, 2, 3, 4 /)
     perme = (/ 1, 2, 3, 4 /)
  case(1) ! T
     permv = (/ 1, 3, 2, 4 /)
     perme = (/ 3, 4, 1, 2 /)
  case(2) ! PX
     permv = (/ 2, 1, 4, 3 /)
     perme = (/ 2, 1, 3, 4 /)
  case(3) ! PYT
     permv = (/ 3, 1, 4, 2 /)
     perme = (/ 4, 3, 1, 2 /)
  case(4) ! PXT
     permv = (/ 2, 4, 1, 3 /)
     perme = (/ 3, 4, 2, 1 /)
  case(5) ! PY
     permv = (/ 3, 4, 1, 2 /)
     perme = (/ 1, 2, 4, 3 /)
  case(6) ! PXPYT
     permv = (/ 4, 2, 3, 1 /)
     perme = (/ 4, 3, 2, 1 /)
  case(7) ! PXPY
     permv = (/ 4, 3, 2, 1 /)
     perme = (/ 2, 1, 4, 3 /)
  end select

end subroutine quad_permutations_inv

subroutine quad_algn_tpl_get(permv, perme, vrt, istr, bne, idq, gsq, bnq, edt, &
     & ide, gse, qut)
  use num_types, only : i4
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t, edge_ornt_t, NEKO_EDGE_NFACET
  use quad_new, only : quad_tpl_t, NEKO_QUAD_NFACET, fct_to_rdg
  implicit none
  integer(i4), dimension(4), intent(in) :: permv, perme
  type(vertex_tpl_t), dimension(4), intent(in) :: vrt
  integer(i4), intent(in) :: istr, idq, gsq, bnq
  integer(i4), dimension(4), intent(in) :: bne
  type(edge_tpl_t), dimension(4), intent(out) :: edt
  integer(i4), dimension(4), intent(out) :: ide, gse
  type(quad_tpl_t), intent(out) :: qut
  type(topology_component_t), dimension(NEKO_EDGE_NFACET) :: fcte
  type(topology_component_t), dimension(NEKO_QUAD_NFACET) :: fctq
  integer(i4) :: il, algn

  do il = 1, NEKO_QUAD_NFACET
     ide(il) = istr + il
     gse(il) = istr + il + 8
  end do
  do il = 1, NEKO_QUAD_NFACET
     allocate(vertex_ornt_t :: fcte(1)%obj)
     call fcte(1)%obj%init(vrt(permv(fct_to_rdg(1, il))), -1)
     allocate(vertex_ornt_t :: fcte(2)%obj)
     call fcte(2)%obj%init(vrt(permv(fct_to_rdg(2, il))), -1)
     call edt(il)%init(ide(perme(il)), 2, fcte, bne(perme(il)))
     call edt(il)%set_gsid(gse(perme(il)))
  end do

  ! non self-periodic quad
  ! simple edge alignment
  algn = 0
  do il = 1, 4
     allocate(edge_ornt_t :: fctq(il)%obj)
     call fctq(il)%obj%init(edt(il), algn)
  end do
  call qut%init(idq, 4, fctq, bnq)
  call qut%set_gsid(gsq)

end subroutine quad_algn_tpl_get

subroutine quad_algn_msh_get(permv, perme, vrt, pts, istr, bne, idq, gdim, &
     & edt, ide, gse, qum)
  use num_types, only : i4
  use topology, only : topology_component_t
  use element_new, only : element_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t, edge_act_t, NEKO_EDGE_NFACET
  use quad_new, only : quad_elm_t, NEKO_QUAD_NFACET, NEKO_QUAD_NRIDGE, &
       & fct_to_rdg
  use point, only : point_ptr
  implicit none
  integer(i4), dimension(4), intent(in) :: permv, perme
  type(vertex_tpl_t), dimension(4), intent(in) :: vrt
  type(point_ptr), dimension(4), intent(in) :: pts
  integer(i4), intent(in) :: istr, idq, gdim
  integer(i4), dimension(4), intent(in) :: bne
  type(edge_tpl_t), dimension(4), intent(out) :: edt
  integer(i4), dimension(4), intent(out) :: ide, gse
  type(quad_elm_t), intent(out) :: qum
  type(topology_component_t), dimension(NEKO_EDGE_NFACET) :: fcte
  type(element_component_t), dimension(NEKO_QUAD_NFACET) :: fctq
  type(point_ptr), dimension(NEKO_QUAD_NRIDGE) :: ptsl
  integer(i4) :: il, algn, hng
  logical :: ifintp
  integer(i4), dimension(2, 3) :: rdg_hng

  do il = 1, NEKO_QUAD_NFACET
     ide(il) = istr + il
     gse(il) = istr + il + 8
  end do
  do il = 1, NEKO_QUAD_NFACET
     allocate(vertex_ornt_t :: fcte(1)%obj)
     call fcte(1)%obj%init(vrt(permv(fct_to_rdg(1, il))), -1)
     allocate(vertex_ornt_t :: fcte(2)%obj)
     call fcte(2)%obj%init(vrt(permv(fct_to_rdg(2, il))), -1)
     call edt(il)%init(ide(perme(il)), 2, fcte, bne(perme(il)))
     call edt(il)%set_gsid(gse(perme(il)))
  end do

  do il = 1, NEKO_QUAD_NRIDGE
     ptsl(il)%p => pts(permv(il))%p
  end do

  ! non self-periodic quad
  ! simple edge alignment
  algn = 0
  ifintp = .false.
  hng = 0
  do il = 1, NEKO_QUAD_NFACET
     allocate(edge_act_t :: fctq(il)%obj)
     call fctq(il)%obj%init(edt(il), algn, ifintp, hng, il)
  end do
  call qum%init(idq, 4, fctq, 4, ptsl, gdim, 0, rdg_hng)

end subroutine quad_algn_msh_get
