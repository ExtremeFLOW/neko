@test
subroutine test_edge_topology_simple
  use pfunit
  use num_types, only : i4
  use polytope, only : polytope_t
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t, NEKO_EDGE_NFACET
  implicit none
  class(polytope_t), pointer :: poly
  type(vertex_tpl_t), dimension(2) :: vrt
  type(edge_tpl_t) :: edt1
  type(topology_component_t), dimension(0) :: fctv
  type(topology_component_t), dimension(NEKO_EDGE_NFACET) :: fcte
  integer(i4), dimension(2) :: idv, gsv
  integer(i4) :: il, itmp, ide1, bne1, gse1

  do il = 1, 2
     idv(il) = il
     gsv(il) = il + 4
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  ide1 = 3
  bne1 = 5
  gse1 = 11

  ! non self-periodic edge
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(1), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(2), -1)
  call edt1%init(ide1, 2, fcte, bne1)
  call edt1%set_gsid(gse1)

  ! edge dimensions
  @assertEqual(edt1%id(), ide1)
  @assertEqual(edt1%tdim(), 1)
  @assertTrue(edt1%check_comp(2, 0, 0))

  ! pointers
  ! facets
  do il = 1, 2
     poly => edt1%fct(il)
     @assertTrue(associated(poly))
     @assertEqual(poly%id(), idv(il))
     @assertEqual(poly%tdim(), 0)
     @assertTrue(poly%check_comp(0, 0, 0))
     @assertEqual(poly%bnd(), -1)
     @assertEqual(poly%gsid(), gsv(il))
     @assertTrue(poly%equal(vrt(il)))
  end do

  ! boundary
  @assertEqual(edt1%bnd(), bne1)

  ! gather-scatter id
  @assertEqual(edt1%gsid(), gse1)

  ! self-periodic flag
  @assertFalse(edt1%self_periodic())

  ! facet alignment tests
  @assertEqual(edt1%falgn(1), -1)
  @assertEqual(edt1%falgn(2), -1)

   do il =1, 2
     call vrt(il)%free()
  end do
  call edt1%free()

end subroutine test_edge_topology_simple

@test
subroutine test_edge_tpl_add
  use pfunit
  use num_types, only : i4
  use topology, only : topology_t
  use vertex, only : vertex_tpl_add
  use edge, only : edge_tpl_add
  implicit none
  class(topology_t), allocatable :: edg, vrt1, vrt2
  integer(i4) :: id, bnd

  id = 1
  call vertex_tpl_add(vrt1, id)
  id = 2
  call vertex_tpl_add(vrt2, id)

  id = 10
  bnd = 20
  call edge_tpl_add(edg, id, bnd, vrt1, vrt2)

  ! edge dimensions
  @assertEqual(edg%id(), id)
  @assertEqual(edg%bnd(), bnd)
  @assertEqual(edg%tdim(), 1)
  @assertTrue(edg%check_comp(2, 0, 0))

  call edg%free()
  call vrt1%free()
  call vrt2%free()
  deallocate(edg, vrt1, vrt2)

end subroutine test_edge_tpl_add

@test
subroutine test_edge_topology_permutation
  use pfunit
  use num_types, only : i4
  use polytope, only : polytope_t
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t, NEKO_EDGE_NFACET
  implicit none
  class(polytope_t), pointer :: poly
  type(vertex_tpl_t), dimension(2) :: vrt
  type(edge_tpl_t) :: edt1, edt2
  type(topology_component_t), dimension(0) :: fctv
  type(topology_component_t), dimension(NEKO_EDGE_NFACET) :: fcte
  integer(i4), dimension(2) :: idv, gsv
  integer(i4) :: il, itmp, ide1, bne1, gse1, ide2, bne2, gse2
  integer(i4), dimension(:, :), allocatable :: facetp

  do il = 1, 2
     idv(il) = il
     gsv(il) = il + 4
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  ide1 = 3
  bne1 = 5
  gse1 = 11
  ide2 = 4
  bne2 = 6
  gse2 = 12

  ! non self-periodic edge
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(1), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(2), -1)
  call edt1%init(ide1, 2, fcte, bne1)
  call edt1%set_gsid(gse1)

  ! second non self-periodic edge; the same edge
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(1), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(2), -1)
  call edt2%init(ide1, 2, fcte, bne1)
  call edt2%set_gsid(gse1)

  ! shared facets
  call edt1%fct_share(edt2, itmp, facetp)
  @assertEqual(itmp, 2)
  do il = 1, itmp
     @assertEqual(facetp(1, il), il)
     @assertEqual(facetp(2, il), il)
  end do
  deallocate(facetp)

  ! shared ridges; edge has no ridges
  call edt1%rdg_share(edt2, itmp, facetp)
  @assertEqual(itmp, 0)
  deallocate(facetp)

  ! edge equality
  @assertTrue(edt1%equal(edt2))

  ! second non self-periodic edge; the same edge with different alignment
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(2), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(1), -1)
  call edt2%init(ide1, 2, fcte, bne1)
  call edt2%set_gsid(gse1)

  ! shared facets
  call edt1%fct_share(edt2, itmp, facetp)
  @assertEqual(itmp, 2)
  @assertEqual(facetp(1, 1), 1)
  @assertEqual(facetp(2, 1), 2)
  @assertEqual(facetp(1, 2), 2)
  @assertEqual(facetp(2, 2), 1)
  deallocate(facetp)

  ! edge equality
  @assertTrue(edt1%equal(edt2))

   do il =1, 2
     call vrt(il)%free()
  end do
  call edt1%free()
  call edt2%free()

end subroutine test_edge_topology_permutation

@test
subroutine test_edge_topology_share
  use pfunit
  use num_types, only : i4
  use polytope, only : polytope_t
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t, NEKO_EDGE_NFACET
  implicit none
  class(polytope_t), pointer :: poly
  type(vertex_tpl_t), dimension(4) :: vrt
  type(edge_tpl_t) :: edt1, edt2
  type(topology_component_t), dimension(0) :: fctv
  type(topology_component_t), dimension(NEKO_EDGE_NFACET) :: fcte
  integer(i4), dimension(4) :: idv, gsv
  integer(i4) :: il, itmp, ide1, bne1, gse1, ide2, bne2, gse2
  integer(i4), dimension(:, :), allocatable :: facetp

  do il = 1, 4
     idv(il) = il
     gsv(il) = il + 4
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  ide1 = 3
  bne1 = 5
  gse1 = 11
  ide2 = 4
  bne2 = 6
  gse2 = 12

  ! non self-periodic edge
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(1), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(2), -1)
  call edt1%init(ide1, 2, fcte, bne1)
  call edt1%set_gsid(gse1)

  ! second non self-periodic edge; single vertex shared
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(2), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(3), -1)
  call edt2%init(ide2, 2, fcte, bne2)
  call edt2%set_gsid(gse1)

  ! shared facets
  call edt1%fct_share(edt2, itmp, facetp)
  @assertEqual(itmp, 1)
  @assertEqual(facetp(1, 1), 2)
  @assertEqual(facetp(2, 1), 1)
  deallocate(facetp)

  ! edge equality
  @assertFalse(edt1%equal(edt2))

  ! second non self-periodic edge; no vertex shared
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(3), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(4), -1)
  call edt2%init(ide2, 2, fcte, bne2)
  call edt2%set_gsid(gse1)

  ! shared facets
  call edt1%fct_share(edt2, itmp, facetp)
  @assertEqual(itmp, 0)
  deallocate(facetp)

  ! edge equality
  @assertFalse(edt1%equal(edt2))

  ! second self-periodic edge; single vertex shared
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(2), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(2), -1)
  call edt2%init(ide2, 2, fcte, bne2)
  call edt2%set_gsid(gse1)

  ! self-periodic flag
  @assertTrue(edt2%self_periodic())

  ! shared facets
  call edt1%fct_share(edt2, itmp, facetp)
  @assertEqual(itmp, 2)
  @assertEqual(facetp(1, 1), 2)
  @assertEqual(facetp(2, 1), 1)
  @assertEqual(facetp(1, 2), 2)
  @assertEqual(facetp(2, 2), 2)
  deallocate(facetp)

  ! edge equality
  @assertFalse(edt1%equal(edt2))

  do il =1, 4
     call vrt(il)%free()
  end do
  call edt1%free()
  call edt2%free()

end subroutine test_edge_topology_share

@test
subroutine test_edge_oriented_simple
  use pfunit
  use num_types, only : i4
  use polytope, only : polytope_t
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t, edge_ornt_t, NEKO_EDGE_NFACET
  implicit none
  class(polytope_t), pointer :: poly
  type(vertex_tpl_t), dimension(2) :: vrt
  type(edge_tpl_t) :: edt1
  type(edge_ornt_t) :: edo1
  type(topology_component_t), dimension(0) :: fctv
  type(topology_component_t), dimension(NEKO_EDGE_NFACET) :: fcte
  integer(i4), dimension(2) :: idv, gsv
  integer(i4) :: il, itmp, ide1, ide2, bne1, bne2, gse1, gse2, algn
  logical :: equal

  do il = 1, 2
     idv(il) = il
     gsv(il) = il + 4
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  ide1 = 3
  bne1 = 5
  gse1 = 11

  ! non self-periodic edge
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(1), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(2), -1)
  call edt1%init(ide1, 2, fcte, bne1)
  call edt1%set_gsid(gse1)

  algn = 0
  call edo1%init(edt1, algn)

  ! pointer
  call edo1%polyp(poly)
  @assertTrue(associated(poly))
  @assertEqual(poly%id(), ide1)
  @assertEqual(poly%tdim(), 1)
  @assertTrue(poly%check_comp(2, 0, 0))
  @assertEqual(poly%bnd(), bne1)
  @assertEqual(poly%gsid(), gse1)
  @assertTrue(poly%equal(edt1))

  ! alignment
  @assertFalse(edo1%ifalgn())
  @assertEqual(edo1%algn(), algn)

  ! alignment test
  @assertTrue(edo1%test(edt1))

  ! equality
  @assertTrue(edo1%equal(edt1))

  call edo1%equal_algn(edt1, equal, algn)
  @assertTrue(equal)
  @assertEqual(algn, 0)

  ! aligned edge
  algn = 1
  call edo1%init(edt1, algn)

  ! alignment
  @assertTrue(edo1%ifalgn())
  @assertEqual(edo1%algn(), 1)

  ! alignment test
  @assertFalse(edo1%test(edt1))

  ! equality
  @assertTrue(edo1%equal(edt1))

  call edo1%equal_algn(edt1, equal, algn)
  @assertTrue(equal)
  @assertEqual(algn, 0)

  do il =1, 2
     call vrt(il)%free()
  end do
  call edt1%free()
  call edo1%free()

end subroutine test_edge_oriented_simple

@test
subroutine test_edge_oriented_permute
  use pfunit
  use num_types, only : i4
  use polytope, only : polytope_t
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t, edge_ornt_t, NEKO_EDGE_NFACET
  implicit none
  class(polytope_t), pointer :: poly
  type(vertex_tpl_t), dimension(4) :: vrt
  type(edge_tpl_t) :: edt1, edt1P, edt2
  type(edge_ornt_t) :: edo1
  type(topology_component_t), dimension(0) :: fctv
  type(topology_component_t), dimension(NEKO_EDGE_NFACET) :: fcte
  integer(i4), dimension(4) :: idv, gsv
  integer(i4) :: il, itmp, ide1, ide2, bne1, bne2, gse1, gse2, algn
  logical :: equal

  do il = 1, 4
     idv(il) = il
     gsv(il) = il + 4
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  ide1 = 3
  bne1 = 5
  gse1 = 11
  ide2 = 4
  bne2 = 6
  gse2 = 12

  ! non self-periodic edge
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(1), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(2), -1)
  call edt1%init(ide1, 2, fcte, bne1)
  call edt1%set_gsid(gse1)

  ! edge with swapped vertices
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(2), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(1), -1)
  call edt1P%init(ide1, 2, fcte, bne1)
  call edt1P%set_gsid(gse1)

  ! second non self-periodic edge; no shared vertices
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(3), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(4), -1)
  call edt2%init(ide2, 2, fcte, bne2)
  call edt2%set_gsid(gse2)

  algn = 0
  call edo1%init(edt1, algn)

  ! equality
  @assertTrue(edo1%equal(edt1P))
  @assertFalse(edo1%equal(edt2))

  call edo1%equal_algn(edt1, equal, algn)
  @assertTrue(equal)
  @assertEqual(algn, 0)
  call edo1%equal_algn(edt1P, equal, algn)
  @assertTrue(equal)
  @assertEqual(algn, 1)
   call edo1%equal_algn(edt2, equal, algn)
  @assertFalse(equal)
  @assertEqual(algn, -1)

  ! alignment test
  @assertFalse(edo1%test(edt1P))
  @assertFalse(edo1%test(edt2))

  algn = 1
  call edo1%init(edt1, algn)

  call edo1%equal_algn(edt1, equal, algn)
  @assertTrue(equal)
  @assertEqual(algn, 0)
  call edo1%equal_algn(edt1P, equal, algn)
  @assertTrue(equal)
  @assertEqual(algn, 1)

  algn = 0
  call edo1%init(edt1P, algn)

  ! equality
  @assertTrue(edo1%equal(edt1))
  @assertTrue(edo1%equal(edt1P))

  call edo1%equal_algn(edt1, equal, algn)
  @assertTrue(equal)
  @assertEqual(algn, 1)
  call edo1%equal_algn(edt1P, equal, algn)
  @assertTrue(equal)
  @assertEqual(algn, 0)

  do il =1, 4
     call vrt(il)%free()
  end do
  call edt1%free()
  call edt1P%free()
  call edt2%free()
  call edo1%free()

end subroutine test_edge_oriented_permute

@test
subroutine test_edge_actualisation
  use pfunit
  use num_types, only : i4
  use polytope, only : polytope_t
  use topology, only : topology_component_t
  use vertex, only : vertex_tpl_t, vertex_ornt_t
  use edge, only : edge_tpl_t, edge_act_t, NEKO_EDGE_NFACET
  implicit none
  class(polytope_t), pointer :: poly
  type(vertex_tpl_t), dimension(4) :: vrt
  type(edge_tpl_t) :: edt1, edt1P, edt2
  type(edge_act_t) :: eda1
  type(topology_component_t), dimension(0) :: fctv
  type(topology_component_t), dimension(NEKO_EDGE_NFACET) :: fcte
  integer(i4), dimension(4) :: idv, gsv
  integer(i4) :: il, itmp, ide1, ide2, bne1, bne2, gse1, gse2, algn, hng, pos
  logical :: equal, ifintp

  do il = 1, 4
     idv(il) = il
     gsv(il) = il + 4
     call vrt(il)%init(idv(il), 0, fctv, -1)
     call vrt(il)%set_gsid(gsv(il))
  end do

  ide1 = 3
  ide2 = 4
  bne1 = 5
  bne2 = 6
  gse1 = 11
  gse2 = 12

  ! non self-periodic edge
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(1), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(2), -1)
  call edt1%init(ide1, 2, fcte, bne1)
  call edt1%set_gsid(gse1)

  ! edge with swapped vertices
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(2), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(1), -1)
  call edt1P%init(ide1, 2, fcte, bne1)
  call edt1P%set_gsid(gse1)

  ! second non self-periodic edge; no shared vertices
  allocate(vertex_ornt_t :: fcte(1)%obj)
  call fcte(1)%obj%init(vrt(3), -1)
  allocate(vertex_ornt_t :: fcte(2)%obj)
  call fcte(2)%obj%init(vrt(4), -1)
  call edt2%init(ide2, 2, fcte, bne2)
  call edt2%set_gsid(gse2)

  algn = 1
  ifintp = .true.
  hng = 2
  pos = 6
  call eda1%init(edt1, algn, ifintp, hng, pos)

  ! pointer
  call eda1%polyp(poly)
  @assertTrue(associated(poly))
  @assertEqual(poly%id(), ide1)
  @assertEqual(poly%tdim(), 1)
  @assertTrue(poly%check_comp(2, 0, 0))
  @assertEqual(poly%bnd(), bne1)
  @assertEqual(poly%gsid(), gse1)
  @assertTrue(poly%equal(edt1))

  ! alignment
  @assertTrue(eda1%ifalgn())
  @assertEqual(eda1%algn(), algn)

  ! interpolation and hanging information
  @assertTrue(eda1%ifintp())
  @assertEqual(eda1%hng(), hng)

  ! position
  @assertEqual(eda1%pos(), pos)

  ! equality
  @assertTrue(eda1%equal(edt1))
  @assertTrue(eda1%equal(edt1P))
  @assertFalse(eda1%equal(edt2))
  call eda1%equal_algn(edt1, equal, algn)
  @assertTrue(equal)
  @assertEqual(algn, 0)
  call eda1%equal_algn(edt1P, equal, algn)
  @assertTrue(equal)
  @assertEqual(algn, 1)
   call eda1%equal_algn(edt2, equal, algn)
  @assertFalse(equal)
  @assertEqual(algn, -1)

  ! alignment test
  @assertFalse(eda1%test(edt1))
  @assertTrue(eda1%test(edt1P))
  @assertFalse(eda1%test(edt2))

  do il =1, 4
     call vrt(il)%free()
  end do
  call edt1%free()
  call edt1P%free()
  call edt2%free()
  call eda1%free()

end subroutine test_edge_actualisation
