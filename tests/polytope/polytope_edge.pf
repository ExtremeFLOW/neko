@test
subroutine test_edge_init
  use pfunit
  use num_types, only : i4
  use vertex_cnn, only : vertex_cab_t, vertex_cab_ptr
  use edge_cnn, only : NEKO_EDGE_NFACET, edge_cab_t
  implicit none
  type(vertex_cab_t) :: vertex1, vertex2, vertex3, vertex4
  type(vertex_cab_ptr), dimension(NEKO_EDGE_NFACET) :: facet
  type(edge_cab_t) :: edge1, edge2
  integer(i4) :: ishare
  integer(i4), dimension(:, :), allocatable :: facetp

  call vertex1%init(1)
  call vertex2%init(2)
  call vertex3%init(3)
  call vertex4%init(4)

  ! self-periodic edge
  call edge1%init(1, vertex1, vertex1)
  @assertTrue(edge1%selfp())
  call edge1%init(1, vertex1, vertex2)
  @assertFalse(edge1%selfp())

  ! facets pointers
  call edge1%fct(facet(1), 1)
  call edge1%fct(facet(2), 2)
  @assertTrue(facet(1)%ptr.eq.vertex1)
  @assertTrue(facet(2)%ptr.eq.vertex2)
  @assertFalse(facet(2)%ptr.eq.vertex1)

  ! edge initialisation and equality
  call edge2%init(2, vertex3, vertex4)
  @assertFalse(edge1.eq.edge2)
  call edge2%init(1, vertex2, vertex1)
  @assertTrue(edge1.eq.edge2)

  ! shared facets
  ! This test is implementation dependent, so not sure how to deal with it not
  ! to make a code very complex
  call edge1%fct_share(edge1, ishare, facetp)
  @assertEqual(size(facetp, 1), 2)
  @assertEqual(size(facetp, 2), 4)
  @assertEqual(ishare, 2)
  @assertEqual(facetp(1, 1), 1)
  @assertEqual(facetp(2, 1), 1)
  @assertEqual(facetp(1, 2), 2)
  @assertEqual(facetp(2, 2), 2)
  call edge2%init(2, vertex2, vertex1)
  deallocate(facetp)
  call edge1%fct_share(edge2, ishare, facetp)
  @assertEqual(ishare, 2)
  @assertEqual(facetp(1, 1), 1)
  @assertEqual(facetp(2, 1), 2)
  @assertEqual(facetp(1, 2), 2)
  @assertEqual(facetp(2, 2), 1)
  call edge2%init(2, vertex2, vertex3)
  deallocate(facetp)
  call edge1%fct_share(edge2, ishare, facetp)
  @assertEqual(ishare, 1)
  @assertEqual(facetp(1, 1), 2)
  @assertEqual(facetp(2, 1), 1)
  @assertEqual(facetp(1, 2), 0)
  @assertEqual(facetp(2, 2), 0)
  call edge2%init(2, vertex1, vertex1)
  deallocate(facetp)
  call edge1%fct_share(edge2, ishare, facetp)
  @assertEqual(ishare, 2)
  @assertEqual(facetp(1, 1), 1)
  @assertEqual(facetp(2, 1), 1)
  @assertEqual(facetp(1, 2), 1)
  @assertEqual(facetp(2, 2), 2)
  call edge1%init(1, vertex1, vertex1)
  deallocate(facetp)
  call edge1%fct_share(edge2, ishare, facetp)
  @assertEqual(ishare, 4)
  @assertEqual(facetp(1, 1), 1)
  @assertEqual(facetp(2, 1), 1)
  @assertEqual(facetp(1, 2), 1)
  @assertEqual(facetp(2, 2), 2)
  @assertEqual(facetp(1, 3), 2)
  @assertEqual(facetp(2, 3), 1)
  @assertEqual(facetp(1, 4), 2)
  @assertEqual(facetp(2, 4), 2)
  deallocate(facetp)

end subroutine test_edge_init

@test
subroutine test_edge_eq_algn
  use pfunit
  use num_types, only : i4
  use vertex_cnn, only : vertex_cab_t
  use edge_cnn, only : edge_cab_t
  implicit none
  type(vertex_cab_t) :: vertex1, vertex2
  type(edge_cab_t) :: edge1, edge2
  logical :: equal
  integer(i4) :: algn

  ! Vertices for edges
  call vertex1%init(1)
  call vertex2%init(2)

  ! reference edge
  call edge1%init(1, vertex1, vertex2)

  ! Test transformations
  ! Identity
  call edge1%eq_algn(edge1, equal, algn)
  @assertTrue(equal)
  @assertEqual(algn, 0)
  ! Permutation
  call edge2%init(1, vertex2, vertex1)
  call edge1%eq_algn(edge2, equal, algn)
  @assertTrue(equal)
  @assertEqual(algn, 1)

end subroutine test_edge_eq_algn

@test
subroutine test_edge_alignment
  use pfunit
  use num_types, only : i4
  use vertex_cnn, only : vertex_cab_t
  use edge_cnn, only : edge_cab_t, edge_cab_ptr, edge_aligned_cab_t
  implicit none
  type(vertex_cab_t) :: vertex1, vertex2
  type(edge_cab_ptr) :: edgep
  type(edge_cab_t) :: edge1, edge2
  type(edge_aligned_cab_t) :: edgea

  call vertex1%init(1)
  call vertex2%init(2)

  call edge1%init(1, vertex1, vertex2)
  call edge2%init(1, vertex2, vertex1)
  call edgea%init_algn(edge1, 0)

  ! check pointers
  call edgea%edgep(edgep)
  @assertTrue(edgea%edge%ptr.eq.edge1)
  @assertTrue(edgep%ptr.eq.edge1)

  ! check alignment test
  @assertTrue(edgea%test(edge1))
  @assertFalse(edgea%test(edge2))

  call edgea%init_algn(edge1, 1)
  @assertTrue(edgea%test(edge2))
  @assertFalse(edgea%test(edge1))

end subroutine test_edge_alignment

@test
subroutine test_edge_3d_nonconforming
  use pfunit
  use num_types, only : i4
  use vertex_cnn, only : vertex_cab_t
  use edge_cnn, only : edge_cab_t, edge_3d_ncnf_cac_t
  implicit none
  type(vertex_cab_t) :: vertex1, vertex2
  type(edge_cab_t) :: edge
  type(edge_3d_ncnf_cac_t) :: edge_ncnf
  integer(i4) :: algn, hng, pos, itmp

  ! The abstract edge
  call vertex1%init(1)
  call vertex2%init(2)
  call edge%init(1, vertex1, vertex2)

  ! Nonconforming actualisation
  algn = 0
  pos = 1
  call edge_ncnf%init_3d(edge, algn, pos)
  @assertTrue(edge .eq. edge_ncnf%edge%ptr)
  itmp = edge_ncnf%pos()
  @assertEqual(itmp, pos)
  itmp = edge_ncnf%hng()
  @assertEqual(itmp, 0)
  hng = 1
  call edge_ncnf%set_hng(hng)
  itmp = edge_ncnf%hng()
  @assertEqual(itmp, hng)

end subroutine test_edge_3d_nonconforming

@test
subroutine test_edge_2d_nonconforming
  use pfunit
  use num_types, only : i4
  use vertex_cnn, only : vertex_cab_t
  use edge_cnn, only : edge_cab_t, edge_2d_ncnf_cac_t
  implicit none
  type(vertex_cab_t) :: vertex1, vertex2
  type(edge_cab_t) :: edge
  type(edge_2d_ncnf_cac_t) :: edge_ncnf
  integer(i4) :: algn, hng, pos, bnd, itmp

  ! The abstract edge
  call vertex1%init(1)
  call vertex2%init(2)
  call edge%init(1, vertex1, vertex2)

  ! Nonconforming actualisation
  algn = 0
  pos = 1
  bnd = 1
  call edge_ncnf%init_2d(edge, algn, pos, bnd)
  @assertTrue(edge .eq. edge_ncnf%edge%ptr)
  itmp = edge_ncnf%pos()
  @assertEqual(itmp, pos)
  itmp = edge_ncnf%bnd()
  @assertEqual(itmp, bnd)
  itmp = edge_ncnf%hng()
  @assertEqual(itmp, 0)
  hng = 1
  call edge_ncnf%set_hng(hng)
  itmp = edge_ncnf%hng()
  @assertEqual(itmp, hng)

end subroutine test_edge_2d_nonconforming
