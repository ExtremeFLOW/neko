<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Neko: User File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Neko<span id="projectnumber">&#160;1.99.2</span>
   </div>
   <div id="projectbrief">A portable framework for high-order spectral element flow simulations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d6/def/user-file.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">User File</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md160">Compiling and running</a></li>
<li class="level1"><a href="#autotoc_md161">High-level structure</a></li>
<li class="level1"><a href="#autotoc_md162">Default user functions</a><ul><li class="level2"><a href="#user-file_init-and-final">Initializing and finalizing</a></li>
<li class="level2"><a href="#user-file_user-check">Computing at every time step</a></li>
<li class="level2"><a href="#user-file_mat-prop">Setting material properties</a></li>
<li class="level2"><a href="#user-file_user-mesh-setup">Runtime mesh deformation</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md163">Case-specific user functions</a><ul><li class="level2"><a href="#user-file_user-ic">Fluid and Scalar initial conditions</a></li>
<li class="level2"><a href="#user-file_user-f">Fluid and scalar source terms</a></li>
<li class="level2"><a href="#user-file_field-dirichlet-update">Dirichlet boundary conditions</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md164">Additional remarks and tips</a><ul><li class="level2"><a href="#user-file_tips_running-on-gpus">Running on GPUs</a><ul><li class="level3"><a href="#user-file_tips_running-on-gpus-custom-kernels">Custom GPU kernels</a></li>
</ul>
</li>
<li class="level2"><a href="#user-file_tips_registries">Registries</a></li>
<li class="level2"><a href="#user-file_access">User access to solver internals</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>The user file is a fortran file where the user can implement their own functions to extend the capabilities of the default Neko executable. The user file can be used for setting advanced initial/boundary conditions, source terms, I/O operations, and interactions with the Neko framework.</p>
<p>This section will provide a written explanation of the user file, its structure, and how to compile and run it. For a more hands-on approach, see the <a class="el" href="../../d5/db5/programming-examples.html">examples</a> section, which contains several user file examples that demonstrate various aspects of programming with Neko.</p>
<h1><a class="anchor" id="autotoc_md160"></a>
Compiling and running</h1>
<p>The user file is a regular Fortran <code>.f90</code> file that needs to be compiled with <code>makeneko</code>, located in the <code>bin</code> folder of your neko installation. To compile a user file <code>user.f90</code>, run:</p>
<div class="fragment"><div class="line">makeneko user.f90</div>
</div><!-- fragment --><p>If everything goes well, you should observe the following output:</p>
<div class="fragment"><div class="line">N E K O build tool, Version 1.99.1</div>
<div class="line">(build: 2025-08-01 on x86_64-pc-linux-gnu using gnu)</div>
<div class="line">Building user NEKO ...</div>
<div class="line">Detected the module named &#39;user&#39; in user.f90</div>
<div class="line">No custom modules detected.</div>
<div class="line">No custom modules register types.</div>
<div class="line">Done!</div>
</div><!-- fragment --><p>Compiling your user file with <code>makeneko</code> will create a <code>neko</code> executable, which you will need to execute with your case file as an argument. For example, if your case file is called <code>user.case</code>:</p>
<div class="fragment"><div class="line">./neko user.case</div>
</div><!-- fragment --><p>Or in parallel using MPI:</p>
<div class="fragment"><div class="line">mpirun -n 8 ./neko user.case</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md161"></a>
High-level structure</h1>
<p>The current high-level structure of the user file is shown below.</p>
<div class="fragment"><div class="line"><span class="keyword">module</span> <a class="code hl_namespace" href="../../dc/d44/namespaceuser.html">user</a></div>
<div class="line">  <span class="keywordtype">use </span><a class="code hl_namespace" href="../../dd/d62/namespaceneko.html">neko</a></div>
<div class="line">  <span class="keywordtype">implicit none</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">contains</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">! Register user defined functions here (see user_intf.f90)</span></div>
<div class="line">  <span class="keyword">subroutine </span><a class="code hl_function" href="../../dc/d44/namespaceuser.html#a34728c151f0dbb7521a84b18b09cbd9d">user_setup</a>(user)</div>
<div class="line">    <span class="keywordtype">type</span>(user_t), <span class="keywordtype">intent(inout)</span> :: user</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">end subroutine </span><a class="code hl_function" href="../../dc/d44/namespaceuser.html#a34728c151f0dbb7521a84b18b09cbd9d">user_setup</a></div>
<div class="line"> </div>
<div class="line"><span class="keyword">end module </span>user</div>
<div class="ttc" id="anamespaceneko_html"><div class="ttname"><a href="../../dd/d62/namespaceneko.html">neko</a></div><div class="ttdoc">Master module.</div><div class="ttdef"><b>Definition</b> <a href="../../d5/d1f/neko_8f90_source.html#l00034">neko.f90:34</a></div></div>
<div class="ttc" id="anamespaceuser_html"><div class="ttname"><a href="../../dc/d44/namespaceuser.html">user</a></div><div class="ttdef"><b>Definition</b> <a href="../../d3/d6f/fields__vectors__math_8f90_source.html#l00018">fields_vectors_math.f90:18</a></div></div>
<div class="ttc" id="anamespaceuser_html_a34728c151f0dbb7521a84b18b09cbd9d"><div class="ttname"><a href="../../dc/d44/namespaceuser.html#a34728c151f0dbb7521a84b18b09cbd9d">user::user_setup</a></div><div class="ttdeci">subroutine user_setup(user)</div><div class="ttdef"><b>Definition</b> <a href="../../d3/d6f/fields__vectors__math_8f90_source.html#l00034">fields_vectors_math.f90:35</a></div></div>
</div><!-- fragment --><p>The user file implements the <code>user</code> module. This modules contains a subroutine named <code>user_setup</code>, which we use to interface the internal procedures defined in <code><a class="el" href="../../d7/d30/user__intf_8f90.html">src/common/user_intf.f90</a></code> with the subroutines that you will implement in your user file. Each user subroutine should be implemented under the <code>contains</code> statement, below <code>user_setup</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The above code snippet is the most basic code structure for the user file. Compiling it and running it would be equivalent to running the "vanilla" neko executable <code>bin/neko</code> in your local neko installation folder.</dd></dl>
<h1><a class="anchor" id="autotoc_md162"></a>
Default user functions</h1>
<p>The following user functions, if defined in the user file, will always be executed, regardless of what is set in the case file:</p>
<ul>
<li><a class="el" href="../../d6/def/user-file.html#user-file_init-and-final">startup</a>: For early access to the case file, its manipulation or initializing simple user parameter variables.</li>
<li><a class="el" href="../../d6/def/user-file.html#user-file_init-and-final">initialize</a>: For initializing most user variables and objects.</li>
<li><a class="el" href="../../d6/def/user-file.html#user-file_init-and-final">finilaze</a>: For finalizing, e.g freeing variables and terminating processes</li>
<li><a class="el" href="../../d6/def/user-file.html#user-file_user-check">compute</a>: Executed at the end of every time step, for e.g. computing and/or outputting user defined quantities.</li>
<li><a class="el" href="../../d6/def/user-file.html#user-file_user-check">preprocess</a>: Similar to <code>compute</code> but executed at the beginning of the time step.</li>
<li><a class="el" href="../../d6/def/user-file.html#user-file_mat-prop">material_properties</a>: For computing and setting material properties such as <code>rho</code>, <code>mu</code>, <code>cp</code> and <code>lambda</code>.</li>
<li><a class="el" href="../../d6/def/user-file.html#user-file_user-mesh-setup">mesh_setup</a>: For applying a deformation to the mesh element nodes, before the simulation time loop.</li>
</ul>
<h2><a class="anchor" id="user-file_init-and-final"></a>
Initializing and finalizing</h2>
<p>Three subroutines <code>startup</code>, <code>initialize</code> and <code>finalize</code> may be used to initialize/finalize any user defined variables, external objects, or processes. The <code>startup</code> routine is called immediately after the case file is read in, meaning that no important objects are initialized yet (e.g. the mesh, fluid, etc.). The <code>initialize</code> and <code>finalize</code> are respectively executed right before/after the simulation time loop.</p>
<p>In most cases, one can use <code>initialize</code> routine and not the <code>startup</code>. The latter is only necessary when you want to either manipulate the case file programmatically before it is used in the simulation, or define some variables that will be used in the constructors of some of the types. An example of the latter is defining some material property constants that can be used in the user <code>material_properties</code> routine, which is run by the constructor of the <code>casefluid</code> object.</p>
<div class="fragment"><div class="line"><span class="comment">! Manipulate the case file and define simple user variables</span></div>
<div class="line"><span class="keyword">subroutine </span>startup(params)</div>
<div class="line">  <span class="keywordtype">type</span>(json_file), <span class="keywordtype">intent(inout)</span> :: params</div>
<div class="line"> </div>
<div class="line">  <span class="comment">! insert your initialization code here</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">end subroutine </span>startup</div>
<div class="line"> </div>
<div class="line"><span class="comment">! Initialize user variables or external objects</span></div>
<div class="line"><span class="keyword">subroutine </span>initialize(time)</div>
<div class="line">  <span class="keywordtype">type</span>(time_state_t), <span class="keywordtype">intent(in)</span> :: time</div>
<div class="line"> </div>
<div class="line">  <span class="comment">! insert your initialization code here</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">end subroutine </span>initialize</div>
<div class="line"> </div>
<div class="line"><span class="comment">! Finalize user variables or external objects</span></div>
<div class="line"><span class="keyword">subroutine </span>finalize(time)</div>
<div class="line">  <span class="keywordtype">type</span>(time_state_t), <span class="keywordtype">intent(in)</span> :: time</div>
<div class="line"> </div>
<div class="line">  <span class="comment">! insert your code here</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">end subroutine </span>finalize</div>
</div><!-- fragment --><p>In the example above, the subroutines <code>startup</code>, <code>initialize</code> and <code>finalize</code> contain the actual implementations. They must also be associated to the internal procedures inside, inside <code>user_setup</code>:</p>
<div class="fragment"><div class="line"><span class="comment">! Register user defined functions (see user_intf.f90)</span></div>
<div class="line"><span class="keyword">subroutine </span>user_setup(user)</div>
<div class="line">  <span class="keywordtype">type</span>(user_t), <span class="keywordtype">intent(inout)</span> :: user</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_namespace" href="../../dc/d44/namespaceuser.html">user</a>%startup =&gt; startup</div>
<div class="line">  <a class="code hl_namespace" href="../../dc/d44/namespaceuser.html">user</a>%initialize =&gt; initialize</div>
<div class="line">  <a class="code hl_namespace" href="../../dc/d44/namespaceuser.html">user</a>%finalize =&gt; finalize</div>
<div class="line"> </div>
<div class="line"><span class="keyword">end subroutine </span>user_setup</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>All three routines are independent of each other. Using one does not require the use of the other. Moreover, the names of the routines implemented in the user file can be chosen freely, as long as they implement the correct interface.</dd></dl>
<h2><a class="anchor" id="user-file_user-check"></a>
Computing at every time step</h2>
<p>The subroutine <code>compute</code> is executed at the end of every time step. It can be used for computing and/or outputting your own variables/quantities at every time step. </p><div class="fragment"><div class="line"><span class="comment">! This is called at the end of every time step</span></div>
<div class="line"><span class="keyword">subroutine </span>user_check(time)</div>
<div class="line">  <span class="keywordtype">type</span>(time_state_t), <span class="keywordtype">intent(in)</span> :: time</div>
<div class="line"> </div>
<div class="line">  <span class="comment">! insert code below</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">end subroutine </span>user_check</div>
</div><!-- fragment --><p>In the example above, the subroutine <code>user_check</code> contains the actual implementation, as a homage to the Nek5000 routine, which served a similar purpose. As usual, the routine needs to be registered by adding:</p>
<div class="fragment"><div class="line"><a class="code hl_namespace" href="../../dc/d44/namespaceuser.html">user</a>%compute =&gt; user_check</div>
</div><!-- fragment --><p>to our <code>user_setup</code>. The <code>preprocess</code> routine can be implemented similarly.</p>
<h2><a class="anchor" id="user-file_mat-prop"></a>
Setting material properties</h2>
<p>The <code>material_properties</code> routine allows for more complex computations and setting of various material properties, such as <code>rho</code>, <code>mu</code> for the fluid and <code>cp</code>, <code>lambda</code> for the scalar. The example below is taken from the <a href="https://github.com/ExtremeFLOW/neko/blob/564686b127ff75a362a06126c6b23e9b4e21879e/examples/rayleigh_benard_cylinder/rayleigh.f90#L22C1-L38C41">rayleigh_benard_cylinder example</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">subroutine </span>material_properties(scheme_name, properties, time)</div>
<div class="line">  <span class="keywordtype">character(len=*)</span>, <span class="keywordtype">intent(in)</span> :: scheme_name</div>
<div class="line">  <span class="keywordtype">type</span>(field_list_t), <span class="keywordtype">intent(inout)</span> :: properties</div>
<div class="line">  <span class="keywordtype">type</span>(time_state_t), <span class="keywordtype">intent(in)</span> :: time</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (scheme_name .eq. <span class="stringliteral">&quot;fluid&quot;</span>) <span class="keywordflow">then</span></div>
<div class="line">     <span class="keyword">call </span>field_cfill(properties%get(<span class="stringliteral">&quot;fluid_rho&quot;</span>), 1.0_rp)</div>
<div class="line">     <span class="keyword">call </span>field_cfill(properties%get(<span class="stringliteral">&quot;fluid_mu&quot;</span>), mu)</div>
<div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (scheme_name .eq. <span class="stringliteral">&quot;temperature&quot;</span>) <span class="keywordflow">then</span></div>
<div class="line">     <span class="keyword">call </span>field_cfill(properties%get(<span class="stringliteral">&quot;temperature_cp&quot;</span>), 1.0_rp)</div>
<div class="line">     <span class="keyword">call </span>field_cfill(properties%get(<span class="stringliteral">&quot;temperature_lambda&quot;</span>), mu / pr)</div>
<div class="line"><span class="keywordflow">  end if</span></div>
<div class="line"><span class="keyword">end subroutine </span>material_properties</div>
</div><!-- fragment --><p>And of course not forgetting to register our function in <code>user_setup</code> by adding the following line:</p>
<div class="fragment"><div class="line">u%material_properties =&gt; material_properties</div>
</div><!-- fragment --><p>Note the usage of the <code>scheme_name</code> argument. This is used in several user routines, to provide the information about what solver (scheme) called the routine. In this example, we make use of it to distinguish the fluid and scalar solvers. The default scheme names are <code>fluid</code> and <code>scalar</code>, but can be controlled by the <code>name</code> entry in the JSON configuration of the solver. Here, the name for the scalar was set to <code>temperature</code>.</p>
<h2><a class="anchor" id="user-file_user-mesh-setup"></a>
Runtime mesh deformation</h2>
<p>This user function allows for the modification of the mesh at runtime, by acting on the element nodes of the mesh specified in the case file. This function is only called once before the simulation time loop. The example below is taken from the <a href="https://github.com/ExtremeFLOW/neko/blob/a0613606360240e5059e65d6d98f4a57cf73e237/examples/tgv/tgv.f90#L27-L42">tgv example</a>.</p>
<div class="fragment"><div class="line"><span class="comment">! Rescale mesh</span></div>
<div class="line"><span class="keyword">subroutine </span>user_mesh_scale(msh, time)</div>
<div class="line">  <span class="keywordtype">type</span>(mesh_t), <span class="keywordtype">intent(inout)</span> :: msh</div>
<div class="line">  <span class="keywordtype">type</span>(time_state_t), <span class="keywordtype">intent(in)</span> :: time</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">integer</span> :: i, p, nvert</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp) :: d</div>
<div class="line">  d = 4._rp</div>
<div class="line"> </div>
<div class="line">  <span class="comment">! The original mesh has size 0..8 to be mapped onto -pi..pi</span></div>
<div class="line">  <span class="comment">! will be updated later to a method giving back the vertices of the mesh</span></div>
<div class="line">  nvert = <span class="keyword">size</span>(msh%points)</div>
<div class="line">  <span class="keywordflow">do</span> i = 1, nvert</div>
<div class="line">     msh%points(i)%x(1) = (msh%points(i)%x(1) - d) / d * pi</div>
<div class="line">     msh%points(i)%x(2) = (msh%points(i)%x(2) - d) / d * pi</div>
<div class="line">     msh%points(i)%x(3) = (msh%points(i)%x(3) - d) / d * pi</div>
<div class="line"><span class="keywordflow">  end do</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">end subroutine </span>user_mesh_scale</div>
</div><!-- fragment --><p>The registering of the above function in <code>user_setup</code> should then be done as follows:</p>
<div class="fragment"><div class="line">u%mesh_setup =&gt; user_mesh_scale</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md163"></a>
Case-specific user functions</h1>
<p>As explained in the <a class="el" href="../../d1/d79/case-file_8md.html">case file</a> page, certain components of the simulation can be set to be user defined. These components and their associated user functions are:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">User function   </th><th class="markdownTableHeadNone">JSON Object in the case file    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Initial conditions   </td><td class="markdownTableBodyNone"><a class="el" href="../../d6/def/user-file.html#user-file_user-ic">initial_conditions</a>   </td><td class="markdownTableBodyNone"><code>case.fluid.initial_condition</code> or <code>case.scalar.initial_condition</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Source terms   </td><td class="markdownTableBodyNone"><a class="el" href="../../d6/def/user-file.html#user-file_user-f">source_term</a>   </td><td class="markdownTableBodyNone"><code>case.fluid.source_terms</code> or <code>case.scalar.source_terms</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Dirichlet boundary conditions   </td><td class="markdownTableBodyNone"><a class="el" href="../../d6/def/user-file.html#user-file_field-dirichlet-update">dirichlet_conditions</a>   </td><td class="markdownTableBodyNone"><code>case.fluid.boundary_types</code> or <code>case.scalar.boundary_types</code>   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>For the sake of simplicity, we refer to the setup with one scalar, i.e. <code>case.scalar</code> in the JSON. For multiple scalars, the same things apply, but the configuration is inside each individual element of <code>case.scalars</code>. In the case of multiple scalars, users should use <code>"checkpoint_format": "hdf5"</code> when enabling checkpointing.</dd></dl>
<h2><a class="anchor" id="user-file_user-ic"></a>
Fluid and Scalar initial conditions</h2>
<p>Enabling user defined initial conditions for the fluid and/or scalar is done by setting the <code>initial_condition.type</code> to <code>"user"</code> in the relevant sections of the case file, <code>case.fluid</code> and/or <code>case.scalar</code>.</p>
<div class="fragment"><div class="line">&quot;case&quot;: {</div>
<div class="line">    &quot;fluid&quot;: {</div>
<div class="line">        &quot;initial_condition&quot;: {</div>
<div class="line">            &quot;type&quot;: &quot;user&quot;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>See the relevant sections on the <a class="el" href="../../dd/d33/case-file.html#case-file_fluid-ic">fluid</a> and <a class="el" href="../../dd/d33/case-file.html#case-file_scalar">scalar</a> initial conditions in the <a class="el" href="../../dd/d33/case-file.html">case file page</a> for more details.</p>
<p>The associated user function for initial conditions must then be added to the user file. An example for the fluid taken from the <a href="https://github.com/ExtremeFLOW/neko/blob/aa72ad9bf34cbfbac0ee893c045639fdd095f80a/examples/scalar_mms/scalar_mms.f90#L55-L79">advecting cone example</a>, is shown below.</p>
<div class="fragment"><div class="line"><span class="keyword">subroutine </span>initial_conditions(scheme_name, fields)</div>
<div class="line">  <span class="keywordtype">character(len=*)</span>, <span class="keywordtype">intent(in)</span> :: scheme_name</div>
<div class="line">  <span class="keywordtype">type</span>(field_list_t), <span class="keywordtype">intent(inout)</span> :: fields</div>
<div class="line">  <span class="keywordtype">integer</span> :: i, e, k, j</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp) :: x, y</div>
<div class="line">  <span class="keywordtype">type</span> (field_t), <span class="keywordtype">pointer</span> :: u, v, w, s</div>
<div class="line">  <span class="keywordtype">type</span>(dofmap_t), <span class="keywordtype">pointer</span> :: dof</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (scheme_name .eq. <span class="stringliteral">&#39;fluid&#39;</span>) <span class="keywordflow">then</span></div>
<div class="line">     u =&gt; fields%get(<span class="stringliteral">&quot;u&quot;</span>)</div>
<div class="line">     v =&gt; fields%get(<span class="stringliteral">&quot;v&quot;</span>)</div>
<div class="line">     w =&gt; fields%get(<span class="stringliteral">&quot;w&quot;</span>)</div>
<div class="line"> </div>
<div class="line">     <span class="keyword">call </span>field_rone(u)</div>
<div class="line">     <span class="keyword">call </span>field_rzero(v)</div>
<div class="line">     <span class="keyword">call </span>field_rzero(w)</div>
<div class="line">  <span class="keywordflow">else</span> <span class="comment">!scalar</span></div>
<div class="line">     s =&gt; fields%get(scheme_name)</div>
<div class="line">     <span class="keywordflow">if</span> (scheme_name .eq. <span class="stringliteral">&#39;s1&#39;</span>) <span class="keywordflow">then</span></div>
<div class="line">        <span class="keywordflow">do</span> i = 1, s%dof%size()</div>
<div class="line">           x = s%dof%x(i,1,1,1)</div>
<div class="line">           y = s%dof%y(i,1,1,1)</div>
<div class="line">           s%x(i,1,1,1) = sin(x)</div>
<div class="line"><span class="keywordflow">        end do</span></div>
<div class="line"><span class="keywordflow">     end if</span></div>
<div class="line"><span class="keywordflow">  end if</span></div>
<div class="line"><span class="keyword">end subroutine </span>initial_conditions</div>
</div><!-- fragment --><p>Not again the usage of <code>scheme_name</code> to distinguish between the fluid and the scalar. Depending on the scheme, the contents of the field list <code>fields</code> changes, and we extract individual fields via field pointers accordingly. The incompressible fluid solver always generates solution fields, <code>u</code>, <code>v</code> and <code>w</code>. For the scalar, the name of the field coincides with <code>scheme_name</code>. For single scalar cases, this defaults to <code>s</code>. For multiple scalar cases, the field name is set to the scalar name specified in the JSON configuration (e.g., "s1", "s2", etc.).</p>
<dl class="section note"><dt>Note</dt><dd>Notice that the code for the scalar runs on the CPU. There is no need to add the transfer to GPU memory in this user routine, it will be done under the hood afterwards.</dd></dl>
<p>We should also add of the following lines in <code>user_setup</code>, as usual.</p>
<div class="fragment"><div class="line"><a class="code hl_namespace" href="../../dc/d44/namespaceuser.html">user</a>%initial_condtions =&gt; initial_conditions.</div>
</div><!-- fragment --><h2><a class="anchor" id="user-file_user-f"></a>
Fluid and scalar source terms</h2>
<p>Enabling user defined source terms for the fluid and/or scalar is done by adding JSON Objects to the <code>case.fluid.source_terms</code> and/or <code>case.scalar.source_terms</code> lists.</p>
<div class="fragment"><div class="line">&quot;case&quot;: {</div>
<div class="line">    &quot;fluid&quot;: {</div>
<div class="line">        &quot;source_terms&quot;:</div>
<div class="line">        [</div>
<div class="line">            {</div>
<div class="line">                &quot;type&quot;: &quot;user&quot;</div>
<div class="line">            }</div>
<div class="line">        ]</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>See the relevant sections on the <a class="el" href="../../dd/d33/case-file.html#case-file_fluid-source-term">fluid</a> and <a class="el" href="../../dd/d33/case-file.html#case-file_scalar">scalar</a> source terms in the [case file page](<a class="el" href="../../dd/d33/case-file.html">Case File</a>) for more details.</p>
<p>The associated user functions for the fluid and/or scalar source terms can then be added to the user file. An example for the fluid, taken from the <code>scalar_mms</code> example, is shown below.</p>
<div class="fragment"><div class="line"><span class="keyword">subroutine </span><a class="code hl_namespace" href="../../de/de7/namespacesource__term.html">source_term</a>(scheme_name, rhs, time)</div>
<div class="line">  <span class="keywordtype">character(len=*)</span>, <span class="keywordtype">intent(in)</span> :: scheme_name</div>
<div class="line">  <span class="keywordtype">type</span>(field_list_t), <span class="keywordtype">intent(inout)</span> :: rhs</div>
<div class="line">  <span class="keywordtype">type</span>(time_state_t), <span class="keywordtype">intent(in)</span> :: time</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp) :: x</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">pointer</span> :: f</div>
<div class="line">  <span class="keywordtype">integer</span> :: i</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (scheme_name .eq. <span class="stringliteral">&#39;fluid&#39;</span>) <span class="keywordflow">return</span></div>
<div class="line"> </div>
<div class="line">  f =&gt; rhs%items(1)%ptr</div>
<div class="line">  <span class="keywordflow">do</span> i = 1, f%size()</div>
<div class="line">     x = f%dof%x(i,1,1,1)</div>
<div class="line"> </div>
<div class="line">     <span class="comment">! 0.01 is the viscosity</span></div>
<div class="line">     f%x(i,1,1,1) = cos(x) - 0.01 * sin(x) - 1.0_rp</div>
<div class="line"><span class="keywordflow">  end do</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (neko_bcknd_device .eq. 1) <span class="keywordflow">then</span></div>
<div class="line">     <span class="keyword">call </span>device_memcpy(f%x, f%x_d, f%size(), &amp;</div>
<div class="line">          host_to_device, sync=.false.)</div>
<div class="line"><span class="keywordflow">  end if</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">end subroutine </span>source_term</div>
<div class="ttc" id="anamespacesource__term_html"><div class="ttname"><a href="../../de/de7/namespacesource__term.html">source_term</a></div><div class="ttdoc">Implements the source_term_t type and a wrapper source_term_wrapper_t.</div><div class="ttdef"><b>Definition</b> <a href="../../df/d69/source__term_8f90_source.html#l00034">source_term.f90:34</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Notice the use of the <code>NEKO_BCKND_DEVICE</code> flag, which will be set to 1 if running on GPUs, and the use of <code>device_</code> functions. See [Running on GPUs](<a class="el" href="../../d6/def/user-file.html#user-file_tips_running-on-gpus">Running on GPUs</a>) for more information on how this works.</dd></dl>
<p>As usual, we point the user routine to our implementation in <code>user_setup</code>.</p>
<div class="fragment"><div class="line"><a class="code hl_namespace" href="../../dc/d44/namespaceuser.html">user</a>%source_term =&gt; <a class="code hl_namespace" href="../../de/de7/namespacesource__term.html">source_term</a></div>
</div><!-- fragment --><h2><a class="anchor" id="user-file_field-dirichlet-update"></a>
Dirichlet boundary conditions</h2>
<p>This user function can be used to specify Dirichlet boundary values for velocity components <code>u,v,w</code>, the pressure <code>p</code>, and/or the scalar(s). This type of boundary condition allows for time-dependent velocity profiles or non-uniform pressure profiles to e.g. impose an outlet pressure computed from another simulation.</p>
<p>The user routine is called by the <code>user_velocity</code> and <code>user_pressure</code> boundary conditions for the fluid, and the <code>user</code> boundary condtition for the scalar. Once the appropriate boundaries have been identified, the user function <code>dirichlet_conditions</code> should be used to compute and apply the desired values to our velocity/pressure/scalar field(s).</p>
<p>The structure of the interface is very similar to e.g. the initial conditions. One gets a list of solution fields, the contents of which depends on what scheme owns the boundary condition. For <code>user_velocity</code>, it will be a list of 3 fields with names <code>u</code>, <code>v</code>, <code>w</code>; For <code>user_pressure</code>, a list with a single field <code>p</code>; For the scalar, also a single field with the same name as the solution field for the scalar (<code>s</code> by default).</p>
<p>It is crucial to understand that all three boundary condition will call the same routine! So, if one has, for example, both <code>user_velocity</code> for the fluid and <code>user</code> for the scalar, it is necessary to have an <code>if</code> statement in the user routine to distinguish between the two cases. The convenient way to do that is to check the size of the passed field list and the names of the fields inside. For example, if there is one field and it is called <code>s</code>, one executes the code setting the boundary values for the scalar <code>s</code>.</p>
<p>Note that the fields that one manipulates in the user routine are not the actual velocity fields, etc. Instead, the code does a masked copy from the dummy fields manipulated in the user routine to the actual fields of unknowns, with the mask corresponding to the boundary faces. So, even if you somehow manipulate the fields elsewhere in the domain inside the user routine, that will not affect the solution.</p>
<p>In the following example, we indicate in <code>case.fluid.boundary_conditions</code> that we would like to apply a velocity profile on the boundary number 1 (in this case, the inlet boundary). On boundary number 2 (the outlet boundary), we change the pressure. In <code>case.scalar.boundary_conditions</code>, we indicate the same for the scalar on boundaries 1 and 2 (inlet and outlet).</p>
<p>The header of the user function is given in the code snippet below.</p>
<div class="fragment"><div class="line"><span class="keyword">subroutine </span>dirichlet_update(fields, bc, time)</div>
<div class="line">  <span class="keywordtype">type</span>(field_list_t), <span class="keywordtype">intent(inout)</span> :: fields</div>
<div class="line">  <span class="keywordtype">type</span>(field_dirichlet_t), <span class="keywordtype">intent(inout)</span> :: bc</div>
<div class="line">  <span class="keywordtype">type</span>(time_state_t) :: time</div>
</div><!-- fragment --><p>The arguments and their purpose are as follows:</p>
<ul>
<li><code>fields</code> is the list of the fields that can be edited. It is a list of <code>field_t</code> objects.<ul>
<li>The field <code>i</code> contained in <code>fields</code> is accessed using <code>fields%items(i)%ptr</code> and will refer to a <code>field_t</code> object. Alternatively, one can use the <code>get</code> method to retrieve a field by name or index, as done in the examples above for other routines.</li>
</ul>
</li>
<li><code>bc</code> contains a <code>field_dirichlet_t</code> object to help access the boundary indices through the boundary mask, <code>msk</code>.<ul>
<li>The boundary mask of the <code>bc</code>object is accessed via <code>bc%msk</code>. It contains the linear indices of each GLL point on the boundary facets. <dl class="section note"><dt>Note</dt><dd><code>msk(0)</code> contains the size of the array. The first boundary index is <code>msk(1)</code>.</dd></dl>
</li>
</ul>
</li>
<li><code>time</code>, is a simple structure that contains various info on time stepping, notably, the current time iteration and time value.</li>
</ul>
<p>Links to the documentation to learn more about what the types mentioned above contain and how to use them: <code><a class="el" href="../../d3/dc1/field_8f90.html">src/field/field.f90</a></code>, <code><a class="el" href="../../df/df6/bc_8f90.html">src/bc/bc.f90</a></code>.</p>
<p>The user function should be registered in <code>user_setup</code> with the following line:</p>
<div class="fragment"><div class="line">u%dirichlet_conditions =&gt; dirichlet_update</div>
</div><!-- fragment --><p>A very simple example illustrating the above is shown below, which is taken from the <a href="https://github.com/ExtremeFLOW/neko/blob/feature/field_bcs/examples/cyl_boundary_layer/cyl_bl.f90">cyl_boundary_layer example</a></p>
<div class="fragment"><div class="line"><span class="keyword">subroutine </span>dirichlet_update(fields, bc, time)</div>
<div class="line">  <span class="keywordtype">type</span>(field_list_t), <span class="keywordtype">intent(inout)</span> :: fields</div>
<div class="line">  <span class="keywordtype">type</span>(field_dirichlet_t), <span class="keywordtype">intent(in)</span> :: bc</div>
<div class="line">  <span class="keywordtype">type</span>(time_state_t), <span class="keywordtype">intent(in)</span> :: time</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">integer</span> :: i</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp) :: y,z</div>
<div class="line"> </div>
<div class="line">  <span class="comment">! Only do this at the first time step since our BCs are constant in time.</span></div>
<div class="line">  <span class="keywordflow">if</span> (tstep .ne. 1) <span class="keywordflow">return</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">! Check that we are being called by the fluid via the name of the field</span></div>
<div class="line">  <span class="keywordflow">if</span> (fields%items(1)%ptr%name .eq. <span class="stringliteral">&quot;u&quot;</span>) <span class="keywordflow">then</span></div>
<div class="line"> </div>
<div class="line">     associate(u =&gt; field_bc_list%items(1)%ptr, &amp;</div>
<div class="line">               v =&gt; field_bc_list%items(2)%ptr, &amp;</div>
<div class="line">               w =&gt; field_bc_list%items(3)%ptr)</div>
<div class="line">       <span class="comment">!</span></div>
<div class="line">       <span class="comment">! Perform operations on u%x, v%x, w%x here</span></div>
<div class="line">       <span class="comment">! Here we are applying very simple uniform boundaries (u,v,w) = (1,0,0)</span></div>
<div class="line">       <span class="comment">! Technically the values are put in the interior as well, but this</span></div>
<div class="line">       <span class="comment">! does not matter, only the boundary values will be copied to the</span></div>
<div class="line">       <span class="comment">! actual fields</span></div>
<div class="line">       u = 1.0_rp</div>
<div class="line">       v = 0.0_rp</div>
<div class="line">       w = 0.0_rp</div>
<div class="line"> </div>
<div class="line">     <span class="keyword">end </span>associate</div>
<div class="line"> </div>
<div class="line">  <span class="comment">! Check that we are being called by the user_pressure bc via the name</span></div>
<div class="line">  <span class="comment">! of the field</span></div>
<div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fields%items(1)%ptr%name .eq. <span class="stringliteral">&quot;p&quot;</span>) <span class="keywordflow">then</span></div>
<div class="line">     associate( p =&gt; fields%items(1)%ptr)</div>
<div class="line">       <span class="comment">!</span></div>
<div class="line">       <span class="comment">! Perform operations on the pressure field here</span></div>
<div class="line">       <span class="comment">!</span></div>
<div class="line"> </div>
<div class="line">       <span class="keywordflow">do</span> i = 1, <a class="code hl_namespace" href="../../d0/dc0/namespacebc.html">bc</a>%msk(0)</div>
<div class="line">          p%x(<a class="code hl_namespace" href="../../d0/dc0/namespacebc.html">bc</a>%msk(i), 1, 1, 1) = -1</div>
<div class="line"><span class="keywordflow">       end do</span></div>
<div class="line"> </div>
<div class="line">     <span class="keyword">end </span>associate</div>
<div class="line"> </div>
<div class="line">  <span class="comment">! Check that we are being called by the scalar via the name of the field</span></div>
<div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fields%items(1)%ptr%name .eq. <span class="stringliteral">&quot;s&quot;</span>) <span class="keywordflow">then</span></div>
<div class="line"> </div>
<div class="line">     associate( s =&gt; field_bc_list%items(1)%ptr)</div>
<div class="line">       <span class="comment">!</span></div>
<div class="line">       <span class="comment">! Perform operations on the scalar field here</span></div>
<div class="line">       <span class="comment">!</span></div>
<div class="line"> </div>
<div class="line">       <span class="keywordflow">do</span> i = 1, <a class="code hl_namespace" href="../../d0/dc0/namespacebc.html">bc</a>%msk(0)</div>
<div class="line">          y = <a class="code hl_namespace" href="../../d0/dc0/namespacebc.html">bc</a>%dof%y(<a class="code hl_namespace" href="../../d0/dc0/namespacebc.html">bc</a>%msk(i), 1, 1, 1)</div>
<div class="line">          z = <a class="code hl_namespace" href="../../d0/dc0/namespacebc.html">bc</a>%dof%z(<a class="code hl_namespace" href="../../d0/dc0/namespacebc.html">bc</a>%msk(i), 1, 1, 1)</div>
<div class="line">          s%x(<a class="code hl_namespace" href="../../d0/dc0/namespacebc.html">bc</a>%msk(i), 1, 1, 1) = sin(y)*sin(z)</div>
<div class="line"><span class="keywordflow">       end do</span></div>
<div class="line"> </div>
<div class="line">     <span class="keyword">end </span>associate</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">  end if</span></div>
<div class="line"><span class="keyword">end subroutine </span>dirichlet_update</div>
<div class="ttc" id="anamespacebc_html"><div class="ttname"><a href="../../d0/dc0/namespacebc.html">bc</a></div><div class="ttdoc">Defines a boundary condition.</div><div class="ttdef"><b>Definition</b> <a href="../../df/df6/bc_8f90_source.html#l00034">bc.f90:34</a></div></div>
</div><!-- fragment --><p>This example is applying constant dirichlet values at the selected boundaries for the velocity components and presure. The scalar is applied a function <code>s(y,z) = sin(y)*sin(z)</code> to demonstrate the usage of boundary masks.</p>
<dl class="section attention"><dt>Attention</dt><dd>The notation <code>u = 1.0_rp</code> is only possible because of the overloading of the assignement operator <code>=</code> in <code>field_t</code>. In general, a field's array should be accessed and modified with <code>u%x</code>.</dd></dl>
<p>Note that we are only applying our boundary values at the first timestep, which is done simply with the line <code>if (timetstep .ne. 1) return</code>. This is a trick that can be used for time-independent boundary profiles that require some kind of time consuming operation like interpolation or reading from a file, which would add overhead if executed at every time step.</p>
<dl class="section attention"><dt>Attention</dt><dd>All the rules for [Running on GPUs](<a class="el" href="../../d6/def/user-file.html#user-file_tips_running-on-gpus">Running on GPUs</a>) apply when working on field arrays. Use <code>device_memcpy</code> to make sure the device arrays are also updated.</dd></dl>
<h1><a class="anchor" id="autotoc_md164"></a>
Additional remarks and tips</h1>
<h2><a class="anchor" id="user-file_tips_running-on-gpus"></a>
Running on GPUs</h2>
<p>When running on GPUs, special care must be taken when using certain user functions. The short explanation is that the device (GPU) has its own memory and cannot directly access the memory on the host (CPU). This means that data and more specifically arrays must be copied manually from the host to the device (see <a class="el" href="../../d6/dac/interfacedevice_1_1device__memcpy.html" title="Copy data between host and device (or device and device)">device::device_memcpy</a>).</p>
<dl class="section attention"><dt>Attention</dt><dd>In some cases, data transfer via <code>device_memcpy</code> is avoidable. Neko has some device math functions implemented that operate directly on device arrays. If you can decompose whatever operations you are performing in a user function into a set of instructions from the <code>math</code> module (e.g. <code>cadd</code>, <code>cfill</code>, <code>sub2</code>, ...), you may use the corresponding <code><a class="el" href="../../d2/d73/namespacedevice__math.html">device_math</a></code> functions to <a class="el" href="../../de/d06/accelerators.html#accelerators_offload-work">offload work to the GPU</a>. Additionally, when you operate on <code>field_t</code> objects (which is very common), you can use routines in the <code><a class="el" href="../../d5/de6/namespacefield__math.html">field_math</a></code> module, that will automatically run on the right backend. This is highly recommended and avoids <code>if</code> statements.</dd></dl>
<p>An example where manual transfer to the GPU was necessary has already been given for the source term. It is reiterated below.</p>
<div class="fragment"><div class="line"><span class="keyword">subroutine </span><a class="code hl_namespace" href="../../de/de7/namespacesource__term.html">source_term</a>(scheme_name, rhs, time)</div>
<div class="line">  <span class="keywordtype">character(len=*)</span>, <span class="keywordtype">intent(in)</span> :: scheme_name</div>
<div class="line">  <span class="keywordtype">type</span>(field_list_t), <span class="keywordtype">intent(inout)</span> :: rhs</div>
<div class="line">  <span class="keywordtype">type</span>(time_state_t), <span class="keywordtype">intent(in)</span> :: time</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp) :: x</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">pointer</span> :: f</div>
<div class="line">  <span class="keywordtype">integer</span> :: i</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (scheme_name .eq. <span class="stringliteral">&#39;fluid&#39;</span>) <span class="keywordflow">return</span></div>
<div class="line"> </div>
<div class="line">  f =&gt; rhs%items(1)%ptr</div>
<div class="line">  <span class="keywordflow">do</span> i = 1, f%size()</div>
<div class="line">     x = f%dof%x(i,1,1,1)</div>
<div class="line"> </div>
<div class="line">     <span class="comment">! 0.01 is the viscosity</span></div>
<div class="line">     f%x(i,1,1,1) = cos(x) - 0.01 * sin(x) - 1.0_rp</div>
<div class="line"><span class="keywordflow">  end do</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (neko_bcknd_device .eq. 1) <span class="keywordflow">then</span></div>
<div class="line">     <span class="keyword">call </span>device_memcpy(f%x, f%x_d, f%size(), &amp;</div>
<div class="line">          host_to_device, sync=.false.)</div>
<div class="line"><span class="keywordflow">  end if</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">end subroutine </span>source_term</div>
</div><!-- fragment --><p>Note that <code>f%x</code> is the field's data on the CPU. Therefore, to populate the correspoding array on GPU, we need to call to <code>device_memcpy</code>. Looking at the detailof the <code>device_memcpy</code> call, we note the following:</p><ul>
<li>Device arrays are refered to by appending the suffix <code>_d</code> to the host array variable name (e.g. <code>f%x</code> and <code>f%x_d</code>). This is the standard in Neko.</li>
<li>We specify the direction of the data movement with the flag <code>HOST_TO_DEVICE</code>. Other flags can also be used to move data from device to host (<code>DEVICE_TO_HOST</code>) or device to device (<code>DEVICE_TO_DEVICE</code>). See the <a class="el" href="../../de/d06/accelerators.html#accelerators_data-transfer">accelerators page</a> for more details on this.</li>
<li>The <code>sync</code> argument is a non-optional argument which dictates wether or not to perform the data transfer synchronously.</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>Use asynchronous data transfers at your own risk! If you are unsure, use <code>sync = .true.</code> as a starting point.</dd></dl>
<p>Finally, observe that we use the flag <code>NEKO_BCKND_DEVICE</code> to check if we are indeed running on GPUs. In that case, <code>NEKO_BCKND_DEVICE</code> would be equal to 1.</p>
<h3><a class="anchor" id="user-file_tips_running-on-gpus-custom-kernels"></a>
Custom GPU kernels</h3>
<p>When running on GPUs it is possible to call an own custom kernel. This could be more performant for more complex source terms or boundary conditions.</p>
<p>Assume we have a custom kernel called <code>mydevice_kernel</code> in a CUDA file called <code>mykernel.cu</code>, to set the initial velicity field. To call the custom kernel, the user file must define a C interface to the routine (inside the <code>.cu</code> file) that launches the kernel</p>
<div class="fragment"><div class="line"><span class="keyword">interface</span></div>
<div class="line">  <span class="keyword">subroutine </span>mydevice_kernel(u_d, v_d, w_d, n) &amp;</div>
<div class="line">        bind(c, name = <span class="stringliteral">&#39;mydevice_kernel&#39;</span>)</div>
<div class="line">    use, <span class="keywordtype">intrinsic</span> :: iso_c_binding, only: c_int, c_ptr</div>
<div class="line">    <span class="keywordtype">type</span>(c_ptr), <span class="keywordtype">value</span> :: u_d, v_d, w_d</div>
<div class="line">    <span class="keywordtype">integer(c_int)</span> :: n</div>
<div class="line">  <span class="keyword">end subroutine </span>mydevice_kernel</div>
<div class="line"><span class="keyword">end interface</span></div>
</div><!-- fragment --><p>Furthermore, the CUDA/HIP file must allow for C linkage, hence the routine <code>mydevice_kernel</code> must be inside an <code>extern "C"</code> block.</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="../../db/d11/cuda_2dirichlet__kernel_8h.html#ac2cb217184f95ca86456f610f72bd533">mydevice_kernel</a>(<span class="keywordtype">void</span> *<a class="code hl_variable" href="../../d0/d7e/cuda_2ax__helm__full__kernel_8h.html#a7c8003e3422abb0b6eec11f6ebf6e6fb">u</a>, <span class="keywordtype">void</span> *<a class="code hl_variable" href="../../d0/d7e/cuda_2ax__helm__full__kernel_8h.html#ad44828fa187c7f6962d8ef80a111c535">v</a>, <span class="keywordtype">void</span> *<a class="code hl_variable" href="../../d0/d7e/cuda_2ax__helm__full__kernel_8h.html#a43799c7789aa82c19649dc9f75f8a87f">w</a>, <span class="keywordtype">int</span> *n) {</div>
<div class="line">    <span class="comment">/* Launch the device kernel here */</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="acuda_2ax__helm__full__kernel_8h_html_a43799c7789aa82c19649dc9f75f8a87f"><div class="ttname"><a href="../../d0/d7e/cuda_2ax__helm__full__kernel_8h.html#a43799c7789aa82c19649dc9f75f8a87f">w</a></div><div class="ttdeci">__global__ void T *__restrict__ T *__restrict__ const T *__restrict__ const T *__restrict__ const T *__restrict__ w</div><div class="ttdef"><b>Definition</b> <a href="../../d0/d7e/cuda_2ax__helm__full__kernel_8h_source.html#l00048">ax_helm_full_kernel.h:48</a></div></div>
<div class="ttc" id="acuda_2ax__helm__full__kernel_8h_html_a7c8003e3422abb0b6eec11f6ebf6e6fb"><div class="ttname"><a href="../../d0/d7e/cuda_2ax__helm__full__kernel_8h.html#a7c8003e3422abb0b6eec11f6ebf6e6fb">u</a></div><div class="ttdeci">__global__ void T *__restrict__ T *__restrict__ const T *__restrict__ u</div><div class="ttdef"><b>Definition</b> <a href="../../d0/d7e/cuda_2ax__helm__full__kernel_8h_source.html#l00046">ax_helm_full_kernel.h:46</a></div></div>
<div class="ttc" id="acuda_2ax__helm__full__kernel_8h_html_ad44828fa187c7f6962d8ef80a111c535"><div class="ttname"><a href="../../d0/d7e/cuda_2ax__helm__full__kernel_8h.html#ad44828fa187c7f6962d8ef80a111c535">v</a></div><div class="ttdeci">__global__ void T *__restrict__ T *__restrict__ const T *__restrict__ const T *__restrict__ v</div><div class="ttdef"><b>Definition</b> <a href="../../d0/d7e/cuda_2ax__helm__full__kernel_8h_source.html#l00047">ax_helm_full_kernel.h:47</a></div></div>
<div class="ttc" id="acuda_2dirichlet__kernel_8h_html_ac2cb217184f95ca86456f610f72bd533"><div class="ttname"><a href="../../db/d11/cuda_2dirichlet__kernel_8h.html#ac2cb217184f95ca86456f610f72bd533">dirichlet_apply_scalar_kernel</a></div><div class="ttdeci">__global__ void dirichlet_apply_scalar_kernel(const int *__restrict__ msk, T *__restrict__ x, const T g, const int m)</div><div class="ttdef"><b>Definition</b> <a href="../../db/d11/cuda_2dirichlet__kernel_8h_source.html#l00042">dirichlet_kernel.h:42</a></div></div>
</div><!-- fragment --><p> The user defined routine for initial conditions calls the kernel in the following way.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">subroutine </span>set_velocity(u, v, w, p, params)</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">intent(inout)</span> :: u</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">intent(inout)</span> :: v</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">intent(inout)</span> :: w</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">intent(inout)</span> :: p</div>
<div class="line">  <span class="keywordtype">type</span>(json_file), <span class="keywordtype">intent(inout)</span> :: params</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (neko_bcknd_device .eq. 1) <span class="keywordflow">then</span></div>
<div class="line">     <span class="keyword">call </span>mydevice_kernel(u%x_d, v%x_d, w%x_d, u%dof%size())</div>
<div class="line"><span class="keywordflow">  endif</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">end subroutine </span>set_velocity</div>
</div><!-- fragment --><p>Finally, compile using <code>makeneko</code> and provide both the <code>user.f90</code> and <code>mykernel.cu</code> file.</p>
<div class="fragment"><div class="line">makeneko user.f90 mykernel.cu</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><code>makeneko</code> does currently only support custom kernels written in CUDA or HIP.</dd></dl>
<h2><a class="anchor" id="user-file_tips_registries"></a>
Registries</h2>
<p>Neko uses the concept of <code>registry</code> as a practical way to retrieve fields and point zones anywhere in the user file.</p>
<p>The registry <code>neko_registry</code> is often used in user functions where certain fields are not directly accessible as arguments. One can retrieve any field in the registry by its <code>name</code> with <code>neko_registry%get_field(name)</code>. Default fields that are added to the registry are <code>u,v,w,p</code> and <code>s</code> if running with the scalar enabled. For a practical example of usage, see the <a href="https://github.com/ExtremeFLOW/neko/blob/49925b7a04a638259db3b1ddd54349ca57f5d207/examples/rayleigh_benard/rayleigh.f90#L102-L105">rayleigh benard example</a></p>
<p>Other fields may be added to the registry by various simulation components. For example:</p><ul>
<li>If running with <code>simulation_components.vorticity</code> enabled, the fields <code>omega_x, omega_y, omega_z</code> will be accessible in the registry.</li>
<li>If running with <code>simulation_components.lambda2</code> enabled, the field <code><a class="el" href="../../d0/d66/namespacelambda2.html" title="A simulation component that computes lambda2 The values are stored in the field registry under the na...">lambda2</a></code> will be accessible in the registry.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>You can add your own fields to the registry with <code>neko_registry%add_field</code> (see registry::field_add).</dd></dl>
<p>The point zone registry, <code>neko_point_zone_registry</code>, can be used to retrieve pointers to <code>point_zone_t</code> objects defined in the case file. See <a class="el" href="../../da/dd0/point-zones.html#point-zones_using-point-zones">using point zones</a> for detailed instructions.</p>
<h2><a class="anchor" id="user-file_access"></a>
User access to solver internals</h2>
<p>Neko proives a special variable called <code>neko_user_access</code> that can be used in the user file to access the internal state of the entire case and the underlying solvers.</p>
<p>In particular the case object (<code>case_t</code>) is reached via <code>neko_user_access%case</code>. There-in the <code>fluid</code> and <code>scalars</code> components refer to the asscociated schemes. You are encouraged to look a bit at <code><a class="el" href="../../d2/d0f/case_8f90.html">case.f90</a></code> to see the overall structure.</p>
<p>A very common use case is to get access to various SEM-related objects, as well as the mesh object.</p>
<ul>
<li><code>neko_user_access%case%fluid%msh</code> &ndash; the mesh.</li>
<li><code>neko_user_access%case%fluid%dm_Xh</code> &ndash; the function space used in the SEM.</li>
<li><code>neko_user_access%case%fluid%dm_Xh</code> &ndash; the map of degrees of freedom, contains the locations of the GLL nodes.</li>
<li><code>neko_user_access%case%fluid%c_Xh</code> &ndash; the coefficients of the SEM,</li>
<li><code>neko_user_access%case%fluid%gs_Xh</code> &ndash; the gather-scatter kernels used for direct stiffness summation. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Neko Manual</a></li><li class="navelem"><a class="el" href="../../dd/d04/user-guide.html">User guide</a></li>
    <li class="footer">Generated on Sun Dec 21 2025 03:53:02 for Neko by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
