<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Neko: Case File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Neko<span id="projectnumber">&#160;1.99.1</span>
   </div>
   <div id="projectbrief">A portable framework for high-order spectral element flow simulations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('dd/d33/case-file.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Case File</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md44">High-level structure</a></li>
<li class="level1"><a href="#autotoc_md45">Output frequency control</a></li>
<li class="level1"><a href="#autotoc_md46">The case object</a><ul><li class="level2"><a href="#autotoc_md47">Time control</a></li>
<li class="level2"><a href="#autotoc_md48">Restarts and joblimit</a></li>
<li class="level2"><a href="#autotoc_md49">Boundary type numbering in the &quot;output_boundary&quot; field</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md50">Numerics</a></li>
<li class="level1"><a href="#autotoc_md51">Fluid</a><ul><li class="level2"><a href="#autotoc_md52">Material properties</a></li>
<li class="level2"><a href="#autotoc_md53">Turbulence modelling</a></li>
<li class="level2"><a href="#case-file_fluid-boundary-conditions">Boundary conditions</a><ul><li class="level3"><a href="#autotoc_md54">Specifying the boundaries</a></li>
<li class="level3"><a href="#autotoc_md55">Available conditions</a></li>
</ul>
</li>
<li class="level2"><a href="#case-file_fluid-ic">Initial conditions</a></li>
<li class="level2"><a href="#case-file_fluid-source-term">Source terms</a><ul><li class="level3"><a href="#autotoc_md56">Brinkman</a></li>
<li class="level3"><a href="#autotoc_md57">Gradient Jump Penalty</a></li>
<li class="level3"><a href="#autotoc_md58">Sponge</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md59">Linear solver configuration</a><ul><li class="level2"><a href="#autotoc_md60">Multilevel preconditioners</a></li>
<li class="level2"><a href="#autotoc_md61">Flow rate forcing</a></li>
<li class="level2"><a href="#autotoc_md62">Full parameter table</a></li>
</ul>
</li>
<li class="level1"><a href="#case-file_scalar">Scalar</a><ul><li class="level2"><a href="#autotoc_md63">Material properties</a></li>
<li class="level2"><a href="#autotoc_md64">Turbulence modelling</a></li>
<li class="level2"><a href="#autotoc_md65">Boundary conditions</a></li>
<li class="level2"><a href="#autotoc_md66">Initial conditions</a></li>
<li class="level2"><a href="#autotoc_md67">Source terms</a></li>
<li class="level2"><a href="#autotoc_md68">Linear solver configuration</a></li>
<li class="level2"><a href="#autotoc_md69">Full parameter table</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md70">Simulation components</a></li>
<li class="level1"><a href="#autotoc_md71">Point zones</a></li>
<li class="level1"><a href="#autotoc_md72">Runtime statistics</a></li>
</ul>
</div>
<div class="textblock"><p>The case file defines all the parameters of a simulation. The format of the file is JSON, making it easy to read and write case files using the majority of the popular programming languages. JSON is hierarchical and, and consists of parameter blocks enclosed in curly braces. These blocks are referred to as objects. The case file makes use objects to separate the configuration of different parts of the solver. We refer the reader to the examples shipped with the code to get a good idea of how a case file looks. The table below provides a complete reference for all possible configuration choices.</p>
<h1><a class="anchor" id="autotoc_md44"></a>
High-level structure</h1>
<p>The current high-level structure of the case file is shown below.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    &quot;version&quot;: 1.0</div>
<div class="line">    &quot;case&quot;: {</div>
<div class="line">        &quot;time&quot;: {}</div>
<div class="line">        &quot;numerics&quot;: {}</div>
<div class="line">        &quot;fluid&quot;: {}</div>
<div class="line">        &quot;scalar&quot;: {}</div>
<div class="line">        &quot;simulation_components&quot; : []</div>
<div class="line">        &quot;point_zones&quot; : []</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Neko also supports multiple scalar fields, using the keyword <code>scalars</code> in the case object. Users can define multiple scalar fields, and each field can have its own boundary conditions, source terms, and solver settings. When using multiple scalar fields, the <code>name</code> property of each scalar field is used to identify the scalar field in the user file, defaulted to <code>s_1, s_2, ...</code>.</p>
<p>The <code>version</code> keyword is reserved to track changes in the format of the file. The subsections below we list all the configuration options for each of the high-level objects. Some parameters will have default values, and are therefore optional.</p>
<h1><a class="anchor" id="autotoc_md45"></a>
Output frequency control</h1>
<p>A common scheme for controlling the output frequency is applied for various outputs. It is described already now in order to clarify the meaning of several parameters found in the tables below.</p>
<p>The frequency is controlled by two parameters, ending with <code>_control</code> and <code>_value</code>, respectively. The latter name is perhaps not ideal, but it is somewhat difficult to come up with a good one, suggestions are welcome.</p>
<p>The <code>_value</code> parameter is a number, that defines the output frequency, but the interpretation of that number depends on the choice of <code>_control</code>. The three following options are possible.</p><ol type="1">
<li><code>simulationtime</code>, then <code>_value</code> is the time interval between the outputs.</li>
<li><code>tsteps</code>, then <code>_value</code> is the number of time steps between the outputs.</li>
<li><code>nsamples</code>, then <code>_value</code> is the total number of outputs that will be performed in the course of the simulation.</li>
<li><code>never</code>, then <code>_value</code> is ignored and output is never performed.</li>
</ol>
<h1><a class="anchor" id="autotoc_md46"></a>
The case object</h1>
<p>This object is mostly used as a high-level container for all the other objects, but also defines several parameters that pertain to the simulation as a whole.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Admissible values   </th><th class="markdownTableHeadNone">Default value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>no_defaults</code>   </td><td class="markdownTableBodyNone">Prevents filling in default values to case file entries.   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>false</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>mesh_file</code>   </td><td class="markdownTableBodyNone">The name of the mesh file.   </td><td class="markdownTableBodyNone">Strings ending with <code>.nmsh</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>output_boundary</code>   </td><td class="markdownTableBodyNone">Whether to write a <code>bdry0.f0000</code> file with boundary labels. Can be used to check boundary conditions.   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>false</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>output_directory</code>   </td><td class="markdownTableBodyNone">Folder for redirecting solver output. Note that the folder has to exist!   </td><td class="markdownTableBodyNone">Path to an existing directory   </td><td class="markdownTableBodyNone"><code>.</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>output_format</code>   </td><td class="markdownTableBodyNone">The file format of field data.   </td><td class="markdownTableBodyNone"><code>nek5000</code> or <code>adios2</code>   </td><td class="markdownTableBodyNone"><code>nek5000</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>output_precision</code>   </td><td class="markdownTableBodyNone">Whether to output snapshots in single or double precision   </td><td class="markdownTableBodyNone"><code>single</code> or <code>double</code>   </td><td class="markdownTableBodyNone"><code>single</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>output_layout</code>   </td><td class="markdownTableBodyNone">Data layout for <code>adios2</code> files. (Choose <code>2</code> or <code>3</code> for ADIOS2 supported compressors BigWhoop or ZFP.)   </td><td class="markdownTableBodyNone">Positive integer <code>1</code>, <code>2</code>, <code>3</code>   </td><td class="markdownTableBodyNone"><code>1</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>load_balancing</code>   </td><td class="markdownTableBodyNone">Whether to apply load balancing.   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>false</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>output_partitions</code>   </td><td class="markdownTableBodyNone">Whether to write a <code>partitions.vtk</code> file with domain partitioning.   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>false</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>output_checkpoints</code>   </td><td class="markdownTableBodyNone">Whether to output checkpoints, i.e. restart files.   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>false</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>checkpoint_control</code>   </td><td class="markdownTableBodyNone">Defines the interpretation of <code>checkpoint_value</code> to define the frequency of writing checkpoint files.   </td><td class="markdownTableBodyNone"><code>nsamples</code>, <code>simulationtime</code>, <code>tsteps</code>, <code>never</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>checkpoint_value</code>   </td><td class="markdownTableBodyNone">The frequency of sampling in terms of <code>checkpoint_control</code>.   </td><td class="markdownTableBodyNone">Positive real or integer   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>checkpoint_filename</code>   </td><td class="markdownTableBodyNone">The filename of written checkpoint.   </td><td class="markdownTableBodyNone">Strings such as <code>my_name</code>   </td><td class="markdownTableBodyNone"><code>fluid</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>checkpoint_format</code>   </td><td class="markdownTableBodyNone">The file format of checkpoints   </td><td class="markdownTableBodyNone"><code>chkp</code> or <code>hdf5</code>   </td><td class="markdownTableBodyNone"><code>chkp</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>restart_file</code>   </td><td class="markdownTableBodyNone">checkpoint to use for a restart from previous data   </td><td class="markdownTableBodyNone">Strings ending with <code>.chkp</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>restart_mesh_file</code>   </td><td class="markdownTableBodyNone">If the restart file is on a different mesh, specify the .nmsh file used to generate it here   </td><td class="markdownTableBodyNone">Strings ending with <code>.nmsh</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>mesh2mesh_tolerance</code>   </td><td class="markdownTableBodyNone">Tolerance for the restart when restarting from another mesh   </td><td class="markdownTableBodyNone">Positive reals   </td><td class="markdownTableBodyNone">1e-6    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>job_timelimit</code>   </td><td class="markdownTableBodyNone">The maximum wall clock duration of the simulation.   </td><td class="markdownTableBodyNone">String formatted as HH:MM:SS   </td><td class="markdownTableBodyNone">No limit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>output_at_end</code>   </td><td class="markdownTableBodyNone">Whether to always write all enabled output at the end of the run.   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>true</code>   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md47"></a>
Time control</h2>
<p>The time control object is used to define the time-stepping of the simulation, including the time-step size, the start and end time, and the variables related to the variable time-stepping algorithm.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Admissible values   </th><th class="markdownTableHeadNone">Default value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>start_time</code>   </td><td class="markdownTableBodyNone">Start time at which the simulation is initiated.   </td><td class="markdownTableBodyNone">Positive reals   </td><td class="markdownTableBodyNone"><code>0.0</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>end_time</code>   </td><td class="markdownTableBodyNone">Final time after which the simulation is stopped.   </td><td class="markdownTableBodyNone">Positive reals   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>timestep</code>   </td><td class="markdownTableBodyNone">Time-step size   </td><td class="markdownTableBodyNone">Positive reals   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>variable_timestep</code>   </td><td class="markdownTableBodyNone">Whether to use variable dt   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>false</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>max_timestep</code>   </td><td class="markdownTableBodyNone">Maximum time-step size when variable time step is activated   </td><td class="markdownTableBodyNone">Positive reals   </td><td class="markdownTableBodyNone"><code>huge</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>min_timestep</code>   </td><td class="markdownTableBodyNone">Minimum time-step size when variable time step is activated   </td><td class="markdownTableBodyNone">Positive reals   </td><td class="markdownTableBodyNone"><code>0.0</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>target_cfl</code>   </td><td class="markdownTableBodyNone">The desired CFL number   </td><td class="markdownTableBodyNone">Positive real   </td><td class="markdownTableBodyNone"><code>0.4</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>max_update_frequency</code>   </td><td class="markdownTableBodyNone">The minimum interval between two time-step-updating steps in terms of time steps   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone"><code>0</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>min_update_frequency</code>   </td><td class="markdownTableBodyNone">The maximum interval between two time-step-updating steps in terms of time steps   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone"><code>huge</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>running_avg_coeff</code>   </td><td class="markdownTableBodyNone">The running average coefficient <code>a</code> where <code>cfl_avg_new = a * cfl_new + (1-a) * cfl_avg_old</code>   </td><td class="markdownTableBodyNone">Positive real between <code>0</code> and <code>1</code>   </td><td class="markdownTableBodyNone"><code>0.5</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>max_dt_increase_factor</code>   </td><td class="markdownTableBodyNone">The maximum scaling factor to increase time step   </td><td class="markdownTableBodyNone">Positive real greater than <code>1</code>   </td><td class="markdownTableBodyNone"><code>1.2</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>min_dt_decrease_factor</code>   </td><td class="markdownTableBodyNone">The minimum scaling factor to decrease time step   </td><td class="markdownTableBodyNone">Positive real less than <code>1</code>   </td><td class="markdownTableBodyNone"><code>0.5</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>cfl_deviation_tolerance</code>   </td><td class="markdownTableBodyNone">The tolerance of the deviation from the target CFL number   </td><td class="markdownTableBodyNone">Positive real less than <code>1</code>   </td><td class="markdownTableBodyNone"><code>0.2</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>cfl_max_update_frequency</code>   </td><td class="markdownTableBodyNone">The minimum interval between two time-step-updating steps in terms of time steps   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone"><code>0</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>cfl_running_avg_coeff</code>   </td><td class="markdownTableBodyNone">The running average coefficient <code>a</code> where <code>cfl_avg_new = a * cfl_new + (1-a) * cfl_avg_old</code>   </td><td class="markdownTableBodyNone">Positive real between <code>0</code> and <code>1</code>   </td><td class="markdownTableBodyNone"><code>0.5</code>   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md48"></a>
Restarts and joblimit</h2>
<p>Restarts will restart the simulation from the exact state at a given time that the checkpoint was written. This means that the flow field and potential scalars will be at the exact same values before as after restarts. However, derived quantities from the flow field and any observables are not guaranteed to be restarted. In addition, Neko does not guarantee that any files are not overwritten. As such, it is recommended to run in different directories if doing large scale simulations that require many restarts. Unless <code>output_at_end</code> is disabled Neko will also ensure that all output is written to file when reaching the <code>end_time</code> or the <code>job_timelimit</code>. In particular, unless <code>output_checkpoints</code> and <code>output_at_end</code> are set to false a checkpoint at the final time will be written as to avoid losing progress as far as possible.</p>
<dl class="section attention"><dt>Attention</dt><dd>For simulations requiring restarts, it is recommended to run each restart in a different output directory as a precaution to avoid potential overwritings of files.</dd></dl>
<h2><a class="anchor" id="autotoc_md49"></a>
Boundary type numbering in the "output_boundary" field</h2>
<p>When the <code>output_boundary</code> setting is set to <code>true</code>, and additional <code>.fld</code> file will be stored in the beginning of the simulation, where the recognized boundary conditions for the fluid will be marked with an integer number. This is a good way to debug the simulation setup. The value of the number depends on the type of the boundary as follows.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Boundary Condition   </th><th class="markdownTableHeadNone">Key    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">no_slip   </td><td class="markdownTableBodyNone">1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">velocity_value   </td><td class="markdownTableBodyNone">2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">outflow, normal_outflow (+dong)   </td><td class="markdownTableBodyNone">3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">symmetry   </td><td class="markdownTableBodyNone">4    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">periodic   </td><td class="markdownTableBodyNone">6    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">user_velocity   </td><td class="markdownTableBodyNone">7    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">user_pressure   </td><td class="markdownTableBodyNone">8    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="../../da/dea/namespaceshear__stress.html" title="Defines a shear stress boundary condition for a vector field. Maintainer: Timofey Mukha.">shear_stress</a>   </td><td class="markdownTableBodyNone">9    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="../../da/ddd/namespacewall__model.html" title="Implements wall_model_t.">wall_model</a>   </td><td class="markdownTableBodyNone">10    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">blasius_profile   </td><td class="markdownTableBodyNone">11   </td></tr>
</table>
<p>For a description of the boundary conditions themselves, see below.</p>
<h1><a class="anchor" id="autotoc_md50"></a>
Numerics</h1>
<p>Used to define the properties of the numerical discretization.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Admissible values   </th><th class="markdownTableHeadNone">Default value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>polynomial_order</code>   </td><td class="markdownTableBodyNone">The order of the polynomial basis.   </td><td class="markdownTableBodyNone">Integers, typically 5 to 9   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>time_order</code>   </td><td class="markdownTableBodyNone">The order of the time integration scheme. Refer to the <code><a class="el" href="../../dc/dfb/namespacetime__scheme__controller.html" title="Compound scheme for the advection and diffusion operators in a transport equation.">time_scheme_controller</a></code> type documentation for details.   </td><td class="markdownTableBodyNone">1, 2, 3   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>dealias</code>   </td><td class="markdownTableBodyNone">Whether to apply dealiasing to advection terms.   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>false</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>dealiased_polynomial order</code>   </td><td class="markdownTableBodyNone">The polynomial order in the higher-order space used in the dealising.   </td><td class="markdownTableBodyNone">Integer   </td><td class="markdownTableBodyNone"><code>3/2(polynomial_order + 1) - 1</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>oifs</code>   </td><td class="markdownTableBodyNone">Whether to apply the Operator-Integration-Factor-Splitting (OIFS).   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>false</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>oifs_target_cfl</code>   </td><td class="markdownTableBodyNone">The desired OIFS-CFL number. Requires variable_timestep = true in the time control object.   </td><td class="markdownTableBodyNone">Positive real   </td><td class="markdownTableBodyNone"><code>1.9</code>   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md51"></a>
Fluid</h1>
<p>The configuration of the fluid solver and the flow problem. Contains multiple subobjects for various parts of the setup.</p>
<h2><a class="anchor" id="autotoc_md52"></a>
Material properties</h2>
<p>As per the governing equations, Neko requires the value of the density and dynamic viscosity to define the flow problem. These can be provided as <code>rho</code> and <code>mu</code> in the case file.</p>
<p>Alternatively, one may opt to provide the Reynolds number, <code>Re</code>, which corresponds to a non-dimensional formulation of the Navier-Stokes equations. This formulation can effectively be obtained by setting \( \rho = 1 \) and \(
\mu = 1/Re \). This is exactly what Neko does under the hood, when <code>Re</code> is provided in the case file.</p>
<p>Note that if both <code>Re</code> and any of the dimensional material properties are provided, the simulation will issue an error.</p>
<p>As an alternative to providing material properties in the case file, it is possible to do that in a special routine in the user file. This is demonstrated in the <code>rayleigh_benard_cylinder</code> example. Ultimately, both <code>rho</code> and <code>mu</code> have to be set in the subroutine. Additionally, this allows to change the material properties in time. Yet another options is to directly manipulate the case file programmatically in the <code>user_startup</code> routine and inject the material properties there. This is demonstrated in the <code>rayleigh_benard</code> example.</p>
<p>When material properties are constant or only vary in time, one can use the simplified form of the viscous stress tensor in the governing equations. However, when there are spatial variations, it is necessary to use the general (full) form. The variation may come, for example, due to a turbulence model, the modifications in the above-mentioned user routine. The general form of the stress tensor requires solving the 3 equations for the velocity components in a coupled manner, which requires an appropriate linear solver. By default, Neko will use the simplified form of the tensor, and the full one must be selected by the user by setting <code>full_stress_formulation</code> to true.</p>
<h2><a class="anchor" id="autotoc_md53"></a>
Turbulence modelling</h2>
<p>Neko currently provides several LES models via the <code><a class="el" href="../../dd/dfc/namespaceles__model.html" title="Implements les_model_t.">les_model</a></code> simulation component. The simcomp computes the viscosity and stores in the field registry under the name selected in the case file. For more details, see the documentation of the simcomp. To enable LES in the fluid solver, one simply has to add the <code>nut_field</code> keyword to the configuration and set it to the name of the field generated by the <code><a class="el" href="../../dd/dfc/namespaceles__model.html" title="Implements les_model_t.">les_model</a></code> simcomp. This will automatically change the governing equations to feature the full viscous stress tensor, as required for a variable viscosity field.</p>
<p>Note that the full viscous stress tensor requires the equations for the 3 velocity components to be solved in a coupled manner. Therefore, the <code>cpldcg</code> solver should be used for velocity.</p>
<h2><a class="anchor" id="case-file_fluid-boundary-conditions"></a>
Boundary conditions</h2>
<p>The optional <code>boundary_conditions</code> keyword can be used to specify boundary conditions. The reason for it being optional, is that periodic boundary conditions are built into the definition of the mesh, so for a periodic box nothings needs to be added to the case file. The TGV example is such a case, for instance. The value of the keyword is an array of JSON objects, each specifying a single boundary condition.</p>
<h3><a class="anchor" id="autotoc_md54"></a>
Specifying the boundaries</h3>
<p>In Neko we usually refer to boundaries as "zones", which in this case are face zones, i.e. a collection of element faces. Which zones the boundary condition is applied to is controlled by the <code>zone_indices</code> keyword, which takes an array of integers. It is up to the user whether to apply a single condition to multiple zones or specify several conditions applied to one zone each. For example, if you have two zones, which should be no-slip walls, you can either create two <code>no_slip</code> conditions, one for each zone, or just create a single condition and apply it to both.</p>
<p>The indices your boundaries have is determined by the mesh. To check them, you can use the <code>mesh_checker</code> utility with the optional <code>--write_zone_indices</code> argument. This will output a <code>zone_indices0.f00000</code> file that you can inspect in Paraview, and the boundaries will be marked by their index value.</p>
<p>Recall that periodic conditions are built into the mesh, since they are topological in nature. This means that you must not specify any conditions for the corresponding zones. For example, in the <code>turb_pipe</code> example, which is a periodic pipe simulation, two periodic zones comprise the boundary conditions in the streamwise direction. Only one condition, corresponding to zone index 3 (the wall) is the specified in the case file.</p>
<h3><a class="anchor" id="autotoc_md55"></a>
Available conditions</h3>
<p>The conditions to apply is specified by <code>type</code> keyword inside each of the JSON objects. The full list of possible conditions for the fluid is specified in the table below.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Boundary Condition   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">symmetry   </td><td class="markdownTableBodyNone">A symmetry plain. Must be axis-aligned.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">velocity_value   </td><td class="markdownTableBodyNone">A Dirichlet condition for velocity.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">no_slip   </td><td class="markdownTableBodyNone">A no-slip wall.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">outflow   </td><td class="markdownTableBodyNone">A pressure outlet.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">normal_outflow   </td><td class="markdownTableBodyNone">An Neumann condition for the surface-normal component of velocity combined with a Dirichlet for the surface-parallel components. Must be axis-aligned.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">outflow+user   </td><td class="markdownTableBodyNone">Same as <code>outflow</code> but with user-specified pressure.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">normal_outflow+user   </td><td class="markdownTableBodyNone">Same as <code>normal_outflow</code> but with user-specified pressure.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">outflow+dong   </td><td class="markdownTableBodyNone">A pressure outlet with the Dong condition applied.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">normal_outflow+dong   </td><td class="markdownTableBodyNone">The <code>normal_outflow</code> with the Dong condition applied. Must be axis-aligned.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="../../da/dea/namespaceshear__stress.html" title="Defines a shear stress boundary condition for a vector field. Maintainer: Timofey Mukha.">shear_stress</a>   </td><td class="markdownTableBodyNone">Prescribed wall shear stress. Must be axis-aligned.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="../../da/ddd/namespacewall__model.html" title="Implements wall_model_t.">wall_model</a>   </td><td class="markdownTableBodyNone">Shear stress condition based on a wall model for large-eddy simulation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">blasius_profile   </td><td class="markdownTableBodyNone">A Blasius velocity profile.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">user_velocity   </td><td class="markdownTableBodyNone">The <code>field_dirichlet_vector_t</code> user-defined Dirichlet condition for velocity.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">user_pressure   </td><td class="markdownTableBodyNone">The <code>field_dirichlet_t</code> user-defined Dirichlet condition for pressure.   </td></tr>
</table>
<p>A more detailed description of each boundary condition is provided below.</p>
<ul>
<li><code>symmetry</code>. A symmetry plain that must be axis-aligned. Sets the surface-normal velocity to 0 and applies a homogenous Neumann condition to the surface-parallel components. Requires no additional keywords. <div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;symmetry&quot;,</div>
<div class="line">  &quot;zone_indices&quot;: [1, 2]</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><p class="startli"><code>velocity_value</code>. A Dirichlet condition for velocity. Suitable for velocity inlets, moving walls, certain freestream conditions, etc. The value is prescribed by the <code>value</code> keyword, that should be an array of 3 reals.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;velocity_value&quot;,</div>
<div class="line">  &quot;value&quot;: [&quot;1, 0, 0&quot;],</div>
<div class="line">  &quot;zone_indices&quot;: [1, 2]</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><code>no_slip</code>. A standard no-slip wall, which sets velocity to zero. Requires no additional keywords. <div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;no_slip&quot;,</div>
<div class="line">  &quot;zone_indices&quot;: [1, 2]</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><code>outflow</code>. A standard pressure outlet condition. Requires no additional keywords. <div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;outflow&quot;,</div>
<div class="line">  &quot;zone_indices&quot;: [1, 2]</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><code>normal_outflow</code>. The condition lets the flow escape through the boundary by setting a homogeneous Neumann condition for the surface-normal velocity component, but fixes the values of the surface-parallel components. The latter values are not prescribed in the boundary condition's JSON, but are instead taken from the initial conditions. The boundary must be axis-aligned. <div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;normal_outflow&quot;,</div>
<div class="line">  &quot;zone_indices&quot;: [1, 2]</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><code>outflow+user</code>. Same as <code>outflow</code>, but with user-specified pressure. The pressure is specified via the same interface as <code>user_pressure</code>, see the <a class="el" href="../../d6/def/user-file.html#user-file_field-dirichlet-update">relevant section</a> for more information.</li>
<li><code>normal_outflow+user</code>. Same as <code>normal_outflow</code>, but with user-specified pressure. The pressure profile is specified via the same interface as <code>user_pressure</code>, see the <a class="el" href="../../d6/def/user-file.html#user-file_field-dirichlet-update">relevant section</a> for more information. Note that, similarly to <code>normal_outflow</code>, surface-parallel velocity components are taken from the initial conditions.</li>
<li><code>outflow+dong</code>. Same as <code>outflow</code>, but additionally applies the Dong boundary condition on the pressure. This is a way to prevent backflow and therefore promotes numerical stability without having to create a mesh "sponge" at the outlet.</li>
<li><code>normal_outflow+dong</code>. Same as <code>normal_outflow</code>, but additionally applies the Dong boundary condition for the pressure to prevent backflow. Must be axis-aligned.</li>
<li><code><a class="el" href="../../da/dea/namespaceshear__stress.html" title="Defines a shear stress boundary condition for a vector field. Maintainer: Timofey Mukha.">shear_stress</a></code>. Non-penetration condition combined with a set shear stress vector. Only works with axis-aligned boundaries. The stress value is specified by the <code>value</code> keyword, which should be an array of 3 reals. It is the responsibility of the user to set the vector in the direction parallel to the boundary. <div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;shear_stress&quot;,</div>
<div class="line">  &quot;value&quot;: [&quot;1, 0, 0&quot;],</div>
<div class="line">  &quot;zone_indices&quot;: [1, 2]</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><p class="startli"><code><a class="el" href="../../da/ddd/namespacewall__model.html" title="Implements wall_model_t.">wall_model</a></code>. A shear stress condition, where the values is computed by a wall model. Meant to be used for wall-modelled large-eddy simulation. Only works with axis-aligned boundaries. The model is selected using the <code>model</code> keyword. Additional configuration depends on the model selected.</p><ul>
<li>The <code>spalding</code>model requires specifying <code>kappa</code> and <code>B</code>, which are the log-law constants. This model is suitable for smooth walls.</li>
<li><p class="startli">The <code><a class="el" href="../../d7/d0f/namespacerough__log__law.html" title="Implements rough_log_law_t.">rough_log_law</a></code> model requires specifying <code>kappa</code> and <code>B</code>, which are the log-law constants, and <code>z0</code>, which is the characteristic roughness height.</p>
<p class="startli">For all wall models, the distance to the sampling point has to be specified based on the off-wall index in the wall-normal direction. Thus, the sampling is currently from a GLL node and arbitrary distances are not yet supported. The index is set by the <code>h_index</code> keyword, with 1 being the minimal value, and the polynomial order + 1 being the maximum.</p>
<p class="startli">A 3D field with the name <code>tau</code> will be registered in the field registry. At the boundary it will store the magnitude of the predicted stress. This can be used to post-process the predictions. Additionally, the sampling points are marked with values -1 in this field, for verification purposes.</p>
</li>
</ul>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;wall_model&quot;,</div>
<div class="line">  &quot;model&quot;: &quot;spalding&quot;,</div>
<div class="line">  &quot;kappa&quot;: 0.41,</div>
<div class="line">  &quot;B&quot;: 5.2,</div>
<div class="line">  &quot;zone_indices&quot;: [1, 2],</div>
<div class="line">  &quot;h_index&quot;: 1</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><code>user_velocity</code>, a Dirichlet boundary for more complex velocity profiles. This boundary condition uses a <a class="el" href="../../d6/def/user-file.html#user-file_field-dirichlet-update">more advanced user interface</a>. <div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;user_velocity&quot;,</div>
<div class="line">  &quot;zone_indices&quot;: [1, 2]</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><code>user_pressure</code>, a boundary for specified non-uniform pressure profiles, similar in essence to <code>user_velocity</code>. <div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;user_pressure&quot;,</div>
<div class="line">  &quot;zone_indices&quot;: [1, 2]</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="case-file_fluid-ic"></a>
Initial conditions</h2>
<p>The object <code>initial_condition</code> is used to provide initial conditions. It is mandatory. Note that this currently pertains to both the fluid, but also scalars. The means of prescribing the values are controlled via the <code>type</code> keyword:</p>
<ol type="1">
<li><code>user</code>, the values are set inside the compiled user file. as explained in the <a class="el" href="../../d6/def/user-file.html#user-file_user-ic">user defined initial condition</a> section of the user file documentation.</li>
<li><code>uniform</code>, the value is a constant vector, looked up under the <code>value</code> keyword.</li>
<li><code>blasius</code>, a Blasius profile is prescribed. The boundary cannot be tilted with respect to the coordinate axes. It requires the following parameters:<ol type="a">
<li><code>delta</code>, the thickness of the boundary layer.</li>
<li><code>freestream_velocity</code>, the velocity value in the free stream.</li>
<li><code>approximation</code>, the numerical approximation to the Blasius profile.<ul>
<li><code>linear</code>, linear approximation.</li>
<li><code>quadratic</code>, quadratic approximation.</li>
<li><code>cubic</code>, cubic approximation.</li>
<li><code>quartic</code>, quartic approximation.</li>
<li><code>sin</code>, sine function approximation.</li>
<li><code>tanh</code>, hyperbolic tangent approximation of Sava≈ü (2012). In this case <code>delta</code> is the 99% thickness.</li>
</ul>
</li>
</ol>
</li>
<li><code><a class="el" href="../../dc/d5f/namespacepoint__zone.html">point_zone</a></code>, the values are set to a constant base value, supplied under the <code>base_value</code> keyword, and then assigned a zone value inside a point zone. The point zone is specified by the <code>name</code> keyword, and should be defined in the <code>case.point_zones</code> object. See more about <a class="el" href="../../da/dd0/point-zones.html">point zones</a>.</li>
<li><p class="startli"><code>field</code>, where the initial condition is retrieved from a field file. The following keywords can be used: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Admissible values   </th><th class="markdownTableHeadNone">Default value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>file_name</code>   </td><td class="markdownTableBodyNone">Name of the field file to use (e.g. <code>myfield0.f00034</code>).   </td><td class="markdownTableBodyNone">Strings ending with <code>f*****</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>interpolate</code>   </td><td class="markdownTableBodyNone">Whether to interpolate the velocity and pressure fields from the field file onto the current mesh.   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>false</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>tolerance</code>   </td><td class="markdownTableBodyNone">Tolerance for the point search.   </td><td class="markdownTableBodyNone">Positive real.   </td><td class="markdownTableBodyNone"><code>1e-6</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>mesh_file_name</code>   </td><td class="markdownTableBodyNone">If interpolation is enabled, the name of the field file that contains the mesh coordinates.   </td><td class="markdownTableBodyNone">Strings ending with <code>f*****</code>   </td><td class="markdownTableBodyNone"><code>file_name</code>   </td></tr>
</table>
<dl class="section attention"><dt>Attention</dt><dd>Interpolating a field from the same mesh but different polynomial order is performed implicitly and does not require to enable interpolation.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is recommended to interpolate from <code>fld</code> files that were written in double precision. To check if your <code>fld</code> file was written in double precision, run the command: <div class="fragment"><div class="line">head -1 field0.f00000</div>
</div><!-- fragment --> The output <code>#std 4 ...</code> indicates single precision, whereas <code>#std 8 ...</code> indicates double precision. Neko writes single precision <code>fld</code> files by default. To write your files in double precision, set <code>case.output_precision</code> to <code>"double"</code>.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Neko does not automatically detect if interpolation is needed. Interpolation will always be performed if <code>"interpolate"</code> is set to <code>true</code>, even if the field file matches with the current simulation.</dd></dl>
</li>
</ol>
<h2><a class="anchor" id="case-file_fluid-source-term"></a>
Source terms</h2>
<p>The <code>source_terms</code> object should be used to specify the source terms in the momentum equation. The object is not mandatory, by default no forcing term is present. Each source term, is itself a JSON object, so <code>source_terms</code> is just an array of them. Note that with respect to the governing equations, the source terms define \( f^u \), meaning that the values are then multiplied by the density.</p>
<p>For each source, the <code>type</code> keyword defines the kind of forcing that will be introduced. Furthermore, the <code>start_time</code> and <code>end_time</code> keywords can be used to set a time frame for when the source term is active. Note, however, that these keywords have no effect on the user-defined source terms, but their execution can, of course, be directly controlled in the user code. By default, all source terms are active during the entire simulation.</p>
<p>The following types are currently implemented.</p>
<ol type="1">
<li><code>constant</code>, constant forcing. Strength defined by the <code>values</code> array with 3 reals corresponding to the 3 components of the forcing.</li>
<li><p class="startli"><code>boussinesq</code>, a source term introducing buoyancy based on the Boussinesq approximation, \( \rho \beta (T - T_{ref}) \cdot \mathbf{g} \). Here, \(
   \rho \) is density, \( \beta \) the thermal expansion coefficient, \(
   \mathbf{g} \) the gravity vector, and \( T_{ref} \) a reference value of the scalar, typically temperature.</p>
<p class="startli">Reads the following entries:</p><ul>
<li><code>scalar_field</code>: The name of the scalar that drives the source term, defaults to "s".</li>
<li><code>reference_value</code>: The reference value of the scalar.</li>
<li><code>g</code>: The gravity vector.</li>
<li><code>beta</code>: The thermal expansion coefficient, defaults to the inverse of <code>ref_value</code>.</li>
</ul>
</li>
<li><p class="startli"><code>coriolis</code>, a source term introducing a Coriolis force, defined as \( -2
   \Omega \times (u - U_g) \). Here, \( \Omega \) is the rotation vector and \( u \) is the velocity vector, and \( U_g \) is the geostrophic wind. Several ways of setting \( \Omega \) are provided via the following keywords.</p><ul>
<li><code>rotation_vector</code>: Array with 3 values. Directly assigns \( \Omega \) to the provided vector.</li>
<li><code>omega</code> and <code>phi</code>: Both scalars. The latitude <code>phi</code> should be provided in degrees. Sets \( \Omega = [0, \omega \cos \phi, \omega \sin \phi ] \). Common notation when modelling the atmosphere. This assumes that the \( z
     \) axis is normal to the ground.</li>
<li><code>f</code>: Scalar, referred to as the Coriolis parameter, \( f = 2 \omega \sin
     \phi \). Sets \( \Omega = [0, 0, 0.5f ] \). This assumes both that \( z
     \) axis is normal to the ground and that the ground-normal component of the Coriolis force is negligible.</li>
</ul>
<p class="startli">The geostrophic wind is set to 0 for all components by default. Other values are set via the <code>geostrophic_wind</code> keyword.</p>
</li>
<li><code>centrifugal</code>, a source term introducing a centrifugal force, defined as \( -
   \Omega \times (\Omega \times r) \). Here, \( \Omega \) is the rotation vector and \( r \) is the position relative to the reference point, which is any point lying on the rotation axis. To define forcing one has to provide \( \Omega \) and the reference point. This is provided via the following keywords.<ul>
<li><code>rotation_vector</code>: Array with 3 values. Directly assigns \( \Omega \) to the provided vector.</li>
<li><code>reference_point</code>: Array with 3 values. Deifines any point on the rotaion axis.</li>
</ul>
</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Notice that to perform simulation in a rotating reference frame one has to define both <code>coriolis</code> and <code>centrifugal</code> source terms in a consistent way.</dd></dl>
<ol type="1">
<li><code>user</code>, the values are set inside the compiled user file, using the corresponding user file subroutine.</li>
<li><code>brinkman</code>, Brinkman permeability forcing inside a pre-defined region.</li>
<li><code><a class="el" href="../../d6/def/namespacegradient__jump__penalty.html" title="Implements gradient_jump_penalty_t.">gradient_jump_penalty</a></code>, perform gradient_jump_penalisation.</li>
<li><code>sponge</code>, adds a sponge term based on a reference velocity field, which is applied in a user-specified region of the domain.</li>
</ol>
<h3><a class="anchor" id="autotoc_md56"></a>
Brinkman</h3>
<p>The Brinkman source term introduces regions of resistance in the fluid domain. The volume force \( f_i \) applied in the selected regions are proportional to the fluid velocity component \( u_i \).</p>
<p class="formulaDsp">
\begin{eqnarray*}
   f_i(x) &amp;=&amp; - B(x) u_i(x), \\
   B(x) &amp;=&amp; \kappa_0 + (\kappa_1 - \kappa_0) \xi(x) \frac{q + 1}{q + \xi(x)},
 \end{eqnarray*}
</p>
<p>where, \( x \) is the current location in the domain, \( \xi: x \mapsto [0,1] \) represent an indicator function for the resistance where \( \xi(x) = 0 \) is a free flow. \( \kappa_i \) describes the limits for the force application at \( \xi(x)=0 \) and \( \xi(x)=1 \). A penalty parameter \( q \) help us to reduce numerical problems.</p>
<p>The indicator function will be defined based on the object type. The following types are currently implemented.</p>
<ol type="1">
<li><code>boundary_mesh</code>, the indicator function for a boundary mesh is computed in two steps. First, the signed distance function is computed for the boundary mesh. Then, the indicator function is computed using the distance transform function specified in the case file. This is currently not very well optimized, it will scale by <code>O(log(M)*N)</code>, where <code>M</code> is the number of triangles in the boundary mesh and <code>N</code> is the number of grid points in the simulation. To avoid recomputing the distance field for multiple simulations with the same boundary mesh and numerical discretization, the distance field can be cached to a file. This is controlled by the <code>cache</code> keyword. If set to <code>true</code>, the distance field will be saved to a file specified by the <code>cache_file</code> keyword. If the file already exists, it will be loaded instead of recomputing it. The distance field is stored in the Nek5000 <code>.fld</code> file format.</li>
<li><code><a class="el" href="../../dc/d5f/namespacepoint__zone.html">point_zone</a></code>, the indicator function is defined as 1 inside the point zone and 0 outside.</li>
</ol>
<p>Each object are added to a common indicator field by means of a point-wise max operator. This means that the indicator field will be the union of all the regions defined by the objects.</p>
<p>To assist correct placement and scaling of objects from external sources, the meshes can be transformed using the <code>mesh_transform</code> object. The object can be used to apply a transformation to the boundary mesh. The following types are currently implemented.</p>
<ol type="1">
<li><code>none</code>, no transformation is applied.</li>
<li><code>bounding_box</code>, the boundary mesh is transformed to fit inside a box defined by <code>box_min</code> and <code>box_max</code>. The box is defined by two vectors of 3 reals each. The <code>keep_aspect_ratio</code> keyword can be used to keep the aspect ratio of the boundary mesh.</li>
</ol>
<p>After the indicator field is computed, it is filtered using a filter type specified in the case file. The filter is used to smooth the indicator field before computing the Brinkman force. The following types are currently implemented.</p>
<ol type="1">
<li><code>none</code>, no filtering is applied.</li>
</ol>
<p>The filtering can be defined for each object separately. Additionally, the filter can be specified for the entire source term, in which case it will be applied to the final indicator field, after all sources have been added.</p>
<p>Additional keywords are available to modify the Brinkman force term.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Admissible values   </th><th class="markdownTableHeadNone">Default value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>brinkman.limits</code>   </td><td class="markdownTableBodyNone">Brinkman factor at free-flow ( \( \kappa_0 \)) and solid domain ( \( \kappa_1 \)).   </td><td class="markdownTableBodyNone">Vector of 2 reals.   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>brinkman.penalty</code>   </td><td class="markdownTableBodyNone">Penalty parameter \( q \) when estimating Brinkman factor.   </td><td class="markdownTableBodyNone">Real   </td><td class="markdownTableBodyNone">\( 1.0 \)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>objects</code>   </td><td class="markdownTableBodyNone">Array of JSON objects, defining the objects to be immersed.   </td><td class="markdownTableBodyNone">Each object must specify a <code>type</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>distance_transform.type</code>   </td><td class="markdownTableBodyNone">How to map from distance field to indicator field.   </td><td class="markdownTableBodyNone"><code>step</code>, <code>smooth_step</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>distance_transform.value</code>   </td><td class="markdownTableBodyNone">Values used to define the distance transform, such as cut-off distance for the step function.   </td><td class="markdownTableBodyNone">Real   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>filter.type</code>   </td><td class="markdownTableBodyNone">Type of filtering applied to the indicator field either globally or for the current object.   </td><td class="markdownTableBodyNone"><code>none</code>   </td><td class="markdownTableBodyNone"><code>none</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>mesh_transform.type</code>   </td><td class="markdownTableBodyNone">Apply a transformation to the boundary mesh.   </td><td class="markdownTableBodyNone"><code>bounding_box</code>, <code>none</code>   </td><td class="markdownTableBodyNone"><code>none</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>mesh_transform.box_min</code>   </td><td class="markdownTableBodyNone">Lower left front corner of the box to fit inside.   </td><td class="markdownTableBodyNone">Vector of 3 reals   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>mesh_transform.box_max</code>   </td><td class="markdownTableBodyNone">Upper right back corner of the box to fit inside.   </td><td class="markdownTableBodyNone">Vector of 3 reals   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>mesh_transform.keep_aspect_ratio</code>   </td><td class="markdownTableBodyNone">Keep the aspect ratio of the boundary mesh.   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>true</code>   </td></tr>
</table>
<p>Example of a Brinkman source term where a boundary mesh and a point zone are combined to define the resistance in the fluid domain. The indicator field for the boundary mesh is computed using a step function with a cut-off distance of \( 0.1 \). The indicator field for the point zone is not filtered.</p>
<div class="fragment"><div class="line">&quot;source_terms&quot;: [</div>
<div class="line">   {</div>
<div class="line">      &quot;type&quot;: &quot;brinkman&quot;,</div>
<div class="line">      &quot;objects&quot;: [</div>
<div class="line">         {</div>
<div class="line">            &quot;type&quot;: &quot;boundary_mesh&quot;,</div>
<div class="line">            &quot;name&quot;: &quot;some_mesh.stl&quot;,</div>
<div class="line">            &quot;distance_transform&quot;: {</div>
<div class="line">               &quot;type&quot;: &quot;step&quot;,</div>
<div class="line">               &quot;value&quot;: 0.1</div>
<div class="line">            },</div>
<div class="line">            &quot;cache&quot;: true,</div>
<div class="line">            &quot;cache_file&quot;: &quot;some_mesh_cache&quot;</div>
<div class="line">         },</div>
<div class="line">         {</div>
<div class="line">            &quot;type&quot;: &quot;point_zone&quot;,</div>
<div class="line">            &quot;name&quot;: &quot;cylinder_zone&quot;,</div>
<div class="line">            &quot;filter&quot;: {</div>
<div class="line">               &quot;type&quot;: &quot;none&quot;</div>
<div class="line">            }</div>
<div class="line">         }</div>
<div class="line">      ],</div>
<div class="line">      &quot;brinkman&quot;: {</div>
<div class="line">         &quot;limits&quot;: [0.0, 100.0],</div>
<div class="line">         &quot;penalty&quot;: 1.0</div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line">]</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md57"></a>
Gradient Jump Penalty</h3>
<p>The optional <code><a class="el" href="../../d6/def/namespacegradient__jump__penalty.html" title="Implements gradient_jump_penalty_t.">gradient_jump_penalty</a></code> object can be used to perform gradient jump penalty as an continuous interior penalty option. The penalty term is performed on the weak form equation of quantity \( T \) (could either be velocity or scalar) as a right hand side term</p>
<p>\( - &lt; \tau |u \cdot n| h^2_{\Omega ^e} G(T) \phi_{t1} \phi_{t2} \frac{\partial \phi_{n}}{\partial n}&gt;\),</p>
<p>where \( &lt;&gt; \) refers to the integral over all facets of the element, \( \tau
\) is the penalty parameter, \( |u \cdot n| \) is the absolute velocity flux over the facet, \( h^2_{\Omega ^e} \) is the mesh size, \( G(T) \) is the gradient jump over the facet, \( \phi_{t1} \phi_{t2} \) are the polynomial on the tangential direction of the facet, and finally \( \frac{\partial
\phi_{n}}{\partial n} \) is the gradient of the normal polynomial on the facet.</p>
<p>Here in our Neko context where hexahedral mesh is adopted, \( h^2_{\Omega ^e}
\) is measured by the average distance from the vertices of the facet to the facet on the opposite side. And the distance of a vertex to another facet is defined by the average distance from the vertex to the plane constituted by 3 vertices from the other facet.</p>
<p>The penalty parameter \( \tau \) could be expressed as the form \( \tau = a
* (P + 1) ^ {-b}\), for \( P &gt; 1 \) where \( P \) is the polynomial order while \( a \) and \( b \) are user-defined parameters. The configuration uses the following parameters:</p>
<ul>
<li><code>tau</code>, the penalty parameter that can be only used for \( P = 1 \), default to be <code>0.02</code>.</li>
<li><code>scaling_factor</code>, the scaling parameter \( a \) for \( P &gt; 1 \), default to be <code>0.8</code>.</li>
<li><code>scaling_exponent</code>, the scaling parameter \( b \) for \( P &gt; 1 \), default to be <code>4.0</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md58"></a>
Sponge</h3>
<p>The sponge source term adds a term to each of the momentum equations of the form</p>
<p>\( \mathbf{\lambda} f(\mathbf{x}) ( \mathbf{u}^{bf} - \mathbf{u}) \)</p>
<p>where:</p>
<ul>
<li>\( \mathbf{\lambda} \) is a 3-element vector of amplitudes of the sponge forcing in each Cartesian direction,</li>
<li>\( \mathbf{u}^{\text{bf}} \) is a reference (baseflow) velocity field,</li>
<li>\( f(\mathbf{x}) \) is a user-defined sponge mask field, defining where the sponge is active.</li>
</ul>
<p>Amplitudes are specified using the <code>amplitudes</code> keyword with an array of 3 reals. Any of those values can be set to 0 to suppress the forcing in that particular direction. For example <code>[1.0, 1.0, 0.0]</code> will multiply the fringe field by 1, 1, and 0 in the <code>x</code>, <code>y</code> and <code>z</code> directions respectively, effectively removing the forcing in the <code>z</code> direction.</p>
<p>The reference velocity field, or <code>baseflow</code> can be set from three methods:</p><ol type="1">
<li><p class="startli"><code>constant</code>, applies constant values according to the <code>values</code> keyword:</p>
<details >
<summary >
<b><u>Example code snippet</u></b></summary>
<div class="fragment"><div class="line">&quot;source_terms&quot;: [</div>
<div class="line">   {</div>
<div class="line">      &quot;type&quot;: &quot;sponge&quot;,</div>
<div class="line">      &quot;amplitudes&quot;: [1.0, 1.0, 1.0],</div>
<div class="line">      &quot;baseflow&quot;: {</div>
<div class="line">          &quot;method&quot;: &quot;constant&quot;,</div>
<div class="line">          &quot;value&quot;: [2.0, 0.0, 0.0]</div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line">]</div>
</div><!-- fragment --> </details>
</li>
<li><code>field</code>, where the velocity fields are retrieved from an <code>fld</code> file. Uses the same parameters as the field initial condition. <dl class="section note"><dt>Note</dt><dd>The same parameters as the <code>field</code> initial condition apply here.</dd></dl>
<details >
<summary >
<b><u>Example code snippet</u></b></summary>
<div class="fragment"><div class="line">&quot;source_terms&quot;: [</div>
<div class="line">   {</div>
<div class="line">      &quot;type&quot;: &quot;sponge&quot;,</div>
<div class="line">      &quot;amplitudes&quot;: [1.0, 1.0, 1.0],</div>
<div class="line">      &quot;baseflow&quot;: {</div>
<div class="line">          &quot;method&quot;: &quot;field&quot;,</div>
<div class="line">          &quot;file_name&quot;: &quot;my_field0.f00016&quot;,</div>
<div class="line">          &quot;mesh_file_name&quot;: &quot;my_field0.f00000&quot;,</div>
<div class="line">          &quot;interpolate&quot;: true,</div>
<div class="line">          &quot;tolerance&quot;: 1e-6</div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line">]</div>
</div><!-- fragment --> </details>
</li>
<li><code>user</code>, where the velocity field is set according to what is defined in the user file. Useful for setting velocity fields manually. In this case, the base flow fields must be created and added to the <code>neko_registry</code> (see fortran code snippet below). <details >
<summary >
<b><u>Example code snippet</u></b></summary>
<div class="fragment"><div class="line">&quot;source_terms&quot;: [</div>
<div class="line">   {</div>
<div class="line">      &quot;type&quot;: &quot;sponge&quot;,</div>
<div class="line">      &quot;amplitudes&quot;: [1.0, 1.0, 1.0],</div>
<div class="line">      &quot;baseflow&quot;: {</div>
<div class="line">          &quot;method&quot;: &quot;user&quot;</div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line">]</div>
</div><!-- fragment --> </details>
</li>
</ol>
<p>Finally, the fringe function field must be filled by the user. This must be done through the user file by adding the fringe field to the <code>neko_registry</code> in either <code>user_init_modules</code> or <code>fluid_user_ic</code> (more specifically, before the first call to compute the sponge source term).</p>
<p>The fringe field must be set by adding a field to the <code>neko_registry</code> under a specific name that can be retrieved internally. By default, Neko will search for the field <code>"sponge_fringe"</code> in the registry, but this can be changed by setting the parameter <code>fringe_registry_name</code>, which is important when using more than one sponge source term.</p>
<p>The same principle applies for the base flow fields (if <code>"method": "user"</code>). By default, neko will search for the base flow fields in the registry using the prefix <code>"sponge_bf_"</code>, meaning that <code>u</code> will be in <code>sponge_bf_u</code>, etc. This prefix can be changed by setting the parameter <code>bf_registry_prefix</code>.</p>
<details >
<summary >
<b><u>Example using <code>user_init_modules</code></u></b></summary>
<p></p>
<div class="fragment"><div class="line"><span class="keyword">module</span> <a class="code hl_namespace" href="../../dc/d44/namespaceuser.html">user</a></div>
<div class="line">  <span class="keywordtype">use </span><a class="code hl_namespace" href="../../dd/d62/namespaceneko.html">neko</a></div>
<div class="line">  <span class="keywordtype">implicit none</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">contains</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">! Register user-defined functions (see user_intf.f90)</span></div>
<div class="line">  <span class="keyword">subroutine </span><a class="code hl_function" href="../../dc/d44/namespaceuser.html#a34728c151f0dbb7521a84b18b09cbd9d">user_setup</a>(user)</div>
<div class="line">    <span class="keywordtype">type</span>(user_t), <span class="keywordtype">intent(inout)</span> :: user</div>
<div class="line">    <a class="code hl_namespace" href="../../dc/d44/namespaceuser.html">user</a>%initialize =&gt; user_initialize</div>
<div class="line">  <span class="keyword">end subroutine </span><a class="code hl_function" href="../../dc/d44/namespaceuser.html#a34728c151f0dbb7521a84b18b09cbd9d">user_setup</a></div>
<div class="line"> </div>
<div class="line">  <span class="comment">! User-defined initialization called just before time loop starts</span></div>
<div class="line">  <span class="keyword">subroutine </span>user_initialize(t)</div>
<div class="line">    <span class="keywordtype">type</span>(time_state_t), <span class="keywordtype">intent(in)</span> :: t</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">type</span>(field_t), <span class="keywordtype">pointer</span> :: u, fringe, ubf, vbf, wbf</div>
<div class="line"><span class="keywordtype">    real</span>(kind=rp) :: x, y, xmin1, delta_rise1, xmin2, delta_rise2</div>
<div class="line">    <span class="keywordtype">integer</span> :: i, imask</div>
<div class="line"> </div>
<div class="line">    <span class="comment">!</span></div>
<div class="line">    <span class="comment">! 1. Add the &quot;sponge_field&quot; to the field registry.</span></div>
<div class="line">    <span class="comment">!    NOTE: The name of the fringe field in the registry</span></div>
<div class="line">    <span class="comment">!    can be changed with the parameter `fringe_registry_name`.</span></div>
<div class="line">    <span class="comment">!</span></div>
<div class="line">    <span class="comment">!</span></div>
<div class="line">    u =&gt; neko_registry%get_field(<span class="stringliteral">&quot;u&quot;</span>)</div>
<div class="line">    <span class="keyword">call </span>neko_registry%add_field(u%dof,<span class="stringliteral">&quot;sponge_fringe&quot;</span>)</div>
<div class="line">    fringe =&gt; neko_registry%get_field(<span class="stringliteral">&quot;sponge_fringe&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="comment">! Initialize the base flows</span></div>
<div class="line">    <span class="keyword">call </span>neko_registry%add_field(u%dof,<span class="stringliteral">&quot;sponge_bf_u&quot;</span>)</div>
<div class="line">    ubf =&gt; neko_registry%get_field(<span class="stringliteral">&quot;sponge_bf_u&quot;</span>)</div>
<div class="line">    <span class="keyword">call </span>neko_registry%add_field(u%dof,<span class="stringliteral">&quot;sponge_bf_v&quot;</span>)</div>
<div class="line">    vbf =&gt; neko_registry%get_field(<span class="stringliteral">&quot;sponge_bf_v&quot;</span>)</div>
<div class="line">    <span class="keyword">call </span>neko_registry%add_field(u%dof,<span class="stringliteral">&quot;sponge_bf_w&quot;</span>)</div>
<div class="line">    wbf =&gt; neko_registry%get_field(<span class="stringliteral">&quot;sponge_bf_w&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="comment">!</span></div>
<div class="line">    <span class="comment">! 2. Set the function f(x,y,z) from 0 to 1. in two zones of the mesh,</span></div>
<div class="line">    <span class="comment">!    a top region in x \in [xmin1, +\infty[, y \in [0, +\infty[</span></div>
<div class="line">    <span class="comment">!  and a bottom region x \in [xmin2, +\infty[, y \in ]-\infty, 0[</span></div>
<div class="line">    <span class="comment">!</span></div>
<div class="line">    <span class="comment">!    A smoothing function S(x) is applied at the beginning of each zone,</span></div>
<div class="line">    <span class="comment">!    with a rising distance of delta_rise1 and delta_rise2</span></div>
<div class="line">    <span class="comment">!</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">! Bottom boundary</span></div>
<div class="line">    xmin1 = 3.0_rp</div>
<div class="line">    delta_rise1 = 3.0_rp</div>
<div class="line"> </div>
<div class="line">    <span class="comment">! Top boundary</span></div>
<div class="line">    xmin2 = 20.0_rp</div>
<div class="line">    delta_rise2 = 7.0_rp</div>
<div class="line"> </div>
<div class="line">    fringe = 0.0_rp</div>
<div class="line">    <span class="keywordflow">do</span> i = 1, fringe%size()</div>
<div class="line">        x = fringe%dof%x(i,1,1,1)</div>
<div class="line">        y = fringe%dof%y(i,1,1,1)</div>
<div class="line"> </div>
<div class="line">        <span class="comment">! Bottom boundary</span></div>
<div class="line">        <span class="keywordflow">if</span> ( (y .lt. 0.0_rp) .and. (x .gt. xmin1)) <span class="keywordflow">then</span></div>
<div class="line">           fringe%x(i,1,1,1) = s( (x - xmin1)/delta_rise1 )</div>
<div class="line"> </div>
<div class="line">        <span class="comment">! Top boundary</span></div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (y .gt. 0.0_rp) .and. (x .gt. xmin2)) <span class="keywordflow">then</span></div>
<div class="line">           fringe%x(i,1,1,1) = s( (x - xmin2)/delta_rise2 )</div>
<div class="line"><span class="keywordflow">        end if</span></div>
<div class="line"> </div>
<div class="line">       <span class="comment">! Set ubf,vbf to something random</span></div>
<div class="line">       ubf%x(i,1,1,1) = sin(3.1415926_rp*2.0_rp/10.0_rp * x)</div>
<div class="line">       vbf%x(i,1,1,1) = cos(3.1415926_rp*2.0_rp/10.0_rp * y)</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">    end do</span></div>
<div class="line"> </div>
<div class="line">    wbf = 0.0_rp</div>
<div class="line">    <span class="keywordflow">if</span> (neko_bcknd_device .eq. 1) <span class="keywordflow">then</span></div>
<div class="line">       <span class="keyword">call </span>device_memcpy(ubf%x, ubf%x_d, ubf%size(), &amp;</div>
<div class="line">            host_to_device, .false.)</div>
<div class="line">       <span class="keyword">call </span>device_memcpy(vbf%x, vbf%x_d, vbf%size(), &amp;</div>
<div class="line">            host_to_device, .false.)</div>
<div class="line">       <span class="keyword">call </span>device_memcpy(fringe%x, fringe%x_d, fringe%size(), &amp;</div>
<div class="line">            host_to_device, .false.)</div>
<div class="line"><span class="keywordflow">    end if</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">! NOTE: You can dump the fringe field to file using the `dump_fields`</span></div>
<div class="line">    <span class="comment">! parameter. The fringe field will be stored under `pressure`.</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">nullify</span>(fringe)</div>
<div class="line">    <span class="keyword">nullify</span>(u)</div>
<div class="line">    <span class="keyword">nullify</span>(ubf)</div>
<div class="line">    <span class="keyword">nullify</span>(vbf)</div>
<div class="line">    <span class="keyword">nullify</span>(wbf)</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">end subroutine </span>user_initialize</div>
<div class="line"> </div>
<div class="line">  <span class="comment">! Smooth step function, 0 if x &lt;= 0, 1 if x &gt;= 1, 1/erp(1/(x-1) + 1/x) between 0 and 1</span></div>
<div class="line">  <span class="keyword">function </span>s(x) <span class="keyword">result</span>(y)</div>
<div class="line"><span class="keywordtype">    real</span>(kind=rp), <span class="keywordtype">intent(in)</span> :: x</div>
<div class="line"><span class="keywordtype">    real</span>(kind=rp)             :: y</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> ( x.le.0._rp ) <span class="keywordflow">then</span></div>
<div class="line">       y = 0._rp</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( x.ge.1._rp ) <span class="keywordflow">then</span></div>
<div class="line">       y = 1._rp</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">       y = 1._rp / (1._rp + exp( 1._rp/(x-1._rp) + 1._rp/x))</div>
<div class="line"><span class="keywordflow">    end if</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">end function </span>s</div>
<div class="line"> </div>
<div class="line"><span class="keyword">end module </span>user</div>
<div class="ttc" id="anamespaceneko_html"><div class="ttname"><a href="../../dd/d62/namespaceneko.html">neko</a></div><div class="ttdoc">Master module.</div><div class="ttdef"><b>Definition</b> <a href="../../d5/d1f/neko_8f90_source.html#l00034">neko.f90:34</a></div></div>
<div class="ttc" id="anamespaceuser_html"><div class="ttname"><a href="../../dc/d44/namespaceuser.html">user</a></div><div class="ttdef"><b>Definition</b> <a href="../../d3/d6f/fields__vectors__math_8f90_source.html#l00018">fields_vectors_math.f90:18</a></div></div>
<div class="ttc" id="anamespaceuser_html_a34728c151f0dbb7521a84b18b09cbd9d"><div class="ttname"><a href="../../dc/d44/namespaceuser.html#a34728c151f0dbb7521a84b18b09cbd9d">user::user_setup</a></div><div class="ttdeci">subroutine user_setup(user)</div><div class="ttdef"><b>Definition</b> <a href="../../d3/d6f/fields__vectors__math_8f90_source.html#l00034">fields_vectors_math.f90:35</a></div></div>
</div><!-- fragment --><p></p>
</details>
<p>In order to visualize your baseflow and fringe field, you may set <code>dump_fields</code> to <code>true</code>. An <code>fld</code> file will be written to disk as <code>spng_fields.fld</code>(note, not in <code>output_directory</code>) with the fringe field stored as <code>pressure</code>. You may change the name of the field file by setting <code>dump_file_name</code> (must have the extension <code>fld</code>).</p>
<p>The parameters for the sponge source term are summarized in the table below:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Admissible values   </th><th class="markdownTableHeadNone">Default value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>amplitudes</code>   </td><td class="markdownTableBodyNone">Sponge forcing strength in each Cartesian direction   </td><td class="markdownTableBodyNone">Array of 3 reals   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>baseflow.method</code>   </td><td class="markdownTableBodyNone">Method to define the reference (baseflow) velocity   </td><td class="markdownTableBodyNone"><code>"constant"</code>, <code>"field"</code>, <code>"user"</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>baseflow.value</code>   </td><td class="markdownTableBodyNone">Velocity vector for constant baseflow   </td><td class="markdownTableBodyNone">Array of 3 reals   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>baseflow.file_name</code>   </td><td class="markdownTableBodyNone">File containing baseflow velocity field   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>baseflow.mesh_file_name</code>   </td><td class="markdownTableBodyNone">Mesh file corresponding to the baseflow field   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>baseflow.interpolate</code>   </td><td class="markdownTableBodyNone">Whether to interpolate field values to current mesh   </td><td class="markdownTableBodyNone">Boolean   </td><td class="markdownTableBodyNone"><code>false</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>baseflow.tolerance</code>   </td><td class="markdownTableBodyNone">Tolerance for interpolation convergence   </td><td class="markdownTableBodyNone">Real   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>fringe_registry_name</code>   </td><td class="markdownTableBodyNone">Name of the fringe mask field in <code>neko_registry</code>   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone"><code>"sponge_fringe"</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>baseflow_registry_prefix</code>   </td><td class="markdownTableBodyNone">Prefix of the base flow fields in <code>neko_registry</code>   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone"><code>"sponge_bf"</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>dump_fields</code>   </td><td class="markdownTableBodyNone">If <code>true</code>, dumps the fringe and baseflow fields for visualization   </td><td class="markdownTableBodyNone">Boolean   </td><td class="markdownTableBodyNone"><code>false</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>dump_file_name</code>   </td><td class="markdownTableBodyNone">Name of the <code>fld</code> file in which to dump the base flow and fringe fields   </td><td class="markdownTableBodyNone">String ending with <code>fld</code>   </td><td class="markdownTableBodyNone"><code>spng_fields.fld</code>   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md59"></a>
Linear solver configuration</h1>
<p>The mandatory <code>velocity_solver</code> and <code>pressure_solver</code> objects are used to configure the solvers for the momentum and pressure-Poisson equation. The following keywords are used, with the corresponding options.</p>
<ul>
<li><code>type</code>, solver type.<ul>
<li><code>cg</code>, a conjugate gradient solver.</li>
<li><code>pipecg</code>, a pipelined conjugate gradient solver.</li>
<li><code>bicgstab</code>, a bi-conjugate gradient stabilized solver.</li>
<li><code>cacg</code>, a communication-avoiding conjugate gradient solver.</li>
<li><code>coupled_cg</code>, a coupled conjugate gradient solver. Must be used for velocity when viscosity varies in space.</li>
<li><code>gmres</code>, a GMRES solver. Typically used for pressure.</li>
<li><code>fused_cg</code>, a conjugate gradient solver optimised for accelerators using</li>
<li><code>fused_coupled_cg</code>, a coupled conjugate gradient solver optimised for accelerators using kernel fusion. Must be used for velocity when viscosity varies in space and device backened is used. using kernel fusion.</li>
</ul>
</li>
<li><code>preconditioner.type</code>, preconditioner type.<ul>
<li><code>jacobi</code>, a Jacobi preconditioner. Typically used for velocity.</li>
<li><code>hsmg</code>, a hybrid-Schwarz multigrid preconditioner. Typically used for pressure.</li>
<li><code>phmg</code>, a hybrid ph multigrid preconditioner. Typically used for pressure.</li>
<li><code>ident</code>, an identity matrix (no preconditioner).</li>
</ul>
</li>
<li><code>absolute_tolerance</code>, tolerance criterion for convergence.</li>
<li><code>max_iterations</code>, maximum number of iterations before giving up.</li>
<li><code>projection_space_size</code>, size of the vector space used for accelerating the solution procedure. If 0, then the projection space is not used. More important for the pressure equation.</li>
<li><code>projection_hold_steps</code>, steps for which the simulation does not use projection after starting or time step changes. E.g. if 5, then the projection space will start to update at the 6th time step and the space will be utilized at the 7th time step.</li>
<li><code>monitor</code>, monitoring of residuals. If set to true, the residuals will be printed for each iteration.</li>
</ul>
<p>In addition to the above settings, the solvers can be configured with strict convergence criteria. This is done by setting the <code>case.fluid.strict_convergence</code> keyword to <code>true</code>. This will force the solver to converge to the specified tolerance within the specified number of iterations. If the solver does not converge, the simulation will be terminated. This can in some situations cause issues if the initial condition is far from a valid solution. Therefore a user can allow an initial stabilization phase by setting the <code>case.fluid.allow_stabilization</code> keyword to <code>true</code>. In this case, the strict convergence will be ignored untill all components of the velocity field converge within the specified tolerance. After this initial stabilization phase, strict convergence will be enforced for the rest of the simulation.</p>
<h2><a class="anchor" id="autotoc_md60"></a>
Multilevel preconditioners</h2>
<p>The multilevel preconditioners, <code>hsmg</code> and <code>phmg</code>, come with an additional set of parameters related to the solution of the coarse grid problem. These parameters are specified as a <code>coarse_grid</code> block under <code>preconditioner</code>.</p>
<p>For <code>hsmg</code>, the following keywords are used:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Admissible values   </th><th class="markdownTableHeadNone">Default value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>coarse_grid.solver</code>   </td><td class="markdownTableBodyNone">Type of linear solver for the coarse grid, any of the Krylov solvers or TreeAMG <code>tamg</code>   </td><td class="markdownTableBodyNone">A solver <code>type</code>   </td><td class="markdownTableBodyNone"><code>cg</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>coarse_grid.preconditioner</code>   </td><td class="markdownTableBodyNone">Type of the preconditioner to use (only valid for a Krylov based <code>solver</code>)   </td><td class="markdownTableBodyNone">A preconditioner <code>type</code>   </td><td class="markdownTableBodyNone"><code>jacobi</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>coarse_grid.iterations</code>   </td><td class="markdownTableBodyNone">Number of linear solver iterations (only valid for a Krylov based <code>solver</code>)   </td><td class="markdownTableBodyNone">An integer   </td><td class="markdownTableBodyNone">10    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>coarse_grid.monitor</code>   </td><td class="markdownTableBodyNone">Monitor residuals in the coarse grid (only valid for a Krylov based <code>solver</code>)   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>false</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>coarse_grid.levels</code>   </td><td class="markdownTableBodyNone">Number of AMG levels to construct (only valid for <code>solver</code> type <code>tamg</code>)   </td><td class="markdownTableBodyNone">An integer   </td><td class="markdownTableBodyNone">3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>coarse_grid.iterations</code>   </td><td class="markdownTableBodyNone">Number of AMG iterations (only valid for <code>solver</code> type <code>tamg</code>)   </td><td class="markdownTableBodyNone">An integer   </td><td class="markdownTableBodyNone">1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>coarse_grid.cheby_degree</code>   </td><td class="markdownTableBodyNone">Degree of the Chebyshev based AMG smoother   </td><td class="markdownTableBodyNone">An integer   </td><td class="markdownTableBodyNone">5   </td></tr>
</table>
<p>For <code>phmg</code>, the following keywords are used:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Admissible values   </th><th class="markdownTableHeadNone">Default value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>pcoarsening_schedule</code>   </td><td class="markdownTableBodyNone">P-multigrid coarsening schedule (polynomial order, high to low)   </td><td class="markdownTableBodyNone">Array of integers   </td><td class="markdownTableBodyNone"><code>[3, 1]</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>smoother_iterations</code>   </td><td class="markdownTableBodyNone">Number of smoother iterations in the p-multigrid parts   </td><td class="markdownTableBodyNone">An integer   </td><td class="markdownTableBodyNone">10    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>smoother_cheby_acc</code>   </td><td class="markdownTableBodyNone">Type of Chebyshev acceleration (non-accelerated semi-iterative Chebyshev method if not set)   </td><td class="markdownTableBodyNone"><code>jacobi</code> or <code>schwarz</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>coarse_grid.levels</code>   </td><td class="markdownTableBodyNone">Number of AMG levels to construct (only valid for <code>solver</code> type <code>tamg</code>)   </td><td class="markdownTableBodyNone">An integer   </td><td class="markdownTableBodyNone">3    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>coarse_grid.iterations</code>   </td><td class="markdownTableBodyNone">Number of linear solver iterations for coarse grid solver   </td><td class="markdownTableBodyNone">An integer   </td><td class="markdownTableBodyNone">1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>coarse_grid.cheby_degree</code>   </td><td class="markdownTableBodyNone">Degree of the Chebyshev based AMG smoother   </td><td class="markdownTableBodyNone">An integer   </td><td class="markdownTableBodyNone">5   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md61"></a>
Flow rate forcing</h2>
<p>The optional <code>flow_rate_force</code> object can be used to force a particular flow rate through the domain. Useful for channel and pipe flows. The configuration uses the following parameters:</p>
<ul>
<li><code>direction</code>, the direction of the flow, defined as 0, 1, or 2, corresponding to x, y or z, respectively.</li>
<li><code>value</code>, the desired flow rate.</li>
<li><code>use_averaged_flow</code>, whether <code>value</code> specifies the domain-averaged (bulk) velocity or the volume flow rate.</li>
</ul>
<h2><a class="anchor" id="autotoc_md62"></a>
Full parameter table</h2>
<p>All the parameters are summarized in the table below. This includes all the subobjects discussed above, as well as keyword parameters that can be described concisely directly in the table.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Admissible values   </th><th class="markdownTableHeadNone">Default value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>scheme</code>   </td><td class="markdownTableBodyNone">The fluid solve type.   </td><td class="markdownTableBodyNone"><code>pnpn</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>name</code>   </td><td class="markdownTableBodyNone">The name associated to the fluid solver.   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone"><code>fluid</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Re</code>   </td><td class="markdownTableBodyNone">The Reynolds number.   </td><td class="markdownTableBodyNone">Positive real   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>rho</code>   </td><td class="markdownTableBodyNone">The density of the fluid.   </td><td class="markdownTableBodyNone">Positive real   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>mu</code>   </td><td class="markdownTableBodyNone">The dynamic viscosity of the fluid.   </td><td class="markdownTableBodyNone">Positive real   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>nut_field</code>   </td><td class="markdownTableBodyNone">The name of the turbulent viscosity field.   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>output_control</code>   </td><td class="markdownTableBodyNone">Defines the interpretation of <code>output_value</code> to define the frequency of writing checkpoint files.   </td><td class="markdownTableBodyNone"><code>nsamples</code>, <code>simulationtime</code>, <code>tsteps</code>, <code>never</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>output_value</code>   </td><td class="markdownTableBodyNone">The frequency of sampling in terms of <code>output_control</code>.   </td><td class="markdownTableBodyNone">Positive real or integer   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>output_filename</code>   </td><td class="markdownTableBodyNone">The output filename.   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone"><code>field</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>inflow_condition.type</code>   </td><td class="markdownTableBodyNone">Velocity inflow condition type.   </td><td class="markdownTableBodyNone"><code>user</code>, <code>uniform</code>, <code>blasius</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>inflow_condition.value</code>   </td><td class="markdownTableBodyNone">Value of the inflow velocity.   </td><td class="markdownTableBodyNone">Vector of 3 reals   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>initial_condition.type</code>   </td><td class="markdownTableBodyNone">Initial condition type.   </td><td class="markdownTableBodyNone"><code>user</code>, <code>uniform</code>, <code>blasius</code>, <code>field</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>initial_condition.value</code>   </td><td class="markdownTableBodyNone">Value of the velocity initial condition.   </td><td class="markdownTableBodyNone">Vector of 3 reals   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>initial_condition.file_name</code>   </td><td class="markdownTableBodyNone">If <code>"type" = "field"</code>, the path to the field file to read from.   </td><td class="markdownTableBodyNone">String ending with <code>.fld</code>, <code>.chkp</code>, <code>.nek5000</code> or <code>f*****</code>.   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>initial_condition.sample_index</code>   </td><td class="markdownTableBodyNone">If <code>"type" = "field"</code>, and file type is <code>fld</code> or <code>nek5000</code>, the index of the file to sampled.   </td><td class="markdownTableBodyNone">Positive integer.   </td><td class="markdownTableBodyNone">-1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>initial_condition.previous_mesh</code>   </td><td class="markdownTableBodyNone">If <code>"type" = "field"</code>, and file type is <code>chkp</code>, the previous mesh from which to interpolate.   </td><td class="markdownTableBodyNone">String ending with <code>.nmsh</code>.   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>initial_condition.tolerance</code>   </td><td class="markdownTableBodyNone">If <code>"type" = "field"</code>, and file type is <code>chkp</code>, tolerance to use for mesh interpolation.   </td><td class="markdownTableBodyNone">Positive real.   </td><td class="markdownTableBodyNone">1e-6    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>blasius.delta</code>   </td><td class="markdownTableBodyNone">Boundary layer thickness in the Blasius profile.   </td><td class="markdownTableBodyNone">Positive real   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>blasius.freestream_velocity</code>   </td><td class="markdownTableBodyNone">Free-stream velocity in the Blasius profile.   </td><td class="markdownTableBodyNone">Vector of 3 reals   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>blasius.approximation</code>   </td><td class="markdownTableBodyNone">Numerical approximation of the Blasius profile.   </td><td class="markdownTableBodyNone"><code>linear</code>, <code>quadratic</code>, <code>cubic</code>, <code>quartic</code>, <code>sin</code>, <code>tanh</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>shear_stress.value</code>   </td><td class="markdownTableBodyNone">The shear stress vector value for <code>sh</code> boundaries   </td><td class="markdownTableBodyNone">Vector of 3 reals   </td><td class="markdownTableBodyNone"><code>[0, 0, 0]</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>wall_modelling.type</code>   </td><td class="markdownTableBodyNone">The wall model type for <code>wm</code> boundaries. See documentation for additional config parameters.   </td><td class="markdownTableBodyNone"><code><a class="el" href="../../d7/d0f/namespacerough__log__law.html" title="Implements rough_log_law_t.">rough_log_law</a></code>, <code>spalding</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>source_terms</code>   </td><td class="markdownTableBodyNone">Array of JSON objects, defining additional source terms.   </td><td class="markdownTableBodyNone">See list of source terms above   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="../../d6/def/namespacegradient__jump__penalty.html" title="Implements gradient_jump_penalty_t.">gradient_jump_penalty</a></code>   </td><td class="markdownTableBodyNone">Array of JSON objects, defining additional gradient jump penalty.   </td><td class="markdownTableBodyNone">See list of gradient jump penalty above   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>boundary_types</code>   </td><td class="markdownTableBodyNone">Boundary types/conditions labels.   </td><td class="markdownTableBodyNone">Array of strings   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>velocity_solver.type</code>   </td><td class="markdownTableBodyNone">Linear solver for the momentum equation.   </td><td class="markdownTableBodyNone"><code>cg</code>, <code>pipecg</code>, <code>bicgstab</code>, <code>cacg</code>, <code>gmres</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>velocity_solver.preconditioner.type</code>   </td><td class="markdownTableBodyNone">Linear solver preconditioner for the momentum equation.   </td><td class="markdownTableBodyNone"><code>ident</code>, <code>hsmg</code>, <code>jacobi</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>velocity_solver.absolute_tolerance</code>   </td><td class="markdownTableBodyNone">Linear solver convergence criterion for the momentum equation.   </td><td class="markdownTableBodyNone">Positive real   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>velocity_solver.maxiter</code>   </td><td class="markdownTableBodyNone">Linear solver max iteration count for the momentum equation.   </td><td class="markdownTableBodyNone">Positive real   </td><td class="markdownTableBodyNone">800    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>velocity_solver.projection_space_size</code>   </td><td class="markdownTableBodyNone">Projection space size for the momentum equation.   </td><td class="markdownTableBodyNone">Positive integer   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>velocity_solver.projection_hold_steps</code>   </td><td class="markdownTableBodyNone">Holding steps of the projection for the momentum equation.   </td><td class="markdownTableBodyNone">Positive integer   </td><td class="markdownTableBodyNone">5    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>velocity_solver.monitor</code>   </td><td class="markdownTableBodyNone">Monitor residuals in the linear solver for the momentum equation.   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>false</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>pressure_solver.type</code>   </td><td class="markdownTableBodyNone">Linear solver for the pressure equation.   </td><td class="markdownTableBodyNone"><code>cg</code>, <code>pipecg</code>, <code>bicgstab</code>, <code>cacg</code>, <code>gmres</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>pressure_solver.preconditioner.type</code>   </td><td class="markdownTableBodyNone">Linear solver preconditioner for the pressure equation.   </td><td class="markdownTableBodyNone"><code>ident</code>, <code>hsmg</code>, <code>jacobi</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>pressure_solver.absolute_tolerance</code>   </td><td class="markdownTableBodyNone">Linear solver convergence criterion for the pressure equation.   </td><td class="markdownTableBodyNone">Positive real   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>pressure_solver.maxiter</code>   </td><td class="markdownTableBodyNone">Linear solver max iteration count for the pressure equation.   </td><td class="markdownTableBodyNone">Positive real   </td><td class="markdownTableBodyNone">800    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>pressure_solver.projection_space_size</code>   </td><td class="markdownTableBodyNone">Projection space size for the pressure equation.   </td><td class="markdownTableBodyNone">Positive integer   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>pressure_solver.projection_hold_steps</code>   </td><td class="markdownTableBodyNone">Holding steps of the projection for the pressure equation.   </td><td class="markdownTableBodyNone">Positive integer   </td><td class="markdownTableBodyNone">5    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>pressure_solver.monitor</code>   </td><td class="markdownTableBodyNone">Monitor residuals in the linear solver for the pressure equation.   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>false</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>flow_rate_force.direction</code>   </td><td class="markdownTableBodyNone">Direction of the forced flow.   </td><td class="markdownTableBodyNone">0, 1, 2   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>flow_rate_force.value</code>   </td><td class="markdownTableBodyNone">Bulk velocity or volumetric flow rate.   </td><td class="markdownTableBodyNone">Positive real   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>flow_rate_force.use_averaged_flow</code>   </td><td class="markdownTableBodyNone">Whether bulk velocity or volumetric flow rate is given by the <code>value</code> parameter.   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>freeze</code>   </td><td class="markdownTableBodyNone">Whether to fix the velocity field at initial conditions.   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>false</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>strict_convergence</code>   </td><td class="markdownTableBodyNone">Whether to enforce strict convergence in the linear solvers.   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>false</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>allow_stabilization</code>   </td><td class="markdownTableBodyNone">Whether to allow an initial stabilization phase before enforcing strict convergence.   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>false</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>advection</code>   </td><td class="markdownTableBodyNone">Whether to compute the advection term.   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>true</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>full_stress_formulation</code>   </td><td class="markdownTableBodyNone">Whether to use the full form of the visous stress tensor term.   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>false</code>   </td></tr>
</table>
<h1><a class="anchor" id="case-file_scalar"></a>
Scalar</h1>
<p>The scalar object allows to add a scalar transport equation to the solution. The solution variable is called <code>s</code> by default, but can be controlled by the <code>field_name</code> entry in the case file. In the fld files, it is saved as <code>temperature</code>. Some properties of the object are inherited from <code>fluid</code>: the value of the density, and the output control.</p>
<h2><a class="anchor" id="autotoc_md63"></a>
Material properties</h2>
<p>The scalar equation requires defining additional material properties: the specific heat capacity and thermal conductivity. These are provided as <code>cp</code> and <code>lambda</code>. Similarly to the fluid, one can provide the Peclet number, <code>Pe</code>, as an alternative. In this case, <code>cp</code> is set to 1 and <code>lambda</code> to the inverse of <code>Pe</code>.</p>
<p>As for the fluid, turbulence modelling is enabled by setting the <code>nut_field</code> to the name matching that set for the simulation component with the LES model. Additionally, the turbulent Prandtl number, <code>Pr_t</code> should be set. The eddy viscosity values will be divided by it to produce eddy diffusivity.</p>
<h2><a class="anchor" id="autotoc_md64"></a>
Turbulence modelling</h2>
<p>The configuration is identical to the Fluid, however, one additionally has to provide the value of the turbulent Prandl number via the <code>Pr_t</code> keyword.</p>
<h2><a class="anchor" id="autotoc_md65"></a>
Boundary conditions</h2>
<p>The boundary conditions for the scalar are specified through the <code>boundary_conditions</code> keyword, which follows the same format as the fluid, for specifying the type of the condition and where it is applied. Four types of conditions are available for the scalar:</p>
<ul>
<li><code>dirichlet</code>. Sets the value of the scalar, controlled by the <code>value</code> keyword. <div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;dirichlet&quot;,</div>
<div class="line">  &quot;value&quot;: 1,</div>
<div class="line">  &quot;zone_indices&quot;: [1, 2]</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><code>neumann</code>. Sets the flux of the scalar, controlled by the <code>flux</code> keyword. <div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;neumann&quot;,</div>
<div class="line">  &quot;flux&quot;: 1,</div>
<div class="line">  &quot;zone_indices&quot;: [1, 2]</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><code>user</code>. User boundary condition, see <a class="el" href="../../d6/def/user-file.html#user-file_field-dirichlet-update">further documentation</a>. <div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;user&quot;,</div>
<div class="line">  &quot;zone_indices&quot;: [1, 2]</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="autotoc_md66"></a>
Initial conditions</h2>
<p>The object <code>initial_condition</code> is used to provide initial conditions. It is mandatory. The means of prescribing the values are controlled via the <code>type</code> keyword:</p>
<ol type="1">
<li><code>user</code>, the values are set inside the compiled user file as explained in the <a class="el" href="../../d6/def/user-file.html#user-file_user-ic">user defined initial condition</a> section of the user file documentation.</li>
<li><code>uniform</code>, the value is a constant scalar, looked up under the <code>value</code> keyword.</li>
<li><code><a class="el" href="../../dc/d5f/namespacepoint__zone.html">point_zone</a></code>, the values are set to a constant base value, supplied under the <code>base_value</code> keyword, and then assigned a zone value inside a point zone. The point zone is specified by the <code>name</code> keyword, and should be defined in the <code>case.point_zones</code> object. See more about <a class="el" href="../../da/dd0/point-zones.html">point zones</a>.</li>
<li><code>field</code>, where the initial condition is retrieved from a field file. Works in the same way as for the fluid. See the <a class="el" href="../../dd/d33/case-file.html#case-file_fluid-ic">fluid section</a> for detailed explanations.</li>
</ol>
<h2><a class="anchor" id="autotoc_md67"></a>
Source terms</h2>
<p>The configuration of source terms is the same as for the fluid. A demonstration of using source terms for the scalar can be found in the <code>scalar_mms</code> example.</p>
<h2><a class="anchor" id="autotoc_md68"></a>
Linear solver configuration</h2>
<p>Should be provided as an object under the <code>solver</code> keyword. For available configuration options, see the corresponding documentation for the fliud. A standard choice would be <code>"type": "cg"</code> and <code>"preconditioner": "jacobi"</code>.</p>
<h2><a class="anchor" id="autotoc_md69"></a>
Full parameter table</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Admissible values   </th><th class="markdownTableHeadNone">Default value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>enabled</code>   </td><td class="markdownTableBodyNone">Whether to enable the scalar computation.   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>true</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>name</code>   </td><td class="markdownTableBodyNone">The name associated to the scalar solver.   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone"><code>scalar</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>field_name</code>   </td><td class="markdownTableBodyNone">The name of the solution in the field registry.   </td><td class="markdownTableBodyNone">A string   </td><td class="markdownTableBodyNone"><code>s</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Pe</code>   </td><td class="markdownTableBodyNone">The Peclet number.   </td><td class="markdownTableBodyNone">Positive real   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>cp</code>   </td><td class="markdownTableBodyNone">Specific heat capacity.   </td><td class="markdownTableBodyNone">Positive real   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>lambda</code>   </td><td class="markdownTableBodyNone">Thermal conductivity.   </td><td class="markdownTableBodyNone">Positive real   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>nut_field</code>   </td><td class="markdownTableBodyNone">Name of the turbulent kinematic viscosity field.   </td><td class="markdownTableBodyNone">String   </td><td class="markdownTableBodyNone">Empty string    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Pr_t</code>   </td><td class="markdownTableBodyNone">Turbulent Prandtl number   </td><td class="markdownTableBodyNone">Positive real   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>boundary_types</code>   </td><td class="markdownTableBodyNone">Boundary types/conditions labels.   </td><td class="markdownTableBodyNone">Array of strings   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>initial_condition.type</code>   </td><td class="markdownTableBodyNone">Initial condition type.   </td><td class="markdownTableBodyNone"><code>user</code>, <code>uniform</code>, <code><a class="el" href="../../dc/d5f/namespacepoint__zone.html">point_zone</a></code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>initial_condition.value</code>   </td><td class="markdownTableBodyNone">Value of the velocity initial condition.   </td><td class="markdownTableBodyNone">Real   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>source_terms</code>   </td><td class="markdownTableBodyNone">Array of JSON objects, defining additional source terms.   </td><td class="markdownTableBodyNone">See list of source terms above   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="../../d6/def/namespacegradient__jump__penalty.html" title="Implements gradient_jump_penalty_t.">gradient_jump_penalty</a></code>   </td><td class="markdownTableBodyNone">Array of JSON objects, defining additional gradient jump penalty.   </td><td class="markdownTableBodyNone">See list of gradient jump penalty above   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>advection</code>   </td><td class="markdownTableBodyNone">Whether to compute the advetion term.   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>true</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>solver.type</code>   </td><td class="markdownTableBodyNone">Linear solver for scalar equation.   </td><td class="markdownTableBodyNone"><code>cg</code>, <code>pipecg</code>, <code>bicgstab</code>, <code>cacg</code>, <code>gmres</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>solver.preconditioner.type</code>   </td><td class="markdownTableBodyNone">Linear solver preconditioner for the momentum equation.   </td><td class="markdownTableBodyNone"><code>ident</code>, <code>hsmg</code>, <code>jacobi</code>   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>solver.absolute_tolerance</code>   </td><td class="markdownTableBodyNone">Linear solver convergence criterion for the momentum equation.   </td><td class="markdownTableBodyNone">Positive real   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>solver.maxiter</code>   </td><td class="markdownTableBodyNone">Linear solver max iteration count for the momentum equation.   </td><td class="markdownTableBodyNone">Positive real   </td><td class="markdownTableBodyNone">800    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>solver.projection_space_size</code>   </td><td class="markdownTableBodyNone">Projection space size for the scalar equation.   </td><td class="markdownTableBodyNone">Positive integer   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>solver.projection_hold_steps</code>   </td><td class="markdownTableBodyNone">Holding steps of the projection for the scalar equation.   </td><td class="markdownTableBodyNone">Positive integer   </td><td class="markdownTableBodyNone">5   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md70"></a>
Simulation components</h1>
<p>Simulation components enable the user to perform various additional operations, which are not strictly necessary to run the solver. An example could be computing and output of additional fields, e.g. vorticity.</p>
<p>A more detailed description as well as a full list of available components and their setup is provided in a <a class="el" href="../../d3/d84/simcomps.html">separate page of the manual</a>.</p>
<h1><a class="anchor" id="autotoc_md71"></a>
Point zones</h1>
<p>Point zones enable the user to select GLL points in the computational domain according to some geometric criterion. Two predefined geometric shapes are selectable from the case file, boxes and spheres.</p>
<p>A point zone object defined in the case file can be retrieved from the point zone registry, <code>neko_point_zone_registry</code>, and can be used to perform any zone-specific operations (e.g. localized source term, probing...). User-specific point zones can also be added manually to the point zone registry from the user file.</p>
<p>A more detailed description as well as a full list of available components and their setup is provided in a <a class="el" href="../../da/dd0/point-zones.html">separate page of the manual</a>.</p>
<h1><a class="anchor" id="autotoc_md72"></a>
Runtime statistics</h1>
<p>This object adds the collection of runtime statistics (timings) for identified profiling regions. A region is defined as all functions between a call to <code>profiler_start_region(name, id)</code> and <code>profiler_end_region(name, id)</code>. Neko currently supports 50 regions, with id 1..25 being reserved for internal use.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Admissible values   </th><th class="markdownTableHeadNone">Default value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>enabled</code>   </td><td class="markdownTableBodyNone">Whether to enable gathering of runtime statistics   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>false</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>output_profile</code>   </td><td class="markdownTableBodyNone">Whether to output all gathered profiling data as a CSV file   </td><td class="markdownTableBodyNone"><code>true</code> or <code>false</code>   </td><td class="markdownTableBodyNone"><code>false</code>   </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Neko Manual</a></li><li class="navelem"><a class="el" href="../../dd/d04/user-guide.html">User guide</a></li>
    <li class="footer">Generated on Fri Dec 5 2025 03:49:11 for Neko by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
