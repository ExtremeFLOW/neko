<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Neko: Simulation components</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Neko<span id="projectnumber">&#160;1.99.2</span>
   </div>
   <div id="projectbrief">A portable framework for high-order spectral element flow simulations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d3/d84/simcomps.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Simulation components</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md146">What are simulation components?</a></li>
<li class="level1"><a href="#autotoc_md147">Adding simulation components to the case</a></li>
<li class="level1"><a href="#autotoc_md148">List of simulation components</a></li>
<li class="level1"><a href="#autotoc_md149">Controling execution and file output</a><ul><li class="level2"><a href="#autotoc_md150">Differential operators</a><ul><li class="level3"><a href="#simcomp_derivative">derivative</a></li>
<li class="level3"><a href="#simcomp_curl">curl</a></li>
<li class="level3"><a href="#simcomp_divergence">divergence</a></li>
</ul>
</li>
<li class="level2"><a href="#simcomp_gradient">gradient</a></li>
<li class="level2"><a href="#simcomp_weak_gradient">weak_gradient</a></li>
<li class="level2"><a href="#simcomp_lambda2">lambda2</a></li>
<li class="level2"><a href="#simcomp_probes">probes</a><ul><li class="level3"><a href="#autotoc_md151">Supported types</a></li>
<li class="level3"><a href="#autotoc_md152">Example usage</a></li>
</ul>
</li>
<li class="level2"><a href="#simcomp_field_writer">field_writer</a></li>
<li class="level2"><a href="#simcomp_force_torque">force_torque</a></li>
<li class="level2"><a href="#simcomp_les_model">les_model</a></li>
<li class="level2"><a href="#user_stats">User statistics</a></li>
<li class="level2"><a href="#simcomp_speri">Spectral error indicator</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="autotoc_md146"></a>
What are simulation components?</h1>
<p>Simulation components, or simcomps for short, encapsulate additional functionalities that may be useful for certain cases but not necessary to run the solver. This can include computation and output of additional fields, in-situ post-processing operations, data sampling, etc.</p>
<p>By design, simulation components can tap into every aspect of the simulation, so they can be quite powerful. As the code grows, we expect to add more and more simcomps to the code.</p>
<h1><a class="anchor" id="autotoc_md147"></a>
Adding simulation components to the case</h1>
<p>Each simcomp is defined as a single JSON object at are added to an array of objects called <code>simulation_components</code>, which resides directly under the <code>case</code> object.</p>
<h1><a class="anchor" id="autotoc_md148"></a>
List of simulation components</h1>
<p>The following is a list of simulation components that are currently available in Neko. The list will be updated as new simcomps are added.</p>
<ul>
<li>Differential operators<ul>
<li>Computation of the curl of a vector field <a class="el" href="../../d3/d84/simcomps.html#simcomp_curl">curl</a></li>
<li>Computation of the gradient of a scalar field <a class="el" href="../../d3/d84/simcomps.html#simcomp_gradient">gradient</a></li>
<li>Computation of the weak gradient of a field <a class="el" href="../../d3/d84/simcomps.html#simcomp_weak_gradient">weak_gradient</a></li>
<li>Computation of the derivative of a scalar field <a class="el" href="../../d3/d84/simcomps.html#simcomp_derivative">derivative</a></li>
<li>Computation of the divergence of a vector field <a class="el" href="../../d3/d84/simcomps.html#simcomp_divergence">divergence</a></li>
</ul>
</li>
<li>Computation of \( \lambda_2 \) <a class="el" href="../../d3/d84/simcomps.html#simcomp_lambda2">lambda2</a></li>
<li>Probing of fields at selected points <a class="el" href="../../d3/d84/simcomps.html#simcomp_probes">probes</a></li>
<li>Output of registered fields to an <code>.fld</code> file <a class="el" href="../../d3/d84/simcomps.html#simcomp_field_writer">field_writer</a></li>
<li>Computation of forces and torque on a surface <a class="el" href="../../d3/d84/simcomps.html#simcomp_force_torque">force_torque</a></li>
<li>Computation of subgrid-scale (SGS) eddy viscosity via a SGS model <a class="el" href="../../d3/d84/simcomps.html#simcomp_les_model">les_model</a></li>
<li>User defined components <a class="el" href="../../db/d11/cuda_2dirichlet__kernel_8h.html#ac2cb217184f95ca86456f610f72bd533">user-file_simcomps</a></li>
<li>Fluid statistics simcomp, "fluid_stats", for more details see the <a class="el" href="../../df/d8f/statistics-guide.html">statistics guide</a></li>
<li>Scalar statistics simcomp, "scalar_stats", for more details see the <a class="el" href="../../df/d8f/statistics-guide.html">statistics guide</a></li>
<li>User statistics simcomp, "user_stats" <a class="el" href="../../d3/d84/simcomps.html#user_stats">User statistics</a></li>
<li>Computation of the spectral error indicator <a class="el" href="../../d3/d84/simcomps.html#simcomp_speri">Spectral error indicator</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md149"></a>
Controling execution and file output</h1>
<p>Each simulation component is, by default, executed once per time step to perform associated computations and output. However, this can be modified by using the <code>compute_control</code> and <code>compute_value</code> parameters for the computation and the <code>output_control</code> and <code>output_value</code> for the output to disk. The parameters for the <code>_control</code> values are the same as for the fluid and checkpointing. Additionally, one can set <code>output_control</code> to <code>global</code> and <code>never</code>. The former will sync the <code>output_</code> parameter to that of the fluid. Choosing <code>never</code> will suppress output all together. If no parameters for the <code>output_</code> parameters are provided, they are set to be the same as for <code>compute_</code>. In order to simplify the configuration, the <code>compute_control</code> can be set to <code><a class="el" href="../../d6/d60/namespacefluid__output.html" title="Defines an output for a fluid.">fluid_output</a></code> to sync the computation to the fluid output.</p>
<p>For simcomps that compute 3D fields, the output can be either added to the main <code>.fld</code> file, containing velocity and pressure, or saved to a separate file. For the latter, the <code>output_filename</code> keyword should be provided. One can additionally provide the <code>precision</code> keyword, which can be set to either <code>single</code> or <code>double</code> to control the precision of the written data.</p>
<p>For example, in the <code>tgv</code> example case the <code>curl</code> component is executed once per 50 time steps. The <code>output_</code> parameters are synced to that, and the vorticity fields will be added to the main <code>.fld</code> file. </p><div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;curl&quot;,</div>
<div class="line">  &quot;field_names&quot;: [&quot;u&quot;, &quot;v&quot;, &quot;w&quot;],</div>
<div class="line">  &quot;computed_field&quot;: &quot;vorticity&quot;</div>
<div class="line">  &quot;compute_control&quot;: &quot;tsteps&quot;,</div>
<div class="line">  &quot;compute_value&quot;: 50</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md150"></a>
Differential operators</h2>
<p>There is a set of simcomps that allow one to apply various differential operators on registered fields. They share common configuration traits. The field or fields that the operators is applied to us controlled, respectively, by the <code>field</code> or <code>feilds</code> keyword. The produced fields are also added to the registry, and each operator provides a default name. However, it can be overriden using the <code>computed_field</code> keyword. Operators that output a vector field will register three fields, adding <code>_x</code>, <code>_y</code>, and <code>_z</code> to the base of the name.</p>
<p>All of these simcomps also support saving the result to <code>.fld</code> files. The <a class="el" href="../../d3/d84/simcomps.html#simcomp_field_writer">field_writer</a> simcomp is used for that under the hood, so the associated JSON keywords can be found in its documentation (<code>output_filename</code>, <code>precision</code>).</p>
<h3><a class="anchor" id="simcomp_derivative"></a>
derivative</h3>
<p>Computes the derivative of field along a chosen direction (x, y, or z). The field to derivate is controlled by the <code>field</code> keyword and the direction by the <code>direction</code> keyword. The simcomp will, by default, register the computed derivative in the registry as <code>d[field]_d[direction]</code>, where the values in the brackets correspond to the choice of the user keywords.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;derivative&quot;,</div>
<div class="line">  &quot;field&quot;: &quot;u&quot;,</div>
<div class="line">  &quot;direction&quot;: &quot;y&quot;</div>
<div class="line">  &quot;computed_field&quot;: &quot;dudy&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="simcomp_curl"></a>
curl</h3>
<p>Takes a list of three field names from the <code>fields</code> keyword, and computes the curl. By default, registers the result in <code>curl_x</code>, <code>curl_y</code> and <code>curl_z</code>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;curl&quot;</div>
<div class="line">  &quot;fields&quot;: [&quot;u&quot;, &quot;v&quot;, &quot;w&quot;],</div>
<div class="line">  &quot;computed_field&quot;: &quot;vorticity&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="simcomp_divergence"></a>
divergence</h3>
<p>Takes a list of three field names from the <code>fields</code> keyword, and computes the divergence. By default, registers the result in <code>div</code>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;divergence&quot;</div>
<div class="line">  &quot;fields&quot;: [&quot;u&quot;, &quot;v&quot;, &quot;w&quot;],</div>
<div class="line">  &quot;computed_field&quot;: &quot;continuity&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="simcomp_gradient"></a>
gradient</h2>
<p>Computes the gradient of a field. The field to derivate is controlled by the <code>field</code> keyword. The simcomp will, by default, register the computed components of the gradients in the registry as <code>grad_[field]_x</code>, <code>grad_[field]_y</code>, <code>grad_[field]_z</code> where the value in the brackets corresponds to the choice of the user keyword.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;gradient&quot;</div>
<div class="line">  &quot;field&quot;: &quot;u&quot;,</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="simcomp_weak_gradient"></a>
weak_gradient</h2>
<p>Computes the weak gradient of a field. The weak gradient is value of the gradient multiplied by the local value of the mass matrix. This is how a gradient term appears in the weak formulation of the governing equations. The field to derivate is controlled by the <code>field</code> keyword. The simcomp will, by default, register the computed components of the gradients in the registry as <code>weak_grad_[field]_x</code>, <code>weak_grad_[field]_y</code>, <code>weak_grad_[field]_z</code> where the value in the brackets corresponds to the choice of the user keyword.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;weak_gradient&quot;</div>
<div class="line">  &quot;field&quot;: &quot;u&quot;,</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="simcomp_lambda2"></a>
lambda2</h2>
<p>Computes \( \lambda_2 \) for the velocity field and stores it in the normal output files as the first unused field. This means that \( \lambda_2 \) can be found in the temperature field in then fld files if running without a scalar and s1 if neko is run with one scalar. To output in a different <code>fld</code> series, use the <code>"output_filename"</code> parameter.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;lambda2&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="simcomp_probes"></a>
probes</h2>
<p>Probes selected solution fields at a list of points. This list of points can be generated in a variety of ways, but the most common is to use the <code>csv</code> type.</p>
<p>Mandatory fields for this simcomp are:</p><ul>
<li><code>fields</code>: a list of fields to probe. Should be a list of field names that exist in the registry. Example: <code>"fields": ["u", "v", "p", "s"]</code>.</li>
<li><code>output_file</code>: Name of the file in which to output the probed fields. Must be <code>.csv</code>.</li>
</ul>
<p>It is also possible to set a <code>start_time</code> before which the probes will not be executed (same behavior as the statistics).</p>
<h3><a class="anchor" id="autotoc_md151"></a>
Supported types</h3>
<ul>
<li><code>file</code>: Reads a list of points from a CSV file. The name of the file is provided with the <code>file_name</code> keyword. The CSV file should have the following format: <div class="fragment"><div class="line">x_0, y_0, z_0</div>
<div class="line">x_1, y_1, z_1</div>
<div class="line">...</div>
<div class="line">x_N, y_N, z_N</div>
</div><!-- fragment --> The points are assumed to be in the same units as the simulation.</li>
<li><code>points</code>: Reads a list of points from a JSON file. The points are specified based in the <code>coordinates</code> keyword and should be a list of x,y,z values. The file should have the following format: <div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;points&quot;,</div>
<div class="line">  &quot;coordinates&quot;: [</div>
<div class="line">    0.0, 0.0, 0.0,</div>
<div class="line">    1.0, 0.0, 0.0,</div>
<div class="line">    0.0, 1.0, 0.0,</div>
<div class="line">    0.0, 0.0, 1.0,</div>
<div class="line">    ...</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --> The points are assumed to be in the same units as the simulation.</li>
<li><code>line</code>: Generates a list of points along a line. The line is defined by two points, <code>start</code> and <code>end</code>, and the number of points to generate, <code>amount</code>. The points are generated by linearly interpolating between <code>start</code> and <code>end</code>. The line is defined as: <div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;line&quot;,</div>
<div class="line">  &quot;start&quot;: [0.0, 0.0, 0.0],</div>
<div class="line">  &quot;end&quot;: [1.0, 1.0, 1.0],</div>
<div class="line">  &quot;amount&quot;: 10</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><code>circle</code>: Generates a list of points along a circle. The circle is defined by a center, <code>center</code>, a radius, <code>radius</code> and the normal, <code>normal</code>, the number of points to generate is controlled by <code>amount</code>. The points are generated by rotating a point around the center starting from the specified axis projected onto the circle. The circle is defined: <div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;circle&quot;,</div>
<div class="line">  &quot;center&quot;: [0.0, 0.0, 0.0],</div>
<div class="line">  &quot;radius&quot;: 1.0,</div>
<div class="line">  &quot;normal&quot;: [0.0, 0.0, 1.0],</div>
<div class="line">  &quot;axis&quot;: &quot;x&quot;,</div>
<div class="line">  &quot;amount&quot;: 4</div>
<div class="line">}</div>
</div><!-- fragment --> Leads to the following points: <div class="fragment"><div class="line">1.0, 0.0, 0.0</div>
<div class="line">0.0, 1.0, 0.0</div>
<div class="line">-1.0, 0.0, 0.0</div>
<div class="line">0.0, -1.0, 0.0</div>
</div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="autotoc_md152"></a>
Example usage</h3>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;probes&quot;,</div>
<div class="line">  &quot;compute_control&quot;: &quot;simulationtime&quot;,</div>
<div class="line">  &quot;compute_value&quot;    : 1,</div>
<div class="line">  &quot;fields&quot;: [&quot;w&quot;,&quot;s&quot;],</div>
<div class="line">  &quot;output_file&quot;:  &quot;output.csv&quot;,</div>
<div class="line">  &quot;points&quot;: [</div>
<div class="line">     {</div>
<div class="line">       &quot;type&quot;: &quot;file&quot;,</div>
<div class="line">       &quot;file_name&quot;: &quot;points.csv&quot;</div>
<div class="line">     }</div>
<div class="line">   ],</div>
<div class="line">}</div>
</div><!-- fragment --><p> This probes the fields 'w', and 's' in the points described by points.csv and outputs into output.csv every 1 time units.</p>
<p>The probed information will be saved in the output file in the following format:</p>
<div class="fragment"><div class="line">N_p, N_f, fields[0], fields[1], ..., fields[N_f-1]</div>
<div class="line">p_0_x, p_0_y, p_0_z</div>
<div class="line">p_1_x, p_1_y, p_1_z</div>
<div class="line">...</div>
<div class="line">p_N_p_x, p_N_p_y, p_N_p_z</div>
<div class="line">time_0, p_0_field_0, p_0_field_1, ..., p_0_field_N_f-1</div>
<div class="line">time_0, p_1_field_0, p_1_field_1, ..., p_1_field_N_f-1</div>
<div class="line">...</div>
<div class="line">time_0, p_N_p_field_0, p_N_p_field_1, ..., p_N_p_field_N_f-1</div>
<div class="line">time_1, p_0_field_0, p_0_field_1, ..., p_0_field_N_f-1</div>
<div class="line">time_1, p_1_field_0, p_1_field_1, ..., p_1_field_N_f-1</div>
<div class="line">...</div>
<div class="line">time_N_p, p_N_p_field_0, p_N_p_field_1, ..., p_N_p_field_N_f-1</div>
</div><!-- fragment --><h2><a class="anchor" id="simcomp_field_writer"></a>
field_writer</h2>
<p>Outputs registered 3D fields to an <code>.fld</code> file. Requires a list of field names in the <code>fields</code> keyword. Primarily to be used for outputting new fields defined in the user file. The fields are added to then <code>neko_registry</code> object and are expected to be updated in the user file, or, perhaps, by other simcomps. Since this simcomp does not compute anything <code>compute_</code> configuration is irrelevant. </p><div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;field_writer&quot;,</div>
<div class="line">  &quot;fields&quot;: [&quot;my_field1&quot;, &quot;my_field2&quot;],</div>
<div class="line">  &quot;output_filename&quot;: &quot;myfields&quot;,</div>
<div class="line">  &quot;precision&quot;: &quot;double&quot;,</div>
<div class="line">  &quot;output_control&quot; : &quot;simulation_time&quot;,</div>
<div class="line">  &quot;output_value&quot; : 1.0</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="simcomp_force_torque"></a>
force_torque</h2>
<p>Computes the force on a specified zone and the corresponding torque around a center point. The compute control specifies how often they are computed and printed into the log. Scale specifies a scale for the computed force/torque. Conventient if one wants to scale with the area or similar. long_print is default false and can be set to true to print all digits in the calculation. Subroutines used in the simcomp can be found in <a class="el" href="../../d9/df1/drag__torque_8f90.html">src/qoi/drag_torque.f90</a></p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;force_torque&quot;,</div>
<div class="line">  &quot;zone_id&quot;: 1,</div>
<div class="line">  &quot;center&quot;: [0.0, 0.0, 0.0],</div>
<div class="line">  &quot;zone_name&quot;: &quot;some chosen name, optional&quot;,</div>
<div class="line">  &quot;scale&quot;: 1.0</div>
<div class="line">  &quot;long_print&quot; : false</div>
<div class="line">  &quot;compute_control&quot; : &quot;tsteps&quot;,</div>
<div class="line">  &quot;compute_value&quot; : 10</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="simcomp_les_model"></a>
les_model</h2>
<p>Computes a subgrid eddy viscosity field using an SGS model. **Note*:* The simcomp <em>only</em> computes the eddy viscosity field. You have to select the corresponding <code>nut_field</code> in the fluid and/or scalar JSON object to actually enable LES, see corresponding documentation. The simcomp is controlled by the following keywords:</p>
<ul>
<li><code>model</code>: Selects the SGS model. Currently available models are:<ul>
<li><code>smagorinsky</code>: The standard Smagorinsky model. Configured by the following additional keyword:<ul>
<li><code>c_s</code>: The Smagorinsky constant, defaults to 0.17.</li>
</ul>
</li>
<li><code><a class="el" href="../../d4/d9c/namespacedynamic__smagorinsky.html" title="Implements dynamic_smagorinsky_t.">dynamic_smagorinsky</a></code>: The dynamic Smagorinsky model.<ul>
<li><code>test_filter</code>: The test filter for the dynamic Smagorinsky model</li>
</ul>
</li>
<li><code>vreman</code>: The Vreman model. Configured by the following additional keyword:<ul>
<li><code>c</code>: The model constant, defaults to 0.07.</li>
</ul>
</li>
<li><code>sigma</code>: The Sigma model. Configured by the following additional keyword:<ul>
<li><code>c</code>: The model constant, defaults to 1.35.</li>
</ul>
</li>
<li><code>wale</code>: The WALE model. Configured by the following additional keyword:<ul>
<li><code>c_w</code>: The WALE constant, defaults to 0.55.</li>
</ul>
</li>
</ul>
</li>
<li><code>les_delta</code>: Selects the way to compute the LES filter length scale. Currently three alternatives are provided and the default one is <code>pointwise</code> if nothing is specified:<ul>
<li><code>pointwise</code>: Computes a local value based on the spacing of the GLL nodes.</li>
<li><code>elementwise_average</code>: Computes a single value for the whole element based on the average spacing of the GLL nodes within the element.</li>
<li><code>elementwise_max</code>: Computes a single value for the whole element based on the maximum spacing of the GLL nodes within the element. The <code>les_delta</code> field is added to the registry and written to the .fld files.</li>
</ul>
</li>
<li><code>nut_field</code>: The name of the SGS eddy viscosity field added to the registry. Defaults to <code>nut</code>. This allows to have two different SGS models active, saved to different fields. For example, one for the scalar and one to the fluid.</li>
<li><p class="startli"><code>extrapolation</code>: Whether or not extrapolate the velocity to compute the eddy viscosity.</p><ul>
<li><code>true</code>: extrapolate the velocity as the same order as the time scheme.</li>
<li><code>false</code>: the default option, disable the extrapolation. In this case, the estimation of the eddy viscosity is of first order, while circumvent the risk of unstable extrapolation.</li>
</ul>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;les_model&quot;</div>
<div class="line">  &quot;model&quot;: &quot;smagorinsky&quot;,</div>
<div class="line">  &quot;delta_type&quot;: &quot;pointwise&quot;,</div>
<div class="line">  &quot;output_control&quot; : &quot;never&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><p class="startli">Please also note that for the dynamic Smagorinsky model, one needs to specify the test filter in the following way for the Boyd filter as the test filter (one could also use "nonBoyd" as the option): </p><div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;les_model&quot;</div>
<div class="line">  &quot;model&quot;: &quot;dynamic_smagorinsky&quot;,</div>
<div class="line">  &quot;test_filter&quot;: {</div>
<div class="line">     &quot;filter&quot;: {</div>
<div class="line">       &quot;type&quot;: &quot;elementwise&quot;,</div>
<div class="line">       &quot;elementwise_filter_type&quot;: &quot;Boyd&quot;</div>
<div class="line">     }</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p> And one could not change the default test filter's kernel through the case file. If one needs to do so, he/she needs to dig into the code in src/les/dynamic_smagorinksy.f90.</p>
</li>
</ul>
<h2><a class="anchor" id="user_stats"></a>
User statistics</h2>
<p>Allows to compute the time-average of an arbitrary collection of fields form the field registry. Just like the <code><a class="el" href="../../d9/d7d/namespacefluid__stats.html" title="Computes various statistics for the fluid fields. We use the Reynolds decomposition for a field u =  ...">fluid_stats</a></code> simcomp, it supports spatial averaging across homogeneous directions, both 1D and 2D. The fields to average are prescribed via the <code>fields</code> keyword, and the optional averaging direction(s) via the <code>avg_direction</code>, which can be <code>x</code>, <code>y</code>, <code>z</code>, <code>xy</code>, <code>xz</code> or <code>yz</code>. Averaging across two directions will lead to the average being saved as a .csv, whereas a 2D .fld file will be produced when averaging across only one axis. The filename is controlled by the <code>output_file</code> keyword and default to <code><a class="el" href="../../df/ded/namespaceuser__stats.html" title="Implements the user_stats_t type.">user_stats</a></code>. We encourage reading the [statistics guide](<a class="el" href="../../df/d8f/statistics-guide.html">Statistics guide</a>) for further details regarding how statistics are computed in Neko.</p>
<p>Keep in mind that simcomps execute before <code>usercompute</code>, so if you update some custom averaged field in that routine, it will not affect the average until the next time step. You can consider using <code>userpreprocess</code> instead, which runs at the beginning of the time step.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;user_stats&quot;,</div>
<div class="line">  &quot;fields&quot;: [&quot;s&quot;],</div>
<div class="line">  &quot;avg_direction&quot;: &quot;xz&quot;,</div>
<div class="line">  &quot;output_file&quot;: &quot;s_average&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="simcomp_speri"></a>
Spectral error indicator</h2>
<p>Computes the spectral error indicator as developed by Mavriplis (1989) (<a href="https://doi.org/10.1007/978-3-663-13975-1_34">https://doi.org/10.1007/978-3-663-13975-1_34</a>). This is an a posteriori error measure, based on the local properties of the spectral solution. This method formally only gives an indication of the error.</p>
<p>The spectral error indicator is computed for the 3 velocity fields, resulting in 3 additional fields appended to the field files.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;spectral_error&quot;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Neko Manual</a></li><li class="navelem"><a class="el" href="../../dd/d04/user-guide.html">User guide</a></li>
    <li class="footer">Generated on Sun Dec 21 2025 03:53:02 for Neko by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
