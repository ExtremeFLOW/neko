<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Neko: Simulation components</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Neko<span id="projectnumber">&#160;0.9.99</span>
   </div>
   <div id="projectbrief">A portable framework for high-order spectral element flow simulations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d3/d84/simcomps.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Simulation components</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md75">What are simulation components?</a></li>
<li class="level1"><a href="#autotoc_md76">Adding simulation components to the case</a></li>
<li class="level1"><a href="#autotoc_md77">List of simulation components</a></li>
<li class="level1"><a href="#autotoc_md78">Controling execution and file output</a><ul><li class="level2"><a href="#simcomp_vorticity">vorticity</a></li>
<li class="level2"><a href="#simcomp_lambda2">lambda2</a></li>
<li class="level2"><a href="#simcomp_probes">probes</a><ul><li class="level3"><a href="#autotoc_md79">Supported types:</a></li>
<li class="level3"><a href="#autotoc_md80">Example usage:</a></li>
</ul>
</li>
<li class="level2"><a href="#simcomp_field_writer">field_writer</a></li>
<li class="level2"><a href="#simcomp_derivative">derivative</a></li>
<li class="level2"><a href="#simcomp_force_torque">force_torque</a></li>
<li class="level2"><a href="#simcomp_weak_grad">weak_grad</a></li>
<li class="level2"><a href="#simcomp_speri">Spectral error indicator</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="autotoc_md75"></a>
What are simulation components?</h1>
<p>Simulation components, or simcomps fo short, incapsulate additional functionality that may be useful for certain cases but not necessary to run the solver. This can include computation and output of additional fields, in-situ post-processing operations, data sampling, etc.</p>
<p>By design, simulation components can tap into every aspect of the simulation, so they can be quite powerful. As the code grows, we expect to add more and more simcomps to the code.</p>
<h1><a class="anchor" id="autotoc_md76"></a>
Adding simulation components to the case</h1>
<p>Each simcomp is defined as a single JSON object at are added to an array of objects called <code>simulation_components</code>, which resides directly under the <code>case</code> object.</p>
<h1><a class="anchor" id="autotoc_md77"></a>
List of simulation components</h1>
<p>The following is a list of simulation components that are currently available in Neko. The list will be updated as new simcomps are added.</p>
<ul>
<li>Computation of vorticity field <a class="el" href="../../d3/d84/simcomps.html#simcomp_vorticity">vorticity</a></li>
<li>Computation of \( \lambda_2 \) <a class="el" href="../../d3/d84/simcomps.html#simcomp_lambda2">lambda2</a></li>
<li>Probing of fields at selected points <a class="el" href="../../d3/d84/simcomps.html#simcomp_probes">probes</a></li>
<li>Output of registered fields to an <code>.fld</code> file <a class="el" href="../../d3/d84/simcomps.html#simcomp_field_writer">field_writer</a></li>
<li>Computation of the derivative of a field <a class="el" href="../../d3/d84/simcomps.html#simcomp_derivative">derivative</a></li>
<li>Computation of forces and torque on a surface <a class="el" href="../../d3/d84/simcomps.html#simcomp_force_torque">force_torque</a></li>
<li>Computation of the weak gradient of a field <a class="el" href="../../d3/d84/simcomps.html#simcomp_weak_grad">weak_grad</a></li>
<li>User defined components <a class="el" href="../../d6/def/user-file.html#user-file_simcomps">User defined simulation components</a></li>
<li>Fluid statistics simcomp, "fluid_stats", for more details see the <a class="el" href="../../df/d8f/statistics-guide.html">statistics guide</a></li>
<li>Computation of the spectral error indicator <a class="el" href="../../d3/d84/simcomps.html#simcomp_speri">Spectral error indicator</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md78"></a>
Controling execution and file output</h1>
<p>Each simulation component is, by default, executed once per time step to perform associated computations and output. However, this can be modified by using the <code>compute_control</code> and <code>compute_value</code> parameters for the computation and the <code>output_control</code> and <code>output_value</code> for the output to disk. The parameters for the <code>_control</code> values are the same as for the fluid and checkpointing. Additionally, one can set <code>output_control</code> to <code>global</code> and <code>never</code>. The former will sync the <code>output_</code> parameter to that of the fluid. Choosing <code>never</code> will suppress output all together. If no parameters for the <code>output_</code> parameters are provided, they are set to be the same as for <code>compute_</code>. In order to simplify the configuration, the <code>compute_control</code> can be set to <code><a class="el" href="../../d6/d60/namespacefluid__output.html" title="Defines an output for a fluid.">fluid_output</a></code> to sync the computation to the fluid output.</p>
<p>For simcomps that compute 3D fields, the output can be either added to the main <code>.fld</code> file, containing velocity and pressure, or saved to a separate file. For the latter, the <code>output_filename</code> keyword should be provided. One can additionally provide the <code>precision</code> keyword, which can be set to either <code>single</code> or <code>double</code> to control the precision of the written data.</p>
<p>For example, in the <code>tgv</code> example case the <code>vorticity</code> component is executed once per 50 time steps. The <code>output_</code> parameters are synced to that, and the vorticity fields will be added to the main <code>.fld</code> file. </p><div class="fragment"><div class="line">{</div>
<div class="line">    &quot;type&quot;: &quot;vorticity&quot;,</div>
<div class="line">    &quot;compute_control&quot;: &quot;tsteps&quot;,</div>
<div class="line">    &quot;compute_value&quot;: 50</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="simcomp_vorticity"></a>
vorticity</h2>
<p>Computes the vorticity field an stores in the field registry as <code>omega_x</code>, <code>omega_y</code> and <code>omega_z</code>. By default, appends the 3 vorticity fields to the field files as scalars. To output in a different <code>fld</code> series, use the <code>"output_filename"</code> parameter.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;vorticity&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="simcomp_lambda2"></a>
lambda2</h2>
<p>Computes \( \lambda_2 \) for the velocity field and stores it in the normal output files as the first unused field. This means that \( \lambda_2 \) can be found in the temperature field in then fld files if running without a scalar and s1 if neko is run with one scalar. To output in a different <code>fld</code> series, use the <code>"output_filename"</code> parameter.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;lambda2&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="simcomp_probes"></a>
probes</h2>
<p>Probes selected solution fields at a list of points. This list of points can be generated in a variety of ways, but the most common is to use the <code>csv</code> type.</p>
<h3><a class="anchor" id="autotoc_md79"></a>
Supported types:</h3>
<ul>
<li><code>file</code>: Reads a list of points from a CSV file. The name of the file is provided with the <code>file_name</code> keyword. The CSV file should have the following format: <div class="fragment"><div class="line">x_0, y_0, z_0</div>
<div class="line">x_1, y_1, z_1</div>
<div class="line">...</div>
<div class="line">x_N, y_N, z_N</div>
</div><!-- fragment --> The points are assumed to be in the same units as the simulation.</li>
</ul>
<p><code>points</code>: Reads a list of points from a JSON file. The points are specified based in the <code>coordinates</code> keyword and should be a list of x,y,z values. The file should have the following format: </p><div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;points&quot;,</div>
<div class="line">  &quot;coordinates&quot;: [</div>
<div class="line">    0.0, 0.0, 0.0,</div>
<div class="line">    1.0, 0.0, 0.0,</div>
<div class="line">    0.0, 1.0, 0.0,</div>
<div class="line">    0.0, 0.0, 1.0,</div>
<div class="line">    ...</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><p> The points are assumed to be in the same units as the simulation.</p><ul>
<li><code>line</code>: Generates a list of points along a line. The line is defined by two points, <code>start</code> and <code>end</code>, and the number of points to generate, <code>amount</code>. The points are generated by linearly interpolating between <code>start</code> and <code>end</code>. The line is defined as: <div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;line&quot;,</div>
<div class="line">  &quot;start&quot;: [0.0, 0.0, 0.0],</div>
<div class="line">  &quot;end&quot;: [1.0, 1.0, 1.0],</div>
<div class="line">  &quot;amount&quot;: 10</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><code>circle</code>: Generates a list of points along a circle. The circle is defined by a center, <code>center</code>, a radius, <code>radius</code> and the normal, <code>normal</code>, the number of points to generate is controlled by <code>amount</code>. The points are generated by rotating a point around the center starting from the specified axis projected onto the circle. The circle is defined: <div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;circle&quot;,</div>
<div class="line">  &quot;center&quot;: [0.0, 0.0, 0.0],</div>
<div class="line">  &quot;radius&quot;: 1.0,</div>
<div class="line">  &quot;normal&quot;: [0.0, 0.0, 1.0],</div>
<div class="line">  &quot;axis&quot;: &quot;x&quot;,</div>
<div class="line">  &quot;amount&quot;: 4</div>
<div class="line">}</div>
</div><!-- fragment --> Leads to the following points: <div class="fragment"><div class="line">1.0, 0.0, 0.0</div>
<div class="line">0.0, 1.0, 0.0</div>
<div class="line">-1.0, 0.0, 0.0</div>
<div class="line">0.0, -1.0, 0.0</div>
</div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="autotoc_md80"></a>
Example usage:</h3>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;probes&quot;,</div>
<div class="line">  &quot;compute_control&quot;: &quot;simulationtime&quot;,</div>
<div class="line">  &quot;compute_value&quot;    : 1,</div>
<div class="line">  &quot;fields&quot;: [&quot;w&quot;,&quot;s&quot;],</div>
<div class="line">  &quot;output_file&quot;:  &quot;output.csv&quot;,</div>
<div class="line">  &quot;points&quot;: [</div>
<div class="line">     {</div>
<div class="line">       &quot;type&quot;: &quot;file&quot;,</div>
<div class="line">       &quot;file_name&quot;: &quot;points.csv&quot;</div>
<div class="line">     }</div>
<div class="line">   ],</div>
<div class="line">}</div>
</div><!-- fragment --><p> This probes the fields 'w', and 's' in the points described by points.csv and outputs into output.csv every 1 time units.</p>
<p>The probed information will be saved in the output file in the following format:</p>
<div class="fragment"><div class="line">N_p, N_f, fields[0], fields[1], ..., fields[N_f-1]</div>
<div class="line">p_0_x, p_0_y, p_0_z</div>
<div class="line">p_1_x, p_1_y, p_1_z</div>
<div class="line">...</div>
<div class="line">p_N_p_x, p_N_p_y, p_N_p_z</div>
<div class="line">time_0, p_0_field_0, p_0_field_1, ..., p_0_field_N_f-1</div>
<div class="line">time_0, p_1_field_0, p_1_field_1, ..., p_1_field_N_f-1</div>
<div class="line">...</div>
<div class="line">time_0, p_N_p_field_0, p_N_p_field_1, ..., p_N_p_field_N_f-1</div>
<div class="line">time_1, p_0_field_0, p_0_field_1, ..., p_0_field_N_f-1</div>
<div class="line">time_1, p_1_field_0, p_1_field_1, ..., p_1_field_N_f-1</div>
<div class="line">...</div>
<div class="line">time_N_p, p_N_p_field_0, p_N_p_field_1, ..., p_N_p_field_N_f-1</div>
</div><!-- fragment --><h2><a class="anchor" id="simcomp_field_writer"></a>
field_writer</h2>
<p>Outputs registered 3D fields to an <code>.fld</code> file. Requires a list of field names in the <code>fields</code> keyword. Primarily to be used for outputting new fields defined in the user file. The fields are added to then <code>neko_field_registry</code> object and are expected to be updated in the user file, or, perhaps, by other simcomps. Since this simcomp does not compute anything <code>compute_</code> configuration is irrelevant. </p><div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;field_writer&quot;,</div>
<div class="line">  &quot;fields&quot;: [&quot;my_field1&quot;, &quot;my_field2&quot;],</div>
<div class="line">  &quot;output_filename&quot;: &quot;myfields&quot;,</div>
<div class="line">  &quot;precision&quot;: &quot;double&quot;,</div>
<div class="line">  &quot;output_control&quot; : &quot;simulation_time&quot;,</div>
<div class="line">  &quot;output_value&quot; : 1.0</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="simcomp_derivative"></a>
derivative</h2>
<p>Computes the derivative of field along a chosen direction (x, y, or z). The field to derivate is controlled by the <code>field</code> keyword and the direction by the <code>direction</code> keyword. The simcomp will register the computed derivatives in the registry as <code>d[field]_d[direction]</code>, where the values in the brackets correspond to the choice of the user keywords. Supports writing the computed fields to disk via the usual common keywords. The resulting field will be appended as a scalar to the field files. To output in a different <code>fld</code> series, use the <code>"output_filename"</code> parameter.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;derivative&quot;,</div>
<div class="line">  &quot;field&quot;: &quot;u&quot;,</div>
<div class="line">  &quot;direction&quot;: &quot;y&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="simcomp_force_torque"></a>
force_torque</h2>
<p>Computes the force on a specified zone and the corresponding torque around a center point. The compute control specifies how often they are computed and printed into the log. Scale specifies a scale for the computed force/torque. Conventient if one wants to scale with the area or similar. long_print is default false and can be set to true to print all digits in the calculation. Subroutines used in the simcomp can be found in <a class="el" href="../../d9/df1/drag__torque_8f90.html">src/qoi/drag_torque.f90</a></p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;force_torque&quot;,</div>
<div class="line">  &quot;zone_id&quot;: 1,</div>
<div class="line">  &quot;center&quot;: [0.0, 0.0, 0.0],</div>
<div class="line">  &quot;zone_name&quot;: &quot;some chosen name, optional&quot;,</div>
<div class="line">  &quot;scale&quot;: 1.0</div>
<div class="line">  &quot;long_print&quot; : false</div>
<div class="line">  &quot;compute_control&quot; : &quot;tsteps&quot;,</div>
<div class="line">  &quot;compute_value&quot; : 10</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="simcomp_weak_grad"></a>
weak_grad</h2>
<p>Computes the weak gradient of a field. The weak gradient is value of the gradient multiplied by the local value of the mass matrix. This is how a gradient term appears in the weak formulation of the governing equations. The field to derivate is controlled by the <code>field</code> keyword. The simcomp will register the computed components of the gradients in the registry as <code>weak_grad_[field]_x</code>, <code>weak_grad_[field]_y</code>, <code>weak_grad_[field]_z</code> where the value in the brackets corresponds to the choice of the user keyword. Supports writing the computed fields to disk via the usual common keywords.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;weak_gradient&quot;</div>
<div class="line">  &quot;field&quot;: &quot;u&quot;,</div>
<div class="line">  &quot;output_control&quot; : &quot;never&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="simcomp_speri"></a>
Spectral error indicator</h2>
<p>Computes the spectral error indicator as developed by Mavriplis (1989) (<a href="https://doi.org/10.1007/978-3-663-13975-1_34">https://doi.org/10.1007/978-3-663-13975-1_34</a>). This is an a posteriori error measure, based on the local properties of the spectral solution. This method formally only gives an indication of the error.</p>
<p>The spectral error indicator is computed for the 3 velocity fields, resulting in 3 additional fields appended to the field files.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;spectral_error&quot;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Neko Manual</a></li><li class="navelem"><a class="el" href="../../dd/d04/user-guide.html">User guide</a></li>
    <li class="footer">Generated on Sat Dec 21 2024 03:36:07 for Neko by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
