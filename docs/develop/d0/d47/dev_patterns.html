<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Neko: Programming patterns and conventions</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Neko<span id="projectnumber">&#160;0.9.99</span>
   </div>
   <div id="projectbrief">A portable framework for high-order spectral element flow simulations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d0/d47/dev_patterns.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Programming patterns and conventions</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md15">A. Naming</a></li>
<li class="level1"><a href="#autotoc_md16">B. Scope</a></li>
<li class="level1"><a href="#autotoc_md17">C. Constructors and destructors.</a></li>
<li class="level1"><a href="#autotoc_md18">D. Documentation</a></li>
<li class="level1"><a href="#autotoc_md19">E. Design</a></li>
</ul>
</div>
<div class="textblock"><p>This section aims to summarize the programming conventions in Neko to guide all developers into writing code with good style and facilitate the reuse of the same programming patterns throughout the code base. It is a good idea to check your code against the guidelines here before opening a PR.</p>
<p>It should be noted that these are note followed universally throughout the code base as of now, but we should at least make all new code as clean as possible.</p>
<h1><a class="anchor" id="autotoc_md15"></a>
A. Naming</h1>
<ol type="1">
<li>Generally all names are lowercase, connected with <code>_</code> when needed. Some exceptions take place, e.g. <code>Re</code> for the Reynolds number and <code>Xh</code> for the function space, but these should be kept to a minimum.</li>
<li>Follow established naming conventions for certain types. For example, <code>Xh</code> for the function space. <br  />
</li>
<li><p class="startli">Use easy-to-remember unambiguous variable names. Avoid abbreviations unless they are universally understandable (e.g. RANS).</p>
<p class="startli">The basic rationale is that code is read much more often than it is written, so clarity is very important. Moreover, it reduces the cognitive load of the developers since one does not have to remember the abbreviations, which often follow no logic. Longer variable names are also no longer a practical issue due to assistance from IDEs. Moreover, there is always the option to use <code>associate</code>, if contracting a variable name is really necessary.</p>
<p class="startli"><em>Antipattern</em>: <code>usr</code>, <code>msh</code> , <code>intrp</code>, <code>tnsr</code>.</p>
<p class="startli"><em>Pattern</em>: <code>user</code>, <code>mesh</code> , <code>interpolate</code>, <code>tensor</code>.</p>
<p class="startli">This rule is</p><ul>
<li>Critical to observe for all keywords added to the JSON case file without exceptions.</li>
<li>Very important to observe in any code, which is intended as <code>public</code>, particularly interfaces.</li>
<li>Desirable to observe even for code not derictly exposed to the outside world.</li>
</ul>
</li>
<li>All derived types should end with <code>_t</code> in the name.</li>
<li>For a module implementing type <code>mytype_t</code>, the module should reside in <code>mytype.f90</code> and the name of the module should be <code>mytype</code>.</li>
<li><p class="startli">Prepend the implementations of type-bound procedures (TBPs) with the name of the type, sans the <code>_t</code>.</p>
<p class="startli">This may lead to long names when both the name of the type and of the procedure by themselves have long names. But since this name is fully internal, it is not a major concern. By following the pattern, we never have to think how to choose the name.</p>
<p class="startli"><em>Antipattern</em>:</p>
<div class="fragment"><div class="line"><span class="keyword">type</span>, <span class="keyword">public</span> :: interpolator_t</div>
<div class="line"> <span class="keyword">contains</span></div>
<div class="line">   <span class="keywordtype">procedure</span>, pass(this) :: init =&gt; interp_init</div>
<div class="line">   <span class="keywordtype">procedure</span>, pass(this) :: free =&gt; interp_free</div>
<div class="line">   <span class="keywordtype">procedure</span>, pass(this) :: map =&gt; interpolate</div>
<div class="line"><span class="keyword">end type</span></div>
</div><!-- fragment --><p class="startli"><em>Pattern</em>:</p>
<div class="fragment"><div class="line"><span class="keyword">type</span>, <span class="keyword">public</span> :: interpolator_t</div>
<div class="line"> <span class="keyword">contains</span></div>
<div class="line">   <span class="keywordtype">procedure</span>, pass(this) :: init =&gt; interpolator_init</div>
<div class="line">   <span class="keywordtype">procedure</span>, pass(this) :: free =&gt; interpolator_free</div>
<div class="line">   <span class="keywordtype">procedure</span>, pass(this) :: map =&gt; interpolator_map</div>
<div class="line"><span class="keyword">end type</span></div>
</div><!-- fragment --></li>
<li>For TBPs or type components that are <code>private</code> or just generally intended as internal to the type, add an underscore to the end of name. Whe you wish to add a getter for the component, it can be called the same name as the component, sans the underscore.</li>
<li>Use <code>init</code> for constructor TBPs.</li>
<li>Use <code>free</code> for destructor TBPs.</li>
<li>The dummy argument, which is <code>pass</code>ed to TBPs should be called <code>this</code>.</li>
</ol>
<h1><a class="anchor" id="autotoc_md16"></a>
B. Scope</h1>
<ol type="1">
<li><p class="startli">Always use <code>only</code> when <code>using</code> something from another module. The <code>neko</code> module is an exception and imports everything. Additionally, current compiler limitations make it impossible to use <code>only</code> with <code>comm</code> and <code>device</code>.</p>
<p class="startli">This latter is done so that the user <code>.f90</code> files need only <code>use</code> the <code>neko</code> module to get access to everything.</p>
</li>
<li>All modules must have <code>implicit none</code> at module level.</li>
<li>All modules should be <code>private</code> at module level.</li>
<li><p class="startli">Apply own taste and judgement regarding which procedures or components should be <code>private</code>.</p>
<p class="startli">We are generally quite permissive in terms of access and rely on the developers' good judgement to not mess with the types in the wrong way. That being said, using <code>private</code> is not discouraged in any way.</p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md17"></a>
C. Constructors and destructors.</h1>
<ol type="1">
<li>If the type has a destructor, the constructor must begin with calling the destructor.</li>
<li>Implement constructors and destructors as TBPs. This may change in the future, but is currently the safest and most OOP-friendly way to do this.</li>
<li>Do not use the <code>final</code> attribute for destructors, the compilers don't support it well.</li>
<li>If a base abstract class needs a constructor, call it <code>init_base</code>. Call the destructor <code>free_base</code>.</li>
<li><p class="startli">For types initializing from JSON, let <code>init</code> be the constructor from the <code>json_file</code> type and <code>init_from_components</code> a constructor directly for component types. The <code>init</code> constructor should parse the JSON and the call <code>init_from_components</code>.</p>
<p class="startli">This way we always have constructors for concrete types that are independent of JSON.</p>
</li>
<li>In the type hierarchy, <code>init</code> should be the name of the constructor, which is introduced as a deferred procedure in the base abstract class. Same for <code>free</code> for the destructor.</li>
<li>All type components should be fully initialized in the constructor, e.g. pointers should be associated, allocatable types allocated, etc. This implies that the constructor interface should be sufficient for the type to fully take care of its own initialization.</li>
</ol>
<h1><a class="anchor" id="autotoc_md18"></a>
D. Documentation</h1>
<ol type="1">
<li>All procedures and interfaces must be documented, with the <em>minimal</em> requirement being a one-liner telling what the procedure does followed by <code>@param</code>s describing all the dummy arguments.</li>
<li>Feel free to add more documentation under <code>@details</code> or other Doxygen decorators. It is highly encouraged.</li>
<li>The one-liner describing the TBP should also be in the type definition. It is best to match the text in both of these places, since it is unclear which one will be picked up by Doxygen.</li>
<li>When a module implements one type, the documentation should be for the type. The module documentation can simply be "implements type `mytype_t`".</li>
<li>All types must have a docstring describing its purpose. The more detailed the better.</li>
<li><p class="startli">All components of the type should be documented. Put the docstring above the component.</p>
<p class="startli">The alternative is to put it on the same line as the component, but it only works for short docstrings and cannot be multiline. Since a future component may require a long docstring, and mixing the styles does not look nice, it is better to default to putting the string above.</p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md19"></a>
E. Design</h1>
<p>The points here are mostly things to consider rather than strict rules. Hopefully, they can guide towards better implementation.</p>
<ol type="1">
<li><p class="startli">For types doing have computations, consider creating separate subroutines for each compute backend, and putting them in separate files in the <code>bcknd</code>.</p>
<p class="startli">This way nitty-gritty optimisation can happen in <code>bcknd</code>, whereas the main code for the type is kept clean.</p>
<p class="startli">Try to add support for as many backends as possible. CPU-only will be merged, but should throw a clear error message when run on an accelerator.</p>
</li>
<li><p class="startli">Wrap legacy code with wrappers following correct naming conventions.</p>
<p class="startli">We will surely leverage the fact that Neko is written in Fortran, and lift some old Nek5000 code to quickly add some functionalities. This old code should be in an internal subroutine and called from a wrapper.</p>
</li>
<li>If you find yourself using <code>optional</code> dummy arguments, consider whether it makes more sense to split the code into separate procedures instead. However, <code>optional</code> is not as such disapproved of.</li>
<li><p class="startli">Follow the single responsibility principle for types.</p>
<p class="startli">For example, don't mix I\O and other functionality into one type. It is very common and completely fine to create helper types encapsulating some necessary functionality. Don't try to map types to "real-world concepts", that doesn't work.</p>
<p class="startli">This point represents the S in SOLID, which is a set of design principles for types. Highly recommended to get acquainted with all of them.</p>
</li>
<li><p class="startli">When encountering code repetition, consider whether these two pieces of code will likely change at different rates and different reasons in the future. If so, code repetition is fine, it will eventually cease to exist naturally.</p>
<p class="startli">True code duplication is when a change in one place will also necessary a change in the other. </p>
</li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Neko Manual</a></li><li class="navelem"><a class="el" href="../../dc/d70/developer-guide.html">Developer guide</a></li>
    <li class="footer">Generated on Mon Dec 30 2024 03:38:07 for Neko by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
