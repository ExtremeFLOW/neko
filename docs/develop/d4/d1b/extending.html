<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Neko: Extending neko</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Neko<span id="projectnumber">&#160;1.99.1</span>
   </div>
   <div id="projectbrief">A portable framework for high-order spectral element flow simulations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d4/d1b/extending.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Extending neko</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In addition to compiling the user file, <code>makeneko</code> can also compile extra <code>.f90</code> files containing Fortran modules and <code>.cu/.hip</code> files containing CUDA/HIP kernels. A common use of this is to separate out functionality needed by the user file into individual source files. However, you can also use this feature to extend Neko's core functionality.</p>
<p>Specifically, you can write modules that implement custom components such as LES models, wall models, or simulation components. These modules can then be configured directly via the case file's JSON input—just like Neko's built-in components.</p>
<p>Of course, you could also achieve this by modifying Neko's source code directly. But that comes with some drawbacks:</p>
<ul>
<li>You need to manually integrate your new files into Neko's build system.</li>
<li>Updating Neko via Git becomes more complex, as you'll need to resolve merge conflicts between your changes and upstream updates.</li>
<li>To avoid that hassle, you would have to open a pull request and merge your changes into Neko—though this may not be your intention. Or it might be to small in scope to qualify for being included.</li>
</ul>
<p>Extending Neko with <code>makeneko</code> is quite easy, but not everything in the code supports this. Here is a list of things you can implement.</p>
<ul>
<li>LES models (<code>les_model_t</code> descendants).</li>
<li>Wall models (<code>wall_model_t</code> descendants).</li>
<li>Simulation components (<code>simulation_component_t</code> descendants).</li>
<li>Source terms (<code>source_term_t</code> descendants).</li>
<li>Point zones (<code>point_zone_t</code> descendants).</li>
</ul>
<p>This list will hopefully be extended later. Notable omissions are scalar and fluid schemes, so currently you cannot add new solvers like this.</p>
<p>To implement a new type, the easiest thing is to start by copying over the <code>.f90</code> of an already existing type, renaming things inside and then adding the functionality you want (e.g. the particular form of the source term). When you are done, two special subroutines have to be added to you module. To make explaining easier, let us assume that your module is called <code>mymodule</code> and the new type <code>mytype</code>.</p>
<ul>
<li>All the types in the list above have a routine called <code>register_*</code>, where the <code>*</code> is replaced by the name of the type, for example, <code>register_source_term</code>.</li>
<li>The also provide a procedure interface called <code>*_allocate</code>, e.g. <code>source_term_allocate</code>.</li>
</ul>
<p>Both of these routines should be brought into the the new modules with <code>use</code> statements. Then, two routines need to be defined in the module.</p>
<ul>
<li><p class="startli">One is just an allocator for our new type. The name of the routine is arbitrary.</p>
<div class="fragment"><div class="line"><span class="keyword">subroutine </span>mytype_allocate(obj)</div>
<div class="line">  <span class="keywordtype">class</span>(source_term_t), <span class="keywordtype">allocatable</span>, <span class="keywordtype">intent(inout)</span> :: obj</div>
<div class="line"> </div>
<div class="line">  <span class="comment">! The only thing the routine does is allocate a polymorphic object to our</span></div>
<div class="line">  <span class="comment">! type.</span></div>
<div class="line">  <span class="keyword">allocate</span>(mytype_t::obj)</div>
<div class="line"><span class="keyword">end subroutine </span></div>
</div><!-- fragment --></li>
<li><p class="startli">The second routine uses the one above to register the type with Neko. It <em>has</em> to be called <code>mymodule_register_types</code>, where <code>mymodule</code> coincides with the name of our module.</p>
<div class="fragment"><div class="line"><span class="keyword">subroutine </span>mymodel_register_types()</div>
<div class="line">  <span class="comment">! Just a helper variable, not that we use the *_allocate routine, here</span></div>
<div class="line">  <span class="comment">! for the source_term_t type, as an example</span></div>
<div class="line">  <span class="keywordtype">procedure</span>(source_term_allocate), <span class="keywordtype">pointer</span> :: allocator</div>
<div class="line"> </div>
<div class="line">  <span class="comment">! Point to our allocator</span></div>
<div class="line">  allocator =&gt; my_source_term_allocate</div>
<div class="line"> </div>
<div class="line">  <span class="comment">! Based on this the name of the source term will be &quot;mytype&quot;,</span></div>
<div class="line">  <span class="comment">! This is what you set in the JSON file, in the type keyword</span></div>
<div class="line">  <span class="keyword">call </span>register_source_term(<span class="stringliteral">&quot;mytype&quot;</span>, allocator)</div>
<div class="line"><span class="keyword">end subroutine </span></div>
</div><!-- fragment --><p class="startli">Note that the <code>*_register_types</code> routine can register maybe types, not necessarily just one.</p>
</li>
</ul>
<p>For custom device kernels, <code>mymodule</code> must define a C interface to a CUDA/HIP routine that launches the kernel.</p>
<div class="fragment"><div class="line"><span class="keyword">interface</span></div>
<div class="line">  <span class="keyword">subroutine </span>device_kernel(a_d, n) &amp;</div>
<div class="line">        bind(c, name = <span class="stringliteral">&#39;device_kernel&#39;</span>)</div>
<div class="line">    use, <span class="keywordtype">intrinsic</span> :: iso_c_binding, only: c_int, c_ptr</div>
<div class="line">    <span class="keywordtype">type</span>(c_ptr), <span class="keywordtype">value</span> :: a_d</div>
<div class="line">    <span class="keywordtype">integer(c_int)</span> :: n</div>
<div class="line">  <span class="keyword">end subroutine </span>device_kernel</div>
<div class="line"><span class="keyword">end interface</span></div>
</div><!-- fragment --><p>Furthermore, the CUDA/HIP file must allow for C linkage, hence the routine <code>device_kernel</code> must be inside an <code>extern "C"</code> block.</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="../../db/d11/cuda_2dirichlet__kernel_8h.html#ac2cb217184f95ca86456f610f72bd533">device_kernel</a>(<span class="keywordtype">void</span> *<a class="code hl_function" href="../../db/d11/cuda_2dirichlet__kernel_8h.html#ac2cb217184f95ca86456f610f72bd533">a</a>, <span class="keywordtype">int</span> *n) {</div>
<div class="line">    <span class="comment">/* Launch device kernel here */</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="acuda_2dirichlet__kernel_8h_html_ac2cb217184f95ca86456f610f72bd533"><div class="ttname"><a href="../../db/d11/cuda_2dirichlet__kernel_8h.html#ac2cb217184f95ca86456f610f72bd533">dirichlet_apply_scalar_kernel</a></div><div class="ttdeci">__global__ void dirichlet_apply_scalar_kernel(const int *__restrict__ msk, T *__restrict__ x, const T g, const int m)</div><div class="ttdef"><b>Definition</b> <a href="../../db/d11/cuda_2dirichlet__kernel_8h_source.html#l00042">dirichlet_kernel.h:42</a></div></div>
</div><!-- fragment --><p>After compiling with <code>makeneko</code>, you can select your type in the JSON in the appropriate place.</p>
<p>One might wonder whether it's necessary to use this functionality—for example, for source terms—when it's possible to simply use a corresponding user routine in the user file. However, implementing a proper custom type has several advantages:</p>
<ul>
<li>You can potentially submit it to Neko via a pull request, if that's your goal.</li>
<li>It's easier to distribute. For example, you can include the type in your own Git repository, making it readily accessible to collaborators. While you could also share a user file, combining multiple user files is error-prone, as they often rely on module-level variables. Consider the difficulty of stitching together two or three custom source terms in a single user routine without causing conflicts.</li>
<li>You can configure the type directly in the JSON input. This is especially useful for parameter studies, where you may want to adjust values without modifying code or recompiling.</li>
</ul>
<p>That said, writing a custom type does take more effort than simply filling in the user routine. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Neko Manual</a></li><li class="navelem"><a class="el" href="../../dd/d04/user-guide.html">User guide</a></li>
    <li class="footer">Generated on Fri Nov 21 2025 03:46:58 for Neko by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
