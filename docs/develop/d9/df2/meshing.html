<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Neko: Meshing</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Neko<span id="projectnumber">&#160;1.99.2</span>
   </div>
   <div id="projectbrief">A portable framework for high-order spectral element flow simulations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d9/df2/meshing.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Meshing</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="general-considerations"></a>
General considerations</h1>
<p>The Spectral Element Method (SEM) used in Neko is a high-order finite element method. You generate a mesh of elements; the individual degrees of freedom (DoFs) inside each element are then placed automatically by Neko based on the chosen polynomial order.</p>
<p>In SEM, the total DoF count increases with the polynomial order <code>p</code>. Consequently, the effective spatial resolution depends both on the element size and on <code>p</code>. Within each element, nodal points are placed at Gauss–Lobatto–Legendre (GLL) locations, which are clustered near element boundaries and not uniformly spaced.</p>
<p>Below are ASCII sketches of approximate GLL node distributions in a 1D element for <code>p = 4</code> and <code>p = 6</code>. Each sketch spans <code>[−1, 1]</code> in the reference element. Vertical ticks show node positions; note the boundary clustering.</p>
<div class="fragment"><div class="line">-1                                        1 </div>
<div class="line">|------|-------------|-------------|------|  p = 4</div>
<div class="line">^      ^             ^             ^      ^</div>
<div class="line">|      |             |             |      |</div>
<div class="line">x1     x2            x3            x4     x5</div>
<div class="line"> </div>
<div class="line">-1                                        1</div>
<div class="line">|--|------|----------|----------|------|--|  p = 6</div>
<div class="line">^  ^      ^          ^          ^      ^  ^</div>
<div class="line">|  |      |          |          |      |  |</div>
<div class="line">x1 x2     x3         x4         x5     x6 x7</div>
</div><!-- fragment --><p>The leads to the question: What <code>p</code> to aim the element spacing for, when constructing the mesh? A default choice is 7, this is the unofficial standard in the SEM community. If you plan a mesh refinement study, it is useful to think if you can make use of <code>p</code>-refinement. That is, use the same element mesh, and increase resolution by increasing polynomial order. This saves you a lot of time because you do not need to re-mesh. Also, projecting the solution onto a new polynomial order is often seamless in Neko. For example, you can easily use a field generated with <code>p</code> equal to 5 as initial conditions for a run with a higher order. A possible strategy is then to aim the element size to get a "good" mesh with order 7, and then treat orders 5, 9 and 11 as refinement levels.</p>
<p>Neko is a 3D code. But you can provide it with a 2D mesh in the x-y plane. In this case it will extrude it to contain 1 element in z, and periodic conditions will be applied on the sides. This allows to generate pseudo-2d solutions. You can use some tricks, like setting the z-component velocity to zero at each time step in the user file. There are a few pseudo-2d examples available, one is <code>lid</code>.</p>
<p>All elements of a Neko mesh must be hexahedral (or quadrilateral for the pseudo-2d case). The topology can be fully unstructured. A practical way of generating a hexahedral mesh of a complicated geometry is to first generate a tetrahedral mesh (usually with triangle prisms in the boundary layer) and then convert it by chopping each tetrahedron into hexahedra. But keep in mind that the quality of such meshes are generally not very high.</p>
<p>Strong skewness, non-orthogonality and other issues will likely cause your case to crash. The SEM is a high-order method and that comes at the price of much higher sensitivity to mesh quality than that of, say, a finite volume solver. Since the SEM flavour used in Neko allows for discontinuities in derivatives across element boundaries, the size of these jumps serve as a good proxy for mesh quality. This can be assessed by simply inspecting some derivative field visually. Similarly the primary solution fields will start exhibiting wiggles on coarse grids, particularly towards the element boundaries. While these visual indicators are not quantitative, then can give you a good idea of where in the domain things have potentially gone wrong.</p>
<p>Finally, an important note for those simulating canonical flows is that periodic boundary conditions are part of the mesh definition in Neko, and not something you specify in the case file. Baking in periodicity into the mesh is discussed below.</p>
<h1><a class="anchor" id="autotoc_md127"></a>
Constructing meshes</h1>
<p>If your domain is a box, you can use Neko's built-in mesher called <code>genmeshbox</code>. Otherwise, you have to convert your mesh into a Nek5000 format called <code>.<a class="el" href="../../dd/da1/namespacere2.html" title="NEKTON re2 format.">re2</a></code>, and then apply a utility in Neko called <code>rea2nbin</code>, which produces a mesh in the native Neko format <code>.nmsh</code>.</p>
<p>So, for most practical cases, the mesh generation for Neko boils down to mesh generation for Nek5000. At this stage it is indeed helpful to have a local copy of Nek5000 to make use of its mesh conversion tools. However, we provide one such tool under <code>contrib/gmsh2nek</code>. Executing the <code>compile.sh</code> script in that folder will produce a <code>gmsh2nek</code> executable. As the name hints, this is a convertor from the gmsh <code>.msh</code> format to <code><a class="el" href="../../dd/da1/namespacere2.html" title="NEKTON re2 format.">re2</a></code>. In addition to just converting, the utility allows to define periodic boundaries.</p>
<p>Since gmsh is popular, a lot of meshing software supports its format. There is a caveat though: there have been several versions of the <code>.msh</code> and <code>gmsh2nek</code> supports only a particular flavour. Moreover, it expects the order of the mesh to be 2, whereas most software will produce a linear mesh. The typical meshing pipeline is therefore the following:</p>
<ol type="1">
<li>Generate your element mesh and save it to the <code>.msh</code> format.</li>
<li>Open the mesh in gmsh, set the order to 2, and export the mesh in the legacy version 2 <code>.msh</code> format.</li>
<li>Convert it to <code>.<a class="el" href="../../dd/da1/namespacere2.html" title="NEKTON re2 format.">re2</a></code> with <code>gmsh2nek</code>, defining periodic boundaries if needed.</li>
<li>Run <code>rea2nbin</code> to get the <code>.nmsh</code>.</li>
<li>Run Neko's <code>mesh_checker</code> utility on the generated <code>.nmsh</code>. This will create an internal representation of the mesh, just like during a simulation, and then output some statistics. If this goes smoothly, your mesh should be good to go.</li>
</ol>
<p>Naturally, the element mesh can also be directly generated by <code>gmsh</code> itself! For example, from a <code>.geo</code> file. This is done in the <code>turb_pipe</code> example. The README there contains much the same meshing instructions as the points above, and provides concrete commands to run to get from a <code>.geo</code> to a <code>.nmsh</code>. Finally, as already noted, <code>gmsh2nek</code> is not the only converter provided in Nek5000, and you may find it useful to explore alternatives, depending on your workflow. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Neko Manual</a></li><li class="navelem"><a class="el" href="../../dd/d04/user-guide.html">User guide</a></li>
    <li class="footer">Generated on Sat Dec 13 2025 03:48:11 for Neko by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
