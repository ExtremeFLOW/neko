<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Neko: Contributing to Neko</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Neko<span id="projectnumber">&#160;1.99.2</span>
   </div>
   <div id="projectbrief">A portable framework for high-order spectral element flow simulations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d1/d5a/contributing.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Contributing to Neko</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md15">Git branches</a></li>
<li class="level1"><a href="#autotoc_md16">Code style</a><ul><li class="level2"><a href="#autotoc_md17">Data types</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md18">Build system and code organization</a><ul><li class="level2"><a href="#autotoc_md19">Building CPU Fortran code</a></li>
<li class="level2"><a href="#autotoc_md20">Device code</a><ul><li class="level3"><a href="#autotoc_md21">CUDA</a></li>
<li class="level3"><a href="#autotoc_md22">HIP</a></li>
<li class="level3"><a href="#autotoc_md23">OpenCL</a></li>
<li class="level3"><a href="#autotoc_md24">Device-based type polymorphism</a></li>
<li class="level3"><a href="#autotoc_md25">Summary of build system entires</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>Please read the following guide before contributing new code or a bug fix to Neko.</p>
<p>All contributions to Neko must be made under the 3-Clause BSD license. Please refer to the <code>COPYING</code> file.</p>
<h1><a class="anchor" id="autotoc_md15"></a>
Git branches</h1>
<p>Neko follows the Git branching model described in <a href="https://nvie.com/posts/a-successful-git-branching-model">https://nvie.com/posts/a-successful-git-branching-model</a>, where <code>develop</code> contains the latest contributions, and all pull requests should start from <code>develop</code> and be merged back into <code>develop</code>. New branches should be named <code>feature/&lt;description&gt;</code> for new features or <code>fix/&lt;description&gt;</code> for bug fixes.</p>
<p>When a pull request is submitted, a series of continuous integration tests will be run. A pull request will not be accepted nor merged into <code>develop</code> until it passes the test suite.</p>
<h1><a class="anchor" id="autotoc_md16"></a>
Code style</h1>
<p>Fortran code should conform to the Fortran 2008 standard and should use an indentation level of 2, except for the extra indentation within <code>do</code> <code>if</code>, <code>select</code> or <code>where</code> statements and for each level inside a structure e.g. <code>type</code>, <code>interface</code>, where the indentation level is 3, and a 0 indentation is used for <code>module</code> or <code>contains</code> (except for <code>contains</code> inside a derived type, where a single indentation level is used). These are the default rules in Emacs' Fortran mode, an example is given below, </p><div class="fragment"><div class="line"><span class="keyword">module</span> example</div>
<div class="line">  <span class="keywordtype">use </span>mod</div>
<div class="line">  <span class="keywordtype">implicit none</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">type</span> :: derived_t</div>
<div class="line">     <span class="keywordtype">integer</span> :: x</div>
<div class="line">   <span class="keyword">contains</span></div>
<div class="line">     <span class="keywordtype">procedure</span>, pass(this) :: bar     </div>
<div class="line">  <span class="keyword">end type </span>derived_t</div>
<div class="line"> </div>
<div class="line"><span class="keyword">contains</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">subroutine </span>foo(x, y)</div>
<div class="line">    <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: x</div>
<div class="line">    <span class="keywordtype">integer</span>, <span class="keywordtype">intent(inout)</span> :: y</div>
<div class="line"><span class="keywordtype">    real</span>(kind=rp) :: <span class="keywordtype">value</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">do</span> i = 1, 10</div>
<div class="line">       ...</div>
<div class="line"><span class="keywordflow">    end do</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (x .lt. y) <span class="keywordflow">then</span></div>
<div class="line">       ...</div>
<div class="line"><span class="keywordflow">    end if</span></div>
<div class="line">    </div>
<div class="line">  <span class="keyword">end subroutine </span>foo</div>
<div class="line"><span class="keyword">end module </span>example</div>
</div><!-- fragment --><p> Please note that the maximum line length in Neko should not exceed 80 columns.</p>
<p>Additional details on the code style, as well as tools used to verify it, can be found under the <a class="el" href="../../da/db6/code-style.html">code style</a>.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Data types</h2>
<p>For portability reasons, it is essential to only use data type kinds defined in <code><a class="el" href="../../dc/d99/num__types_8f90.html">src/config/num_types.f90</a></code> and avoid legacy constructs like <code>real*8</code> or <code>integer(kind=8)</code></p>
<p>Floating-point numbers should be declared using <code>real</code> with the kind <code>rp</code>, which is the configured working precision for Neko (defaults to double). If single, double or quad precision is explicitly needed, use the kinds <code>sp</code>, <code>dp</code> or <code>qp</code>, respectively. For 16, 32, or 64-bit integers, Neko has defined the kinds <code>i2</code>, <code>i4</code> or <code>i8</code>, respectively; however, for standard integers, it is perfectly fine to use a plain <code>integer</code>.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Build system and code organization</h1>
<p>This section contains information on how to add new source files to the build system. It also give an overview of the common folder structures you will encounter in the code.</p>
<p>Neko uses Autotools for building all sources. You will need to have at least <code>autoconf</code>, <code>libtool</code>, and <code>automake</code> installed for development work. It is also highly recommended to have <code>makedepf90</code> installed to avoid error-prone manual dependency tracking. Since Neko uses <code>submodules</code>, a recent version of <code>makedepf90</code> from <a href="https://salsa.debian.org/science-team/makedepf90">https://salsa.debian.org/science-team/makedepf90</a> is needed.</p>
<p>The vast majority of the code is located inside the <code>src</code> folder, where it is organized into subfolders, roughly based on the functionality, which is implemented inside the them. A common folder structure is used to organize the implementation of the same functionality on various compute backends. This is discussed further below. Outside, <code>src</code>, the <code>contrib</code> folder is home for the implementations of various executable utilities.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
Building CPU Fortran code</h2>
<p>The following steps describe how to add a new Fortran file to Neko's build system.</p><ol type="1">
<li>Place the file in an appropriate subdirectory under <code>src/</code>. Either create a new subdirectory or place the file in <code>common</code> if none of the existing directories is a good match. Avoid placing the file directly under <code>src</code></li>
<li>Add the file to the <code>neko_fortran_SOURCES</code> list in <code>src/Makefile.am</code>, following the pattern of <code>&lt;subdir under src&gt;/newfile.f90</code>.</li>
<li>Ensure correct dependency tracking<ul>
<li>Using <code>makedepf90</code><ul>
<li>Regenerate build system by running <code>./regen.sh</code> at the top level, and reconfigure using <code>configure</code></li>
<li>Regenerate dependency file (<code>src/.depends</code>) by issuing <code>make depend</code> under <code>src</code></li>
<li>Do a final regeneration of the build system (<code>./regen.sh</code>)</li>
</ul>
</li>
<li>Manually<ul>
<li>Manually add the new file and all its dependencies to <code>src/.depends</code>, using the following pattern, <div class="fragment"><div class="line">directory/newfile.o : directory/newfile.f90 directory/dependency.o anotherdirectory/anotherdependency.o</div>
</div><!-- fragment --></li>
<li>Regenerate build system by running <code>./regen.sh</code> at the top level.</li>
</ul>
</li>
</ul>
</li>
<li>Finally reconfigure using <code>configure</code> and rebuild Neko with your new contribution!</li>
</ol>
<h2><a class="anchor" id="autotoc_md20"></a>
Device code</h2>
<p>Here we focus on three particular backends: CUDA, HIP, and OpenCL. In Neko these three are collectively referred to as the "device", distinguishing them from both ordinary CPU code, but also other special backends like the SX. Whenever a type needs to implement dedicated compute kernels, Neko often follows a standardized directory and file structure.</p>
<p>As an example, we will consider the folder <code>src/bc</code>, please open it in a terminal alongside reading this text. Inside, you can see a bunch of <code>.f90</code> files, corresponding to different boundary conditions, for example, <code>symmtery.f90</code> and <code><a class="el" href="../../d8/d69/dirichlet_8f90.html">dirichlet.f90</a></code>. These files define the corresponding types, like <code>dirichlet_t</code> and are included in the build system as per the instructions above. So, these files are just pure Fortran.</p>
<p>Observe that there is a directory called <code>bcknd</code>. This is where the low-level implementation of compute kernels. Sometimes this folder contains a <code>cpu</code> folder, with modules implementing CPU kernels. In the case of boundary conditions, the CPU kernels are directly implemented in the high-level <code>.f90</code> files mentioned above. Here, we focus on the folder <code>device</code>, which contains the implementation of kernels for the 3 "device" backends. Note the contents: a bunch of <code>.F90</code> files (note the big F in the extension!) and a folder for each backend (<code>cuda</code>, <code>hip</code>, <code>opencl</code>).</p>
<p>Let us start with the <code>.F90</code>s. The reason for the big F is that these files contain preprocessor directives (like <code>#ifdef</code>). This is just a general convention, not invented by Neko authors. The <code>.F90</code> files act as a device abstraction layer. What that means in practice is that they contain:</p><ul>
<li>Wrapper routines, calling the correct backend kernel, depending on the device Neko has been compiled for.</li>
<li>Several <code>interface</code> blocks, for the backend kernels, which are essentially glue between Fortran and the actual backend code, which is called from a C routine. This is standard "C interoperability" stuff, which you can read about in books or online.</li>
</ul>
<p>Let's take a look at <code><a class="el" href="../../dd/d9a/device__symmetry_8F90.html">device_symmetry.F90</a></code>. It contains one subroutine, <code>device_symmetry_apply_vector</code>, that just dispatches the call to one of the backends, via the corresponding interfaces defined in the beginning of the file. If we now go back to <code><a class="el" href="../../d2/d3a/symmetry_8f90.html">symmetry.f90</a></code>, we see that it imports this routine, and calls it inside <code>symmetry_apply_vector_dev</code>.</p>
<p>Since the <code>.F90</code>s are ordinary Fortran files, they are also added to the build system in the already specified way.</p>
<p>Now we leave the familiar Fortran territory and look at individual backends. Generally, CUDA and HIP are very similar (in fact, even the code of the kernels is often pretty much a copy-paste), so we will look at CUDA in detail and then quickly mentioned adjustments for HIP. OpenCL is a different beast, but the pattern is still quite similar.</p>
<h3><a class="anchor" id="autotoc_md21"></a>
CUDA</h3>
<p>To follow along, navigate to <code>src/bc/bcknd/device/cuda</code>. We see three types of files: <code>.cu</code>, <code>*_kernel.h</code> and potentially other, auxillary, <code>.h</code> files.</p>
<ul>
<li>The <code>.cu</code> files contain a C routine, which corresponds to the <code>interface</code> defined in the <code>.F90</code> file. We need this because we cannot just launch a CUDA kernel from Fortran, so instead we created this binding between a Fortran and a C routine, and the latter launches the CUDA kernel for us.</li>
<li>The kernels themselves are not in the <code>.cu</code> files, but rather in the <code>*_kernel.h</code> files. The <code>.cu</code> files simply <code>#include</code> them. For example, <code>symmtery.cu</code> includes <code>symmetry_kernel.h</code>, which has the <code>symmetry_apply_vector_kernel</code>, which is then launched in the <code>.cu</code> file.</li>
<li>The other <code>.h</code> files just contain implementations of functions and kernels used in several of the <code>*_kernel.h</code> files.</li>
</ul>
<p>Let's zoom out again, because now we have the full picture for CUDA, which is similar for other device backends.</p><ul>
<li>The <code>.f90</code> file.<ul>
<li>Defines the type, heavy on OOP.</li>
<li>With a <code>use</code> statement, imports kernel subroutines from modules in the <code>bcknd</code> subdirectory.</li>
<li>Sometimes contains the CPU implementation instead of using a dedicated kernel for it.</li>
</ul>
</li>
<li>The <code>.F90</code> files inside <code>bcknd/device</code>.<ul>
<li>Contains wrapper routines that are called from the <code>.f90</code> and dispatch to the implementation on the correct device backend.</li>
<li>Contains <code>interface</code>s for the implementation on each device, binding Fortran that we can call from the wrappers in the <code>.F90</code> with C code that launches actual device kernels.</li>
</ul>
</li>
<li>Thn <code>.cu</code> files in <code>bcknd/device/cuda</code> that contain C routines adhering to the interface defined in the <code>.F90</code>. They <code>#include</code> the kernel code, and launch the kernel.</li>
<li>The <code>_kernel.h</code> files in <code>bcknd/device/cuda</code> that contain implementations of CUDA kernels.</li>
</ul>
<p>Now, let's see how the <code>.cu</code> and <code>.h</code> files are properly added to the build system. First, consider the <code>src/Makefile.am</code> file. The <code>.cu</code>s are added under the </p><div class="fragment"><div class="line">if ENABLE_CUDA</div>
<div class="line">libneko_la_SOURCES += \</div>
</div><!-- fragment --><p> list. On the other hand, all the <code>.h</code> files are added to the </p><div class="fragment"><div class="line">EXTRA_DIST = \</div>
</div><!-- fragment --><p> list.</p>
<p>Unfortunately, we also have to manually provide the dependencies between the files. That is done in the <code>src/.depends_device</code> file. A typical line will bind a <code>.lo</code> file with the corresponding <code>.cu</code> and <code>.h</code> files. For example: </p><div class="fragment"><div class="line">bc/bcknd/device/cuda/symmetry.lo : bc/bcknd/device/cuda/symmetry.cu bc/bcknd/device/cuda/symmetry_kernel.h</div>
</div><!-- fragment --><p> So, one should make similar entries for each new <code>.cu</code> file one adds.</p>
<h3><a class="anchor" id="autotoc_md22"></a>
HIP</h3>
<p>Thankfully, HIP works in precisely the same way as CUDA, with the following differenece: instead of <code>.cu</code> we have <code>.hip</code> files. These are to be added under </p><div class="fragment"><div class="line">if ENABLE_HIP</div>
<div class="line">libneko_la_SOURCES += \</div>
</div><!-- fragment --><p> for the build system to see them. The <code>.h</code> files go to <code>EXTRA_DIST</code> as with CUDA. The dependencies are also specified in the exact same way.</p>
<h3><a class="anchor" id="autotoc_md23"></a>
OpenCL</h3>
<p>To follow along, navigate to <code>src/bc/bcknd/device/opencl</code>. Quite similar to CUDA, there are up to 3 types of files that can be present here.</p><ul>
<li>The <code>.c</code> files, which are just like <code>.hip</code> or <code>.cu</code>. They contain a C routine, which launches the OpenCL kernel.</li>
<li><p class="startli">The <code>_kernel.cl</code> files, which are like the <code>_kernel.h</code> files for CUDA and HIP. You will notice that the <code>.c</code> files <code>#include</code> the <code>.cl</code> files, but with an additional <code>.h</code> in the end like</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;symmetry_kernel.cl.h&quot;</span></div>
</div><!-- fragment --><p> Don't let that lead you astray with your file naming: the <code>.h</code> is added automatically, and the files are just <code>.cl</code>!</p>
</li>
<li>There may possibly be auxillary <code>.h</code> files for common functionlity across kernels.</li>
</ul>
<p>Note that the <code>.c</code> files contain also the following <code>include</code> statement. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d1/df7/prgm__lib_8h.html">device/opencl/prgm_lib.h</a>&gt;</span></div>
<div class="ttc" id="aprgm__lib_8h_html"><div class="ttname"><a href="../../d1/df7/prgm__lib_8h.html">prgm_lib.h</a></div></div>
</div><!-- fragment --><p> This is an important file, which we have to modify to register our kernel. Each OpenCL kernel has an associated <code>_program</code>, for example, if you look at <code><a class="el" href="../../d6/d04/symmetry_8c.html">symmetry.c</a></code>, you will see the variable <code>symmetry_program</code> used in a few places. This is not really important for the implementation per se, but the point is that twe have to define these <code>*_program</code> variables somewhere, and in Neko this is done in two files. One is the above mentioned <code><a class="el" href="../../d1/df7/prgm__lib_8h.html">src/device/opencl/prgm_lib.h</a></code>, where you can find </p><div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> *<a class="code hl_variable" href="../../d1/df7/prgm__lib_8h.html#ae93fd324a82c664649662c6b9ee4b5d4">symmetry_program</a>;</div>
<div class="ttc" id="aprgm__lib_8h_html_ae93fd324a82c664649662c6b9ee4b5d4"><div class="ttname"><a href="../../d1/df7/prgm__lib_8h.html#ae93fd324a82c664649662c6b9ee4b5d4">symmetry_program</a></div><div class="ttdeci">void * symmetry_program</div></div>
</div><!-- fragment --><p> One needs to add a similar line for the <code>_program</code> corresponding to the new kernel. The other file is very similar, but written in Fortran: <code>src/device/opencl/prh_lib.F90</code>. Here you can e.g. find</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keywordtype">type</span>(c_ptr), <span class="keywordtype">public</span>, <span class="keyword">bind(c)</span> :: symmetry_program = c_null_ptr</div>
</div><!-- fragment --><p> and just like with the <code>.h</code> file a corresponding entry for the new kernel should be added.</p>
<p>This finally brings us to the build system. The <code>.c</code> files are to be added under </p><div class="fragment"><div class="line">if ENABLE_OPENCL</div>
<div class="line">libneko_la_SOURCES += \</div>
</div><!-- fragment --><p> in <code>src/Makefile.am</code>, and the <code>.cl</code> and <code>.h</code> files go under the <code>EXTRA_DIST</code> list, just like the CUDA and HIP kernel files did.</p>
<p>The entry to <code>src/.depends_device</code> also follows a familiar pattern, e.g. </p><div class="fragment"><div class="line">bc/bcknd/device/opencl/symmetry.lo : bc/bcknd/device/opencl/symmetry.c bc/bcknd/device/opencl/symmetry_kernel.cl.h</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md24"></a>
Device-based type polymorphism</h3>
<p>Neko is developing, and not all the conventions active now have been applied from the beginning, and even in new code there are sometimes exceptions. For example, it has already been mentioned tha the CPU kernels sometimes reside in a seprate module, like the device ones, and sometimes just implemented inside the main module defining the type.</p>
<p>Some important types in Neko use polymorphism in addition to the <code>#ifdef</code> statements we saw in the <code>.F90</code> files in order define the behavior on the device. If we look at the <code><a class="el" href="../../da/d32/pnpn__res_8f90.html">pnpn_res.f90</a></code> file, we see that an abstract type is defined, <code>pnpn_pres_res_t</code>. Then in <code><a class="el" href="../../d1/d10/pnpn__res__device_8F90.html">pnpn_res_device.F90</a></code> the type is extended: </p><div class="fragment"><div class="line"><span class="keyword">type</span>, <span class="keyword">public</span>, <span class="keyword">extends</span>(pnpn_prs_res_t) :: pnpn_prs_res_device_t</div>
<div class="line"> <span class="keyword">contains</span></div>
<div class="line">   <span class="keywordtype">procedure</span>, <span class="keywordtype">nopass</span> :: compute =&gt; pnpn_prs_res_device_compute</div>
<div class="line"><span class="keyword">end type </span>pnpn_prs_res_device_t</div>
</div><!-- fragment --><p> An inspection of the <code>compute</code> routine reveals a complex code that both launches kernels and also makes use of the operators and math routines that also dispatch to the correct backend. Similar types are defined for the CPU and also other backends (SX) in this case. The correct type is then instantiated at run time in a factory routine located in <code><a class="el" href="../../dc/dfb/pnpn__res__fctry_8f90.html">pnpn_res_fctry.f90</a></code>.</p>
<p>What this achieves is that you don't need the extra <code>if</code> statement to distinguish between the CPU, the device, and the SX backends each time you want <code>pnpn_res</code> to do its job. Instead, you have that <code>if</code> statement in the factory routine, and you get the correct type to use for your backend for the rest of the run time.</p>
<p>In the majority of situations, one can take the hit of having that extra <code>if</code> statement and not complicate the code with the extra types and the factory.</p>
<h3><a class="anchor" id="autotoc_md25"></a>
Summary of build system entires</h3>
<p>Here is concise summary of how to add device kernels to the build system:</p>
<p>In <code>src/Makefile.am</code></p><ul>
<li>Add <code>.f90</code> and <code>.F90</code> files under <code>neko_fortran_SOURCES = \</code></li>
<li>Add <code>.c</code> files under <code>neko_c_SOURCES = \</code></li>
<li>Add all <code>.h</code> and all <code>.cl</code> files under <code>EXTRA_DIST = \</code></li>
<li>Add <code>.cu</code> files under <div class="fragment"><div class="line">if ENABLE_CUDA</div>
<div class="line">libneko_la_SOURCES += \</div>
</div><!-- fragment --></li>
<li>Add <code>.hip</code> files under <div class="fragment"><div class="line">if ENABLE_HIP</div>
<div class="line">libneko_la_SOURCES += \</div>
</div><!-- fragment --></li>
<li>Add all OpenCL <code>.c</code> files under <div class="fragment"><div class="line">if ENABLE_OPENCL</div>
<div class="line">libneko_la_SOURCES += \</div>
</div><!-- fragment --></li>
<li>Add associated code entries to <code><a class="el" href="../../d1/df7/prgm__lib_8h.html">prgm_lib.h</a></code> and <code><a class="el" href="../../d8/dae/prgm__lib_8F90.html">prgm_lib.F90</a></code>, located in <code>/src/device/opencl/</code>.</li>
<li>Add appropriate entries to <code>src/.depends_device</code>.</li>
</ul>
<p><b>Happy hacking!</b> üçª </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Neko Manual</a></li><li class="navelem"><a class="el" href="../../dc/d70/developer-guide.html">Developer guide</a></li>
    <li class="footer">Generated on Fri Dec 19 2025 03:50:40 for Neko by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
