<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Neko: Installing Neko</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Neko<span id="projectnumber">&#160;1.99.1</span>
   </div>
   <div id="projectbrief">A portable framework for high-order spectral element flow simulations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d5/dfc/installation.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Installing Neko</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md108">Building from source</a><ul><li class="level2"><a href="#autotoc_md109">Dependencies</a><ul><li class="level3"><a href="#autotoc_md110">Building JSON Fortran</a></li>
<li class="level3"><a href="#autotoc_md111">Building HDF5 (optional, but highly recommended)</a></li>
<li class="level3"><a href="#autotoc_md112">Building ParMETIS (optional)</a></li>
<li class="level3"><a href="#autotoc_md113">Bulding PFunit (optional)</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md114">Building Neko</a><ul><li class="level3"><a href="#autotoc_md115">Compiling Neko for CPU or SX-Aurora</a></li>
<li class="level3"><a href="#autotoc_md116">Compiling Neko for NVIDIA GPUs</a></li>
<li class="level3"><a href="#autotoc_md117">Compiling Neko for AMD GPUs</a></li>
<li class="level3"><a href="#autotoc_md118">Compiling Neko with a collective communications library</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md119">Installing via Spack</a><ul><li class="level2"><a href="#autotoc_md120">Quick start guide with Spack</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md121">Installing using pixi</a></li>
<li class="level1"><a href="#autotoc_md122">Using a Docker container</a></li>
</ul>
</div>
<div class="textblock"><p>Neko can be installed in various ways, either building directly from source, manually compiling all dependencies and Neko or via tools like Spack, pixi, and Docker. What to use comes down to personal preference, but here are some rough guidelines.</p>
<ul>
<li>Use pixi to quickly obtain a CPU build with all optional dependencies in an isolated environment.</li>
<li>Spack is a more advanced package manager, targeting HPC environments. It gives you a lot of control yet the possibility to easily get neko for several compute backends.</li>
<li>Use Docker if you are a fan of containers.</li>
<li>Build from source if you want full control over the build parameters and environment and don't want to use a package manager.</li>
</ul>
<h1><a class="anchor" id="autotoc_md108"></a>
Building from source</h1>
<p>To build Neko, you will need a Fortran compiler supporting the Fortran-08 standard, autotools, libtool, pkg-config, a working MPI installation supporting the Fortran 2008 bindings (<code>mpi_f08</code>), BLAS/LAPACK and JSON-Fortran. Optional dependencies are PFunit, HDF5 and ParMETIS.</p>
<p>Follow the steps below to install the less common dependencies (e.g. JSON-Fortran).</p>
<h2><a class="anchor" id="autotoc_md109"></a>
Dependencies</h2>
<h3><a class="anchor" id="autotoc_md110"></a>
Building JSON Fortran</h3>
<p>Download and compile, at least version 0.7.1 of JSON Fortran from the main repository. </p><dl class="section note"><dt>Note</dt><dd>Neko requires JSON Fortran to be configured with <code>USE_GNU_INSTALL_CONVENTION</code>.</dd></dl>
<div class="fragment"><div class="line">git clone --depth=1 https://github.com/jacobwilliams/json-fortran.git</div>
<div class="line">cd json-fortran &amp;&amp; mkdir b &amp;&amp; cd b</div>
<div class="line">cmake -DCMAKE_INSTALL_PREFIX=/path/to/installation -DUSE_GNU_INSTALL_CONVENTION=ON ..</div>
<div class="line">make install</div>
</div><!-- fragment --><p> Now ad the installation path to <code>PKG_CONFIG_PATH</code> (and if needed <code>LD_LIBRARY_PATH</code>). </p><dl class="section note"><dt>Note</dt><dd>On certain systems <code>lib</code> should be substituted with <code>lib64</code></dd></dl>
<div class="fragment"><div class="line">export PKG_CONFIG_PATH=/path/to/installation/lib/pkgconfig:$PKG_CONFIG_PATH</div>
<div class="line">export LD_LIBRARY_PATH=/path/to/installation/lib:$LD_LIBRARY_PATH</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md111"></a>
Building HDF5 (optional, but highly recommended)</h3>
<p>Download and compile at least version 1.14 of HDF5, with Fortran and MPI support. Note that you may need to adjust the compilers depending on you machine (for example, on Cray supercomputers <code>mpifort</code> is usually replaced with <code>ftn</code>, and so on).</p>
<div class="fragment"><div class="line">wget https://github.com/HDFGroup/hdf5/archive/refs/tags/hdf5_1.14.6.tar.gz</div>
<div class="line">tar xvf hdf5_1.14.6.tar.gz</div>
<div class="line">cd hdf5-hdf5_1.14.6/</div>
<div class="line">cmake -B build -S ./ --install-prefix /path/to/installation \</div>
<div class="line">    -DCMAKE_C_COMPILER=mpicc -DCMAKE_CXX_COMPILER=mpicxx \</div>
<div class="line">    -DCMAKE_Fortran_COMPILER=mpifort -DHDF5_ENABLE_PARALLEL=ON \</div>
<div class="line">    -DHDF5_BUILD_FORTRAN=ON -DCMAKE_BUILD_TYPE=Release</div>
<div class="line">cmake --build build/ --parallel</div>
<div class="line">cmake --install build/</div>
</div><!-- fragment --><p>It can be a good idea to double-check that you have files starting with <code>libhdf5_fortran</code> in the <code>lib</code> directory in your install path. If not, try to inspecting the log in the <code>build</code> directory with <code>cat CMakeCache.txt | grep FORTRAN</code> to identify issues.</p>
<p>Similar to <code>json-fortran</code>, populate relevant environmental variables. </p><div class="fragment"><div class="line">export PATH=:/path/to/installation/bin:$PATH</div>
<div class="line">export PKG_CONFIG_PATH=/path/to/installation/lib/pkgconfig:$PKG_CONFIG_PATH</div>
<div class="line">export LD_LIBRARY_PATH=/path/to/installation/lib:$LD_LIBRARY_PATH</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md112"></a>
Building ParMETIS (optional)</h3>
<p>The following steps is an example on how to build and install ParMETIS</p>
<div class="fragment"><div class="line"> shell</div>
<div class="line">$ export PARMETIS_INSTALL=/usr/local/parmetis</div>
<div class="line">$ wget https://github.com/mfem/tpls/raw/refs/heads/gh-pages/parmetis-4.0.3.tar.gz</div>
<div class="line">$ tar xzf parmetis-4.0.3.tar.gz &amp;&amp; cd parmetis-4.0.3 &amp;&amp; make config prefix=${PARMETIS_INSTALL} &amp;&amp; make install</div>
<div class="line">$ cd metis &amp;&amp; make config prefix=${PARMETIS_INSTALL} &amp;&amp; make install &amp;&amp; cd ../..</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md113"></a>
Bulding PFunit (optional)</h3>
<p>To build the PFunit testing framework, please refers to the <a class="el" href="../../d5/d75/testing.html">Testing</a> page</p>
<h2><a class="anchor" id="autotoc_md114"></a>
Building Neko</h2>
<p>Neko uses autotools as its build system. The first step is to run the <code>configure</code> script, located in the top directory.</p>
<div class="fragment"><div class="line"> shell</div>
<div class="line">&lt;path-to-neko&gt;/configure FC=&lt;Fortran compiler&gt; CC=&lt;C compiler&gt; \</div>
<div class="line">                         MPIFC=&lt;MPI Fortran compiler&gt; MPICC=&lt;MPI C ompiler&gt; \</div>
<div class="line">                         FCFLAGS=&lt;Fortran compiler flags&gt; CFLAGS=&lt;C compiler flags&gt; \</div>
<div class="line">                         --prefix=&lt;installation path&gt; [options]</div>
</div><!-- fragment --><p>In the above command, <code>[options]</code> refers to either optional features or packages.</p>
<p>Features are enabled and disabled by passing either <code>--enable-FEATURE[=arg]</code> or <code>--disable-FEATURE</code> to <code>configure</code>. A list of currently supported features are given in the table below.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--enable-real=Xp</code>   </td><td class="markdownTableBodyNone">Specify working precision of REAL types:<br  />
<code>sp</code> &ndash; <code>REAL(kind=REAL32)</code> <br  />
<code>dp</code> &ndash; <code>REAL(kind=REAL64)</code> (default)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--enable-contrib</code>   </td><td class="markdownTableBodyNone">Compile various tools    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--enable-device-mpi</code>   </td><td class="markdownTableBodyNone">Enable device aware MPI    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--enable-openmp</code>   </td><td class="markdownTableBodyNone">Enable OpenMP    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--enable-shared</code>   </td><td class="markdownTableBodyNone">Build shared libraries (default: no)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--enable-static</code>   </td><td class="markdownTableBodyNone">Build static libraries (default: yes)   </td></tr>
</table>
<p>When configuring Neko with <code>sp</code> precision some variables are still stored in double precision, for example when gathering data from multiple processes. This can be avoided by specifying <code>ssp</code> instead, however, this is not actively maintained. Optional packages are controlled by passing either <code>--with-PACKAGE[=ARG]</code> or <code>--without-PACKAGE</code> to <code>configure</code>. A list of all supported optional packages are given in the table below.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--with-blas=&lt;lib&gt;</code>   </td><td class="markdownTableBodyNone">Use BLAS library <code>&lt;lib&gt;</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--with-lapack=&lt;lib&gt;</code>   </td><td class="markdownTableBodyNone">Use LAPACK library <code>&lt;lib&gt;</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--with-metis=DIR</code>   </td><td class="markdownTableBodyNone">Directory for metis    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--with-metis-libdir=LIBDIR</code>   </td><td class="markdownTableBodyNone">Directory for metis library (if different)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--with-parmetis=DIR</code>   </td><td class="markdownTableBodyNone">Compile with support for parmetis library    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--with-parmetis-libdir=LIBDIR</code>   </td><td class="markdownTableBodyNone">Directory for parmetis library (if different)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--with-adios2=DIR</code>   </td><td class="markdownTableBodyNone">Compile with support for ADIOS2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--with-adios2-fortran=DIR</code>   </td><td class="markdownTableBodyNone">Compile with support for ADIOS2 with Fortran    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--with-libxsmm</code>   </td><td class="markdownTableBodyNone">Compile with support for libxsmm    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--with-hip=DIR</code>   </td><td class="markdownTableBodyNone">Compile with HIP backend    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--with-cuda=DIR</code>   </td><td class="markdownTableBodyNone">Compile with CUDA backend    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--with-opencl=DIR</code>   </td><td class="markdownTableBodyNone">Compile with OpenCL backend    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--with-nvtx=DIR</code>   </td><td class="markdownTableBodyNone">Compile with support for NVTX    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--with-roctx=DIR</code>   </td><td class="markdownTableBodyNone">Compile with support for ROCTX    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--with-nccl=DIR</code>   </td><td class="markdownTableBodyNone">Compiler with support for NCCL    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--with-rccl=DIR</code>   </td><td class="markdownTableBodyNone">Compiler with support for RCCL    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--with-hdf5</code>   </td><td class="markdownTableBodyNone">Compile with support for HDF5    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--with-pfunit=DIR</code>   </td><td class="markdownTableBodyNone">Directory for pFUnit (see <a class="el" href="../../d5/d75/testing.html">Testing</a>)   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Accelerators backends are not enabled as a feature in Neko, but rather via optional packages.</dd></dl>
<p>Once configured, to compile and install Neko issue <code>make</code> followed by <code>make install</code></p>
<h3><a class="anchor" id="autotoc_md115"></a>
Compiling Neko for CPU or SX-Aurora</h3>
<p>For a standard CPU or SX-Aurora build of Neko, simply run the <code>configure</code> script as given above, using appropriate compilers and compiler flags, e.g:</p>
<div class="fragment"><div class="line">$ ./configure FC=gfortran FCFLAGS=&quot;-O2 -pedantic -std=f2008&quot; --prefix=/opt/pkg/neko</div>
<div class="line">$ make &amp;&amp; make install</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md116"></a>
Compiling Neko for NVIDIA GPUs</h3>
<p>To compile Neko for NVIDIA GPUs</p><ul>
<li>Make sure you have the CUDA Toolkit installed (e.g. <code>nvidia-cuda-toolkit</code>)</li>
<li>Configure Neko to use CUDA using the <code>--with-cuda=/path/to/cuda</code> argument to <code>configure</code>, e.g.: <div class="fragment"><div class="line">$ ./configure  --with-cuda=/usr/local/cuda</div>
</div><!-- fragment --></li>
<li>CUDA compiler flags and options can be passed using <code>CUDA_CFLAGS</code>, <code>CUDA_ARCH</code> and <code>NVCC</code> respectively, e.g: <div class="fragment"><div class="line">$ ./configure  --with-cuda=/usr/local/cuda CUDA_CFLAGS=-O3  CUDA_ARCH=-arch=sm_80 NVCC=/usr/local/cuda/bin/nvcc</div>
</div><!-- fragment --></li>
<li>Build using <code>make &amp;&amp; make install</code></li>
</ul>
<h3><a class="anchor" id="autotoc_md117"></a>
Compiling Neko for AMD GPUs</h3>
<p>To compile Neko for AMD GPUs</p><ul>
<li>Make sure you have the ROCm Toolkit installed</li>
<li>Configure Neko to use HIP using the <code>--with-hip=/path/to/hip</code> argument to <code>configure</code>, e.g.: <div class="fragment"><div class="line">$ ./configure  --with-hip=/opt/rocm/hip</div>
</div><!-- fragment --></li>
<li>HIP compiler flags and options can be passed using HIP_HIPCC_FLAGS and HIPCC, respectively, e.g.: <div class="fragment"><div class="line">$ ./configure  --with-hip=/opt/rocm/hip HIP_HIPCC_FLAGS=-O3  HIPCC=/opt/rocm/hip/bin/hipcc</div>
</div><!-- fragment --></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>More examples, and instructions for specific machines can be found on Neko's <a href="https://github.com/ExtremeFLOW/neko/discussions">user discussions</a> pages.</dd></dl>
<h3><a class="anchor" id="autotoc_md118"></a>
Compiling Neko with a collective communications library</h3>
<p>To compile Neko to use a collective communcations library on GPUs</p><ul>
<li>Configure Neko to use NCCL (on NVIDIA GPUs) using the <code>--with-nccl=/path/to/nccl</code> argument to <code>configure</code></li>
<li>Configure Neko to use RCCL (on AMD GPUs) using the <code>--with-rccl=/path/to/rccl</code> argument to <code>configure</code></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This will change all collective communications (reductions etc) during a simulation step to use NCCL/RCCL, while gather-scatter operations still uses MPI.</dd></dl>
<h1><a class="anchor" id="autotoc_md119"></a>
Installing via Spack</h1>
<p>Neko is distributed as part of the package manager Spack as <code>neko</code>. The package can install releases of Neko as well as the latest commit to the <code>develop</code> branch, for most of Neko's supported backends. For a list of all supported variants, see <code>spack info neko</code></p>
<h2><a class="anchor" id="autotoc_md120"></a>
Quick start guide with Spack</h2>
<p>To install a CPU build of Neko using Spack, follow the steps below:</p>
<div class="fragment"><div class="line"> shell</div>
<div class="line">$ git clone https://github.com/spack/spack.git</div>
<div class="line">$ cd spack</div>
<div class="line">$ . share/spack/setup-env.sh</div>
<div class="line">$ spack install neko</div>
</div><!-- fragment --><p> For a GPU build using e.g. CUDA, change the last line to :</p>
<div class="fragment"><div class="line"> shell</div>
<div class="line">$ spack install neko+cuda</div>
</div><!-- fragment --><p>For a more detailed guide on getting started with Spack, please refer to the offical documentation: <a href="https://spack.readthedocs.io/en/latest/getting_started.html">https://spack.readthedocs.io/en/latest/getting_started.html</a></p>
<h1><a class="anchor" id="autotoc_md121"></a>
Installing using pixi</h1>
<p>Pixi is a package managment tool using conda under the hood. It is very easy to install. For more information see (pixi.sh)[pixi.sh].</p>
<div class="fragment"><div class="line">curl -fsSL https://pixi.sh/install.sh | sh</div>
</div><!-- fragment --><p>Pixi will leverage conda to install all the dependencies, including basic ones like <code>gfortran</code> and <code>openmpi</code>. All of these will be installed inside an isolated environment. So, to install Neko simply clone the repo with git, and run the following command inside it</p>
<div class="fragment"><div class="line">pixi run install-neko-cpu</div>
</div><!-- fragment --><p>This will give you a double-precision CPU build charged with all optional dependencies: hdf5, and parmetis. For now, this is the only configuration that can be installed automatically with pixi.</p>
<p>To use Neko, you need to drop into a shell, where the pixi environment will be activated. For that run</p>
<div class="fragment"><div class="line">pixi shell</div>
</div><!-- fragment --><p>The <code>neko</code> and <code>makeneko</code> executables are already be in your <code>PATH</code>, so you can start running cases!</p>
<p>The installed executables, libraries, etc. are all located inside the <code>install</code> folder in the repo.</p>
<p>Note that you can use this pixi environment as you like, including manually <code>configuring</code> and building Neko (as per instructions for building from source), for example, with single precision reals or even with a different backend.</p>
<h1><a class="anchor" id="autotoc_md122"></a>
Using a Docker container</h1>
<p>Perhaps the easiest way to quickly give Neko a try is using a Docker container. Below we assume that you have Docker up and running on your system. The released container images can be found here: <a href="https://gitlab.com/ExtremeFLOW/neko/container_registry">https://gitlab.com/ExtremeFLOW/neko/container_registry</a>. Select the image with the release you want to use. Here we will use version 0.6.1, but in most cases you will want to simply pick up the latest version available. To the left of every image there is a button with three dots. Click on it to get the full path to the image in the correct format for Docker. For our release this is <code>registry.gitlab.com/extremeflow/neko/release-0.6.1-ubunut20.04-x86_64-gcc-12.3</code>. To get the image on you machine use <code>docker pull</code>:</p>
<div class="fragment"><div class="line">docker pull registry.gitlab.com/extremeflow/neko/release-0.6.1-ubunut20.04-x86_64-gcc-12.3</div>
</div><!-- fragment --><p>Now, let's verify that the image has been added using <code>docker image ls</code>. There should be a row of the following kind in the output.</p>
<div class="fragment"><div class="line">registry.gitlab.com/extremeflow/neko/release-0.6.1-ubunut20.04-x86_64-gcc-12.3   latest    6a9febfaa645   3 months ago    2.71GB</div>
</div><!-- fragment --><p>The third column contains the ID of the image. We will need that to run Neko in the container. The typical scenario is that you want to run a case stored on your computer inside the container. For that we will need to mount the directory with the case to the container file system. This is done using the the <code>-v</code> flag to the <code>docker run</code> command. For example, we will consider that the case resides in <code>/home/user/case</code> and we will mount it to <code>/case</code> inside the container. The full command to execute is the following:</p>
<div class="fragment"><div class="line">docker run --rm -v /home/user/case:/case 6a9febfaa645 bin/bash -c &quot;cd /case &amp;&amp; mpirun -n 2 neko case_file.case&quot;</div>
</div><!-- fragment --><p>The <code>--rm</code> flag tells Docker to remove the container after the run is finished. Note that we use the image ID from before as the third argument. As the run command we simply use <code>bash</code>, followed by a sequence of commands to actually execute the case. The commands are chained using <code>&amp;&amp;</code>, so one can easily add additional steps, for example, running <code>makeneko</code>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Neko Manual</a></li><li class="navelem"><a class="el" href="../../dd/d04/user-guide.html">User guide</a></li>
    <li class="footer">Generated on Sat Nov 22 2025 03:42:57 for Neko by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
